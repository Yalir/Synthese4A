<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>protocols/sametime/sametime.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('sametime_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">protocols/sametime/sametime.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">/*</span>
<a name="l00003"></a>00003 <span class="comment">  Meanwhile Protocol Plugin for Purple</span>
<a name="l00004"></a>00004 <span class="comment">  Adds Lotus Sametime support to Purple using the Meanwhile library</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">  Copyright (C) 2004 Christopher (siege) O&#39;Brien &lt;siege@preoccupied.net&gt;</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">  This program is free software; you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
<a name="l00010"></a>00010 <span class="comment">  the Free Software Foundation; either version 2 of the License, or (at</span>
<a name="l00011"></a>00011 <span class="comment">  your option) any later version.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">  This program is distributed in the hope that it will be useful, but</span>
<a name="l00014"></a>00014 <span class="comment">  WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00015"></a>00015 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<a name="l00016"></a>00016 <span class="comment">  General Public License for more details.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">  You should have received a copy of the GNU General Public License</span>
<a name="l00019"></a>00019 <span class="comment">  along with this program; if not, write to the Free Software</span>
<a name="l00020"></a>00020 <span class="comment">  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02111-1301,</span>
<a name="l00021"></a>00021 <span class="comment">  USA.</span>
<a name="l00022"></a>00022 <span class="comment">*/</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;internal.h&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">/* system includes */</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;time.h&gt;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="comment">/* glib includes */</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;glib.h&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="comment">/* purple includes */</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="account_8h.html">account.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="accountopt_8h.html">accountopt.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="circbuffer_8h.html">circbuffer.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="conversation_8h.html">conversation.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="debug_8h.html">debug.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="ft_8h.html">ft.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="imgstore_8h.html">imgstore.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="mime_8h.html">mime.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="notify_8h.html">notify.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="plugin_8h.html">plugin.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="privacy_8h.html">privacy.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="prpl_8h.html">prpl.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="request_8h.html">request.h</a>&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="util_8h.html">util.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="version_8h.html">version.h</a>&quot;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="comment">/* meanwhile includes */</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;mw_cipher.h&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;mw_common.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &lt;mw_error.h&gt;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;mw_service.h&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;mw_session.h&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;mw_srvc_aware.h&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;mw_srvc_conf.h&gt;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;mw_srvc_ft.h&gt;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &lt;mw_srvc_im.h&gt;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;mw_srvc_place.h&gt;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &lt;mw_srvc_resolve.h&gt;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &lt;mw_srvc_store.h&gt;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &lt;mw_st_list.h&gt;</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="comment">/* plugin includes */</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &quot;sametime.h&quot;</span>
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">/* considering that there&#39;s no display of this information for prpls,</span>
<a name="l00070"></a>00070 <span class="comment">   I don&#39;t know why I even bother providing these. Oh valiant reader,</span>
<a name="l00071"></a>00071 <span class="comment">   I do it all for you. */</span>
<a name="l00072"></a>00072 <span class="comment">/* scratch that, I just added it to the prpl options panel */</span>
<a name="l00073"></a>00073 <span class="preprocessor">#define PLUGIN_ID        &quot;prpl-meanwhile&quot;</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#define PLUGIN_NAME      &quot;Sametime&quot;</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#define PLUGIN_SUMMARY   &quot;Sametime Protocol Plugin&quot;</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#define PLUGIN_DESC      &quot;Open implementation of a Lotus Sametime client&quot;</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">#define PLUGIN_AUTHOR    &quot;Christopher (siege) O&#39;Brien &lt;siege@preoccupied.net&gt;&quot;</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">#define PLUGIN_HOMEPAGE  &quot;http://meanwhile.sourceforge.net/&quot;</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">/* plugin preference names */</span>
<a name="l00082"></a>00082 <span class="preprocessor">#define MW_PRPL_OPT_BASE          &quot;/plugins/prpl/meanwhile&quot;</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#define MW_PRPL_OPT_BLIST_ACTION  MW_PRPL_OPT_BASE &quot;/blist_action&quot;</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#define MW_PRPL_OPT_PSYCHIC       MW_PRPL_OPT_BASE &quot;/psychic&quot;</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#define MW_PRPL_OPT_FORCE_LOGIN   MW_PRPL_OPT_BASE &quot;/force_login&quot;</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#define MW_PRPL_OPT_SAVE_DYNAMIC  MW_PRPL_OPT_BASE &quot;/save_dynamic&quot;</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="comment">/* stages of connecting-ness */</span>
<a name="l00090"></a>00090 <span class="preprocessor">#define MW_CONNECT_STEPS  11</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span>
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="comment">/* stages of conciousness */</span>
<a name="l00094"></a>00094 <span class="preprocessor">#define MW_STATE_OFFLINE      &quot;offline&quot;</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span><span class="preprocessor">#define MW_STATE_ACTIVE       &quot;active&quot;</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#define MW_STATE_AWAY         &quot;away&quot;</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#define MW_STATE_BUSY         &quot;dnd&quot;</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#define MW_STATE_MESSAGE      &quot;message&quot;</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">#define MW_STATE_ENLIGHTENED  &quot;buddha&quot;</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="comment">/* keys to get/set chat information */</span>
<a name="l00103"></a>00103 <span class="preprocessor">#define CHAT_KEY_CREATOR   &quot;chat.creator&quot;</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">#define CHAT_KEY_NAME      &quot;chat.name&quot;</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span><span class="preprocessor">#define CHAT_KEY_TOPIC     &quot;chat.topic&quot;</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#define CHAT_KEY_INVITE    &quot;chat.invite&quot;</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor">#define CHAT_KEY_IS_PLACE  &quot;chat.is_place&quot;</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="comment">/* key for associating a mwLoginType with a buddy */</span>
<a name="l00111"></a>00111 <span class="preprocessor">#define BUDDY_KEY_CLIENT  &quot;meanwhile.client&quot;</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>
<a name="l00113"></a>00113 <span class="comment">/* store the remote alias so that we can re-create it easily */</span>
<a name="l00114"></a>00114 <span class="preprocessor">#define BUDDY_KEY_NAME    &quot;meanwhile.shortname&quot;</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>
<a name="l00116"></a>00116 <span class="comment">/* enum mwSametimeUserType */</span>
<a name="l00117"></a>00117 <span class="preprocessor">#define BUDDY_KEY_TYPE    &quot;meanwhile.type&quot;</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span>
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="comment">/* key for the real group name for a meanwhile group */</span>
<a name="l00121"></a>00121 <span class="preprocessor">#define GROUP_KEY_NAME    &quot;meanwhile.group&quot;</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>
<a name="l00123"></a>00123 <span class="comment">/* enum mwSametimeGroupType */</span>
<a name="l00124"></a>00124 <span class="preprocessor">#define GROUP_KEY_TYPE    &quot;meanwhile.type&quot;</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span>
<a name="l00126"></a>00126 <span class="comment">/* NAB group owning account */</span>
<a name="l00127"></a>00127 <span class="preprocessor">#define GROUP_KEY_OWNER   &quot;meanwhile.account&quot;</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span>
<a name="l00129"></a>00129 <span class="comment">/* key gtk blist uses to indicate a collapsed group */</span>
<a name="l00130"></a>00130 <span class="preprocessor">#define GROUP_KEY_COLLAPSED  &quot;collapsed&quot;</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span>
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="comment">/* verification replacement */</span>
<a name="l00134"></a>00134 <span class="preprocessor">#define mwSession_NO_SECRET  &quot;meanwhile.no_secret&quot;</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="comment">/* keys to get/set purple plugin information */</span>
<a name="l00138"></a>00138 <span class="preprocessor">#define MW_KEY_HOST        &quot;server&quot;</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span><span class="preprocessor">#define MW_KEY_PORT        &quot;port&quot;</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor">#define MW_KEY_FORCE       &quot;force_login&quot;</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span><span class="preprocessor">#define MW_KEY_FAKE_IT     &quot;fake_client_id&quot;</span>
<a name="l00142"></a>00142 <span class="preprocessor"></span><span class="preprocessor">#define MW_KEY_CLIENT      &quot;client_id_val&quot;</span>
<a name="l00143"></a>00143 <span class="preprocessor"></span><span class="preprocessor">#define MW_KEY_MAJOR       &quot;client_major&quot;</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span><span class="preprocessor">#define MW_KEY_MINOR       &quot;client_minor&quot;</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span>
<a name="l00146"></a>00146 
<a name="l00149"></a>00149 <span class="preprocessor">#define BLIST_SAVE_SECONDS  15</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span>
<a name="l00151"></a>00151 
<a name="l00153"></a>00153 <span class="keyword">enum</span> blist_choice {
<a name="l00154"></a>00154   blist_choice_LOCAL = 1, 
<a name="l00155"></a>00155   blist_choice_MERGE = 2, 
<a name="l00156"></a>00156   blist_choice_STORE = 3, 
<a name="l00157"></a>00157   blist_choice_SYNCH = 4  
<a name="l00158"></a>00158 };
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 
<a name="l00162"></a>00162 <span class="preprocessor">#define BLIST_CHOICE_DEFAULT  blist_choice_SYNCH</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="comment">/* testing for the above */</span>
<a name="l00166"></a>00166 <span class="preprocessor">#define BLIST_PREF_IS(n) (purple_prefs_get_int(MW_PRPL_OPT_BLIST_ACTION)==(n))</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span><span class="preprocessor">#define BLIST_PREF_IS_LOCAL()  BLIST_PREF_IS(blist_choice_LOCAL)</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span><span class="preprocessor">#define BLIST_PREF_IS_MERGE()  BLIST_PREF_IS(blist_choice_MERGE)</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span><span class="preprocessor">#define BLIST_PREF_IS_STORE()  BLIST_PREF_IS(blist_choice_STORE)</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span><span class="preprocessor">#define BLIST_PREF_IS_SYNCH()  BLIST_PREF_IS(blist_choice_SYNCH)</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span>
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 <span class="comment">/* debugging output */</span>
<a name="l00174"></a>00174 <span class="preprocessor">#define DEBUG_ERROR(...)  purple_debug_error(G_LOG_DOMAIN, __VA_ARGS__)</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG_INFO(...)   purple_debug_info(G_LOG_DOMAIN, __VA_ARGS__)</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG_MISC(...)   purple_debug_misc(G_LOG_DOMAIN, __VA_ARGS__)</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG_WARN(...)   purple_debug_warning(G_LOG_DOMAIN, __VA_ARGS__)</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span>
<a name="l00179"></a>00179 
<a name="l00181"></a>00181 <span class="preprocessor">#ifndef NSTR</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span><span class="preprocessor"># define NSTR(str) ((str)? (str): &quot;(null)&quot;)</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span>
<a name="l00185"></a>00185 
<a name="l00187"></a>00187 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> no_secret[] = {
<a name="l00188"></a>00188   0x2d, 0x2d, 0x20, 0x73, 0x69, 0x65, 0x67, 0x65,
<a name="l00189"></a>00189   0x20, 0x6c, 0x6f, 0x76, 0x65, 0x73, 0x20, 0x6a,
<a name="l00190"></a>00190   0x65, 0x6e, 0x6e, 0x69, 0x20, 0x61, 0x6e, 0x64,
<a name="l00191"></a>00191   0x20, 0x7a, 0x6f, 0x65, 0x20, 0x2d, 0x2d, 0x00,
<a name="l00192"></a>00192 };
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 
<a name="l00196"></a>00196 <span class="keyword">static</span> guint log_handler[2] = { 0, 0 };
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 
<a name="l00201"></a><a class="code" href="structmw_purple_plugin_data.html">00201</a> <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> {
<a name="l00202"></a>00202   <span class="keyword">struct </span>mwSession *session;
<a name="l00203"></a>00203 
<a name="l00204"></a>00204   <span class="keyword">struct </span>mwServiceAware *srvc_aware;
<a name="l00205"></a>00205   <span class="keyword">struct </span>mwServiceConference *srvc_conf;
<a name="l00206"></a>00206   <span class="keyword">struct </span>mwServiceFileTransfer *srvc_ft;
<a name="l00207"></a>00207   <span class="keyword">struct </span>mwServiceIm *srvc_im;
<a name="l00208"></a>00208   <span class="keyword">struct </span>mwServicePlace *srvc_place;
<a name="l00209"></a>00209   <span class="keyword">struct </span>mwServiceResolve *srvc_resolve;
<a name="l00210"></a>00210   <span class="keyword">struct </span>mwServiceStorage *srvc_store;
<a name="l00211"></a>00211 
<a name="l00213"></a><a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">00213</a>   GHashTable *<a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">group_list_map</a>;
<a name="l00214"></a>00214 
<a name="l00216"></a><a class="code" href="structmw_purple_plugin_data.html#acac54485b7d345e826b6942f5f0186d6">00216</a>   guint <a class="code" href="structmw_purple_plugin_data.html#acac54485b7d345e826b6942f5f0186d6">save_event</a>;
<a name="l00217"></a>00217 
<a name="l00219"></a><a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">00219</a>   <span class="keywordtype">int</span> <a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>;
<a name="l00220"></a>00220   gint outpa;  <span class="comment">/* like inpa, but the other way */</span>
<a name="l00221"></a>00221 
<a name="l00223"></a><a class="code" href="structmw_purple_plugin_data.html#a4271075ebe80e8e123d1d22a2673ce6a">00223</a>   <a class="code" href="struct___purple_circ_buffer.html">PurpleCircBuffer</a> *<a class="code" href="structmw_purple_plugin_data.html#a4271075ebe80e8e123d1d22a2673ce6a">sock_buf</a>;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l00226"></a>00226 };
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 
<a name="l00229"></a><a class="code" href="struct_buddy_add_data.html">00229</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00230"></a>00230   <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy;
<a name="l00231"></a>00231   <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group;
<a name="l00232"></a>00232 } <a class="code" href="struct_buddy_add_data.html">BuddyAddData</a>;
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 <span class="comment">/* blist and aware functions */</span>
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_export(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">struct</span> mwSametimeList *stlist);
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_store(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_schedule(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd);
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_merge(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">struct</span> mwSametimeList *stlist);
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_sync(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">struct</span> mwSametimeList *stlist);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 <span class="keyword">static</span> gboolean buddy_is_external(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *b);
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="keyword">static</span> <span class="keywordtype">void</span> buddy_add(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd, <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="keyword">static</span> <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *
<a name="l00252"></a>00252 buddy_ensure(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group,
<a name="l00253"></a>00253              <span class="keyword">struct</span> mwSametimeUser *stuser);
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 <span class="keyword">static</span> <span class="keywordtype">void</span> group_add(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd, <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="keyword">static</span> <a class="code" href="struct___purple_group.html">PurpleGroup</a> *
<a name="l00258"></a>00258 group_ensure(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">struct</span> mwSametimeGroup *stgroup);
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 <span class="keyword">static</span> <span class="keyword">struct </span>mwAwareList *
<a name="l00261"></a>00261 list_ensure(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd, <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <span class="comment">/* session functions */</span>
<a name="l00265"></a>00265 
<a name="l00266"></a>00266 <span class="keyword">static</span> <span class="keyword">struct </span>mwSession *
<a name="l00267"></a>00267 gc_to_session(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="keyword">static</span> <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *session_to_gc(<span class="keyword">struct</span> mwSession *session);
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="comment">/* conference functions */</span>
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 <span class="keyword">static</span> <span class="keyword">struct </span>mwConference *
<a name="l00275"></a>00275 conf_find_by_id(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd, <span class="keywordtype">int</span> <span class="keywordtype">id</span>);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="comment">/* conversation functions */</span>
<a name="l00279"></a>00279 
<a name="l00280"></a><a class="code" href="structconvo__msg.html">00280</a> <span class="keyword">struct </span><a class="code" href="structconvo__msg.html">convo_msg</a> {
<a name="l00281"></a>00281   <span class="keyword">enum</span> mwImSendType type;
<a name="l00282"></a>00282   gpointer data;
<a name="l00283"></a>00283   GDestroyNotify clear;
<a name="l00284"></a>00284 };
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 
<a name="l00287"></a><a class="code" href="structconvo__data.html">00287</a> <span class="keyword">struct </span><a class="code" href="structconvo__data.html">convo_data</a> {
<a name="l00288"></a>00288   <span class="keyword">struct </span>mwConversation *conv;
<a name="l00289"></a><a class="code" href="structconvo__data.html#ad03c8a7f666aca2c5385d1526e5a292f">00289</a>   GList *<a class="code" href="structconvo__data.html#ad03c8a7f666aca2c5385d1526e5a292f">queue</a>;   
<a name="l00290"></a>00290 };
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="keyword">static</span> <span class="keywordtype">void</span> convo_data_new(<span class="keyword">struct</span> mwConversation *conv);
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 <span class="keyword">static</span> <span class="keywordtype">void</span> convo_data_free(<span class="keyword">struct</span> <a class="code" href="structconvo__data.html">convo_data</a> *conv);
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="keyword">static</span> <span class="keywordtype">void</span> convo_features(<span class="keyword">struct</span> mwConversation *conv);
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="keyword">static</span> <a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *convo_get_gconv(<span class="keyword">struct</span> mwConversation *conv);
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="comment">/* name and id */</span>
<a name="l00302"></a>00302 
<a name="l00303"></a><a class="code" href="structnamed__id.html">00303</a> <span class="keyword">struct </span><a class="code" href="structnamed__id.html">named_id</a> {
<a name="l00304"></a>00304   <span class="keywordtype">char</span> *id;
<a name="l00305"></a>00305   <span class="keywordtype">char</span> *name;
<a name="l00306"></a>00306 };
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 <span class="comment">/* connection functions */</span>
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="keyword">static</span> <span class="keywordtype">void</span> connect_cb(gpointer data, gint source, <span class="keyword">const</span> gchar *error_message);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="comment">/* ----- session ------ */</span>
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 
<a name="l00318"></a>00318 <span class="keyword">static</span> <span class="keyword">struct </span>mwSession *gc_to_session(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc) {
<a name="l00319"></a>00319   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321   g_return_val_if_fail(gc != NULL, NULL);
<a name="l00322"></a>00322 
<a name="l00323"></a>00323   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l00324"></a>00324   g_return_val_if_fail(pd != NULL, NULL);
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="keywordflow">return</span> pd-&gt;session;
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 
<a name="l00331"></a>00331 <span class="keyword">static</span> <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *session_to_gc(<span class="keyword">struct</span> mwSession *session) {
<a name="l00332"></a>00332   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334   g_return_val_if_fail(session != NULL, NULL);
<a name="l00335"></a>00335 
<a name="l00336"></a>00336   pd = mwSession_getClientData(session);
<a name="l00337"></a>00337   g_return_val_if_fail(pd != NULL, NULL);
<a name="l00338"></a>00338 
<a name="l00339"></a>00339   <span class="keywordflow">return</span> pd-&gt;gc;
<a name="l00340"></a>00340 }
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 <span class="keyword">static</span> <span class="keywordtype">void</span> write_cb(gpointer data, gint source, <a class="code" href="eventloop_8h.html#ae16a4b18f1da57dff1eb139e934fffb3">PurpleInputCondition</a> cond) {
<a name="l00344"></a>00344   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = data;
<a name="l00345"></a>00345   <a class="code" href="struct___purple_circ_buffer.html">PurpleCircBuffer</a> *circ = pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a4271075ebe80e8e123d1d22a2673ce6a">sock_buf</a>;
<a name="l00346"></a>00346   gsize avail;
<a name="l00347"></a>00347   <span class="keywordtype">int</span> ret;
<a name="l00348"></a>00348 
<a name="l00349"></a>00349   DEBUG_INFO(<span class="stringliteral">&quot;write_cb\n&quot;</span>);
<a name="l00350"></a>00350 
<a name="l00351"></a>00351   g_return_if_fail(circ != NULL);
<a name="l00352"></a>00352 
<a name="l00353"></a>00353   avail = purple_circ_buffer_get_max_read(circ);
<a name="l00354"></a>00354   <span class="keywordflow">if</span>(BUF_LONG &lt; avail) avail = BUF_LONG;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   <span class="keywordflow">while</span>(avail) {
<a name="l00357"></a>00357     ret = write(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>, circ-&gt;<a class="code" href="struct___purple_circ_buffer.html#a9282df7cb8bb4cc968362f122d706664">outptr</a>, avail);
<a name="l00358"></a>00358 
<a name="l00359"></a>00359     <span class="keywordflow">if</span>(ret &lt;= 0)
<a name="l00360"></a>00360       <span class="keywordflow">break</span>;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362     purple_circ_buffer_mark_read(circ, ret);
<a name="l00363"></a>00363     avail = purple_circ_buffer_get_max_read(circ);
<a name="l00364"></a>00364     <span class="keywordflow">if</span>(BUF_LONG &lt; avail) avail = BUF_LONG;
<a name="l00365"></a>00365   }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   <span class="keywordflow">if</span>(! avail) {
<a name="l00368"></a>00368     <a class="code" href="eventloop_8c.html#ae309cb053b0e7984f10d9886367ed84e">purple_input_remove</a>(pd-&gt;outpa);
<a name="l00369"></a>00369     pd-&gt;outpa = 0;
<a name="l00370"></a>00370   }
<a name="l00371"></a>00371 }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="keyword">static</span> <span class="keywordtype">int</span> mw_session_io_write(<span class="keyword">struct</span> mwSession *session,
<a name="l00375"></a>00375                                <span class="keyword">const</span> guchar *buf, gsize len) {
<a name="l00376"></a>00376   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l00377"></a>00377   gssize ret = 0;
<a name="l00378"></a>00378   <span class="keywordtype">int</span> err = 0;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   pd = mwSession_getClientData(session);
<a name="l00381"></a>00381 
<a name="l00382"></a>00382   <span class="comment">/* socket was already closed. */</span>
<a name="l00383"></a>00383   <span class="keywordflow">if</span>(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a> == 0)
<a name="l00384"></a>00384     <span class="keywordflow">return</span> 1;
<a name="l00385"></a>00385 
<a name="l00386"></a>00386   <span class="keywordflow">if</span>(pd-&gt;outpa) {
<a name="l00387"></a>00387     DEBUG_INFO(<span class="stringliteral">&quot;already pending INPUT_WRITE, buffering\n&quot;</span>);
<a name="l00388"></a>00388     purple_circ_buffer_append(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a4271075ebe80e8e123d1d22a2673ce6a">sock_buf</a>, buf, len);
<a name="l00389"></a>00389     <span class="keywordflow">return</span> 0;
<a name="l00390"></a>00390   }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392   <span class="keywordflow">while</span>(len) {
<a name="l00393"></a>00393     ret = write(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>, buf, (len &gt; BUF_LEN)? BUF_LEN: len);
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     <span class="keywordflow">if</span>(ret &lt;= 0)
<a name="l00396"></a>00396       <span class="keywordflow">break</span>;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     len -= ret;
<a name="l00399"></a>00399     buf += ret;
<a name="l00400"></a>00400   }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <span class="keywordflow">if</span>(ret &lt;= 0)
<a name="l00403"></a>00403     err = errno;
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <span class="keywordflow">if</span>(err == EAGAIN) {
<a name="l00406"></a>00406     <span class="comment">/* append remainder to circular buffer */</span>
<a name="l00407"></a>00407     DEBUG_INFO(<span class="stringliteral">&quot;EAGAIN\n&quot;</span>);
<a name="l00408"></a>00408     purple_circ_buffer_append(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a4271075ebe80e8e123d1d22a2673ce6a">sock_buf</a>, buf, len);
<a name="l00409"></a>00409     pd-&gt;outpa = <a class="code" href="eventloop_8c.html#ad4f7f5fdc0ee617d0e3fe358f04f838b">purple_input_add</a>(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>, <a class="code" href="eventloop_8h.html#ae16a4b18f1da57dff1eb139e934fffb3a00c293d57b62e5a9c09e4539ade9d51c">PURPLE_INPUT_WRITE</a>, write_cb, pd);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(len &gt; 0) {
<a name="l00412"></a>00412         gchar *tmp = g_strdup_printf(_(<span class="stringliteral">&quot;Lost connection with server: %s&quot;</span>),
<a name="l00413"></a>00413                         g_strerror(errno));
<a name="l00414"></a>00414     DEBUG_ERROR(<span class="stringliteral">&quot;write returned %&quot;</span> G_GSSIZE_FORMAT <span class="stringliteral">&quot;, %&quot;</span> G_GSIZE_FORMAT
<a name="l00415"></a>00415                         <span class="stringliteral">&quot; bytes left unwritten\n&quot;</span>, ret, len);
<a name="l00416"></a>00416     purple_connection_error_reason(pd-&gt;gc,
<a name="l00417"></a>00417                                    <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4dae83601cb8c581624c7af7dd81b5eaac9">PURPLE_CONNECTION_ERROR_NETWORK_ERROR</a>,
<a name="l00418"></a>00418                                    tmp);
<a name="l00419"></a>00419         g_free(tmp);
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 <span class="preprocessor">#if 0</span>
<a name="l00422"></a>00422 <span class="preprocessor"></span>    close(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>);
<a name="l00423"></a>00423     pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a> = 0;
<a name="l00424"></a>00424 <span class="preprocessor">#endif</span>
<a name="l00425"></a>00425 <span class="preprocessor"></span>
<a name="l00426"></a>00426     <span class="keywordflow">return</span> -1;
<a name="l00427"></a>00427   }
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="keywordflow">return</span> 0;
<a name="l00430"></a>00430 }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 
<a name="l00433"></a>00433 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_session_io_close(<span class="keyword">struct</span> mwSession *session) {
<a name="l00434"></a>00434   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l00435"></a>00435   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l00436"></a>00436 
<a name="l00437"></a>00437   pd = mwSession_getClientData(session);
<a name="l00438"></a>00438   g_return_if_fail(pd != NULL);
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   gc = pd-&gt;gc;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442   <span class="keywordflow">if</span>(pd-&gt;outpa) {
<a name="l00443"></a>00443     <a class="code" href="eventloop_8c.html#ae309cb053b0e7984f10d9886367ed84e">purple_input_remove</a>(pd-&gt;outpa);
<a name="l00444"></a>00444     pd-&gt;outpa = 0;
<a name="l00445"></a>00445   }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447   <span class="keywordflow">if</span>(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>) {
<a name="l00448"></a>00448     close(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>);
<a name="l00449"></a>00449     pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a> = 0;
<a name="l00450"></a>00450   }
<a name="l00451"></a>00451 
<a name="l00452"></a>00452   <span class="keywordflow">if</span>(gc-&gt;<a class="code" href="struct___purple_connection.html#a58491547528ab1611acab75d3eccbbbe">inpa</a>) {
<a name="l00453"></a>00453     <a class="code" href="eventloop_8c.html#ae309cb053b0e7984f10d9886367ed84e">purple_input_remove</a>(gc-&gt;<a class="code" href="struct___purple_connection.html#a58491547528ab1611acab75d3eccbbbe">inpa</a>);
<a name="l00454"></a>00454     gc-&gt;<a class="code" href="struct___purple_connection.html#a58491547528ab1611acab75d3eccbbbe">inpa</a> = 0;
<a name="l00455"></a>00455   }
<a name="l00456"></a>00456 }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_session_clear(<span class="keyword">struct</span> mwSession *session) {
<a name="l00460"></a>00460   ; <span class="comment">/* nothing for now */</span>
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="comment">/* ----- aware list ----- */</span>
<a name="l00465"></a>00465 
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_resolve_alias_cb(<span class="keyword">struct</span> mwServiceResolve *srvc,
<a name="l00468"></a>00468                                    guint32 <span class="keywordtype">id</span>, guint32 code, GList *results,
<a name="l00469"></a>00469                                    gpointer data) {
<a name="l00470"></a>00470   <span class="keyword">struct </span>mwResolveResult *result;
<a name="l00471"></a>00471   <span class="keyword">struct </span>mwResolveMatch *match;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473   g_return_if_fail(results != NULL);
<a name="l00474"></a>00474 
<a name="l00475"></a>00475   result = results-&gt;data;
<a name="l00476"></a>00476   g_return_if_fail(result != NULL);
<a name="l00477"></a>00477   g_return_if_fail(result-&gt;matches != NULL);
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   match = result-&gt;matches-&gt;data;
<a name="l00480"></a>00480   g_return_if_fail(match != NULL);
<a name="l00481"></a>00481 
<a name="l00482"></a>00482   purple_blist_server_alias_buddy(data, match-&gt;name);
<a name="l00483"></a>00483   purple_blist_node_set_string(data, BUDDY_KEY_NAME, match-&gt;name);
<a name="l00484"></a>00484 }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_aware_list_on_aware(<span class="keyword">struct</span> mwAwareList *list,
<a name="l00488"></a>00488                                    <span class="keyword">struct</span> mwAwareSnapshot *aware) {
<a name="l00489"></a>00489 
<a name="l00490"></a>00490   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l00491"></a>00491   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l00494"></a>00494   guint32 idle;
<a name="l00495"></a>00495   guint stat;
<a name="l00496"></a>00496   <span class="keyword">const</span> <span class="keywordtype">char</span> *id;
<a name="l00497"></a>00497   <span class="keyword">const</span> <span class="keywordtype">char</span> *status = MW_STATE_ACTIVE;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   gc = mwAwareList_getClientData(list);
<a name="l00500"></a>00500   acct = purple_connection_get_account(gc);
<a name="l00501"></a>00501 
<a name="l00502"></a>00502   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l00503"></a>00503   idle = aware-&gt;status.time;
<a name="l00504"></a>00504   stat = aware-&gt;status.status;
<a name="l00505"></a>00505   <span class="keywordtype">id</span> = aware-&gt;id.user;
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   <span class="keywordflow">if</span>(idle) {
<a name="l00508"></a>00508     guint32 idle_len;       <span class="comment">/*&lt; how long a client has been idle */</span>
<a name="l00509"></a>00509     guint32 ugly_idle_len;  <span class="comment">/*&lt; how long a broken client has been idle */</span>
<a name="l00510"></a>00510 
<a name="l00511"></a>00511     DEBUG_INFO(<span class="stringliteral">&quot;%s has idle value 0x%x\n&quot;</span>, NSTR(<span class="keywordtype">id</span>), idle);
<a name="l00512"></a>00512 
<a name="l00513"></a>00513     idle_len = time(NULL) - idle;
<a name="l00514"></a>00514     ugly_idle_len = ((time(NULL) * 1000) - idle) / 1000;
<a name="l00515"></a>00515 
<a name="l00516"></a>00516         <span class="keywordflow">if</span>(idle &gt; ugly_idle_len)
<a name="l00517"></a>00517                 ugly_idle_len = 0;
<a name="l00518"></a>00518         <span class="keywordflow">else</span>
<a name="l00519"></a>00519                 ugly_idle_len = (ugly_idle_len - idle) / 1000;
<a name="l00520"></a>00520 
<a name="l00521"></a>00521     <span class="comment">/*</span>
<a name="l00522"></a>00522 <span class="comment">       what&#39;s the deal here? Well, good clients are smart enough to</span>
<a name="l00523"></a>00523 <span class="comment">       publish their idle time by using an attribute to indicate that</span>
<a name="l00524"></a>00524 <span class="comment">       they went idle at some time UTC, in seconds since epoch. Bad</span>
<a name="l00525"></a>00525 <span class="comment">       clients use milliseconds since epoch. So we&#39;re going to compute</span>
<a name="l00526"></a>00526 <span class="comment">       the idle time for either method, then figure out the lower of</span>
<a name="l00527"></a>00527 <span class="comment">       the two and use that. Blame the ST 7.5 development team for</span>
<a name="l00528"></a>00528 <span class="comment">       this.</span>
<a name="l00529"></a>00529 <span class="comment">     */</span>
<a name="l00530"></a>00530 
<a name="l00531"></a>00531     DEBUG_INFO(<span class="stringliteral">&quot;idle time: %u, ugly idle time: %u\n&quot;</span>, idle_len, ugly_idle_len);
<a name="l00532"></a>00532 
<a name="l00533"></a>00533 <span class="preprocessor">#if 1</span>
<a name="l00534"></a>00534 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(idle_len &lt;= ugly_idle_len) {
<a name="l00535"></a>00535       ; <span class="comment">/* DEBUG_INFO(&quot;sane idle value, let&#39;s use it\n&quot;); */</span>
<a name="l00536"></a>00536     } <span class="keywordflow">else</span> {
<a name="l00537"></a>00537       idle = time(NULL) - ugly_idle_len;
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 <span class="preprocessor">#else</span>
<a name="l00541"></a>00541 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(idle &lt; 0 || idle &gt; time(NULL)) {
<a name="l00542"></a>00542       DEBUG_INFO(<span class="stringliteral">&quot;hiding a messy idle value 0x%x\n&quot;</span>, NSTR(<span class="keywordtype">id</span>), idle);
<a name="l00543"></a>00543       idle = -1;
<a name="l00544"></a>00544     }
<a name="l00545"></a>00545 <span class="preprocessor">#endif</span>
<a name="l00546"></a>00546 <span class="preprocessor"></span>  }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548   <span class="keywordflow">switch</span>(stat) {
<a name="l00549"></a>00549   <span class="keywordflow">case</span> mwStatus_ACTIVE:
<a name="l00550"></a>00550     status = MW_STATE_ACTIVE;
<a name="l00551"></a>00551     idle = 0;
<a name="l00552"></a>00552     <span class="keywordflow">break</span>;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554   <span class="keywordflow">case</span> mwStatus_IDLE:
<a name="l00555"></a>00555     <span class="keywordflow">if</span>(! idle) idle = -1;
<a name="l00556"></a>00556     <span class="keywordflow">break</span>;
<a name="l00557"></a>00557 
<a name="l00558"></a>00558   <span class="keywordflow">case</span> mwStatus_AWAY:
<a name="l00559"></a>00559     status = MW_STATE_AWAY;
<a name="l00560"></a>00560     <span class="keywordflow">break</span>;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   <span class="keywordflow">case</span> mwStatus_BUSY:
<a name="l00563"></a>00563     status = MW_STATE_BUSY;
<a name="l00564"></a>00564     <span class="keywordflow">break</span>;
<a name="l00565"></a>00565   }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567   <span class="comment">/* NAB group members */</span>
<a name="l00568"></a>00568   <span class="keywordflow">if</span>(aware-&gt;group) {
<a name="l00569"></a>00569     <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group;
<a name="l00570"></a>00570     <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy;
<a name="l00571"></a>00571     <a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *bnode;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573     group = g_hash_table_lookup(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">group_list_map</a>, list);
<a name="l00574"></a>00574     buddy = purple_find_buddy_in_group(acct, <span class="keywordtype">id</span>, group);
<a name="l00575"></a>00575     bnode = (<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) buddy;
<a name="l00576"></a>00576 
<a name="l00577"></a>00577     <span class="keywordflow">if</span>(! buddy) {
<a name="l00578"></a>00578       <span class="keyword">struct </span>mwServiceResolve *srvc;
<a name="l00579"></a>00579       GList *query;
<a name="l00580"></a>00580 
<a name="l00581"></a>00581       buddy = purple_buddy_new(acct, <span class="keywordtype">id</span>, NULL);
<a name="l00582"></a>00582       purple_blist_add_buddy(buddy, NULL, group, NULL);
<a name="l00583"></a>00583 
<a name="l00584"></a>00584       bnode = (<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) buddy;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586       srvc = pd-&gt;srvc_resolve;
<a name="l00587"></a>00587       query = g_list_append(NULL, (<span class="keywordtype">char</span> *) <span class="keywordtype">id</span>);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589       mwServiceResolve_resolve(srvc, query, mwResolveFlag_USERS,
<a name="l00590"></a>00590                                blist_resolve_alias_cb, buddy, NULL);
<a name="l00591"></a>00591       g_list_free(query);
<a name="l00592"></a>00592     }
<a name="l00593"></a>00593 
<a name="l00594"></a>00594     purple_blist_node_set_int(bnode, BUDDY_KEY_TYPE, mwSametimeUser_NORMAL);
<a name="l00595"></a>00595   }
<a name="l00596"></a>00596 
<a name="l00597"></a>00597   <span class="keywordflow">if</span>(aware-&gt;online) {
<a name="l00598"></a>00598     purple_prpl_got_user_status(acct, <span class="keywordtype">id</span>, status, NULL);
<a name="l00599"></a>00599     purple_prpl_got_user_idle(acct, <span class="keywordtype">id</span>, !!idle, (time_t) idle);
<a name="l00600"></a>00600 
<a name="l00601"></a>00601   } <span class="keywordflow">else</span> {
<a name="l00602"></a>00602     purple_prpl_got_user_status(acct, <span class="keywordtype">id</span>, MW_STATE_OFFLINE, NULL);
<a name="l00603"></a>00603   }
<a name="l00604"></a>00604 }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_aware_list_on_attrib(<span class="keyword">struct</span> mwAwareList *list,
<a name="l00608"></a>00608                                     <span class="keyword">struct</span> mwAwareIdBlock *<span class="keywordtype">id</span>,
<a name="l00609"></a>00609                                     <span class="keyword">struct</span> mwAwareAttribute *attrib) {
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   ; <span class="comment">/* nothing. We&#39;ll get attribute data as we need it */</span>
<a name="l00612"></a>00612 }
<a name="l00613"></a>00613 
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_aware_list_clear(<span class="keyword">struct</span> mwAwareList *list) {
<a name="l00616"></a>00616   ; <span class="comment">/* nothing for now */</span>
<a name="l00617"></a>00617 }
<a name="l00618"></a>00618 
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 <span class="keyword">static</span> <span class="keyword">struct </span>mwAwareListHandler mw_aware_list_handler = {
<a name="l00621"></a>00621   mw_aware_list_on_aware,
<a name="l00622"></a>00622   mw_aware_list_on_attrib,
<a name="l00623"></a>00623   mw_aware_list_clear,
<a name="l00624"></a>00624 };
<a name="l00625"></a>00625 
<a name="l00626"></a>00626 
<a name="l00629"></a>00629 <span class="keyword">static</span> <span class="keyword">struct </span>mwAwareList *
<a name="l00630"></a>00630 list_ensure(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd, <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group) {
<a name="l00631"></a>00631 
<a name="l00632"></a>00632   <span class="keyword">struct </span>mwAwareList *list;
<a name="l00633"></a>00633 
<a name="l00634"></a>00634   g_return_val_if_fail(pd != NULL, NULL);
<a name="l00635"></a>00635   g_return_val_if_fail(group != NULL, NULL);
<a name="l00636"></a>00636 
<a name="l00637"></a>00637   list = g_hash_table_lookup(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">group_list_map</a>, group);
<a name="l00638"></a>00638   <span class="keywordflow">if</span>(! list) {
<a name="l00639"></a>00639     list = mwAwareList_new(pd-&gt;srvc_aware, &amp;mw_aware_list_handler);
<a name="l00640"></a>00640     mwAwareList_setClientData(list, pd-&gt;gc, NULL);
<a name="l00641"></a>00641 
<a name="l00642"></a>00642     mwAwareList_watchAttributes(list,
<a name="l00643"></a>00643                                 mwAttribute_AV_PREFS_SET,
<a name="l00644"></a>00644                                 mwAttribute_MICROPHONE,
<a name="l00645"></a>00645                                 mwAttribute_SPEAKERS,
<a name="l00646"></a>00646                                 mwAttribute_VIDEO_CAMERA,
<a name="l00647"></a>00647                                 mwAttribute_FILE_TRANSFER,
<a name="l00648"></a>00648                                 NULL);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650     g_hash_table_replace(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">group_list_map</a>, group, list);
<a name="l00651"></a>00651     g_hash_table_insert(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">group_list_map</a>, list, group);
<a name="l00652"></a>00652   }
<a name="l00653"></a>00653 
<a name="l00654"></a>00654   <span class="keywordflow">return</span> list;
<a name="l00655"></a>00655 }
<a name="l00656"></a>00656 
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_export(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">struct</span> mwSametimeList *stlist) {
<a name="l00659"></a>00659   <span class="comment">/* - find the account for this connection</span>
<a name="l00660"></a>00660 <span class="comment">     - iterate through the buddy list</span>
<a name="l00661"></a>00661 <span class="comment">     - add each buddy matching this account to the stlist</span>
<a name="l00662"></a>00662 <span class="comment">  */</span>
<a name="l00663"></a>00663 
<a name="l00664"></a>00664   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l00665"></a>00665   <a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *gn, *cn, *bn;
<a name="l00666"></a>00666   <a class="code" href="struct___purple_group.html">PurpleGroup</a> *grp;
<a name="l00667"></a>00667   <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *bdy;
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   <span class="keyword">struct </span>mwSametimeGroup *stg = NULL;
<a name="l00670"></a>00670   <span class="keyword">struct </span>mwIdBlock idb = { NULL, NULL };
<a name="l00671"></a>00671 
<a name="l00672"></a>00672   acct = purple_connection_get_account(gc);
<a name="l00673"></a>00673   g_return_if_fail(acct != NULL);
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <span class="keywordflow">for</span>(gn = purple_blist_get_root(); gn;
<a name="l00676"></a>00676                   gn = purple_blist_node_get_sibling_next(gn)) {
<a name="l00677"></a>00677     <span class="keyword">const</span> <span class="keywordtype">char</span> *owner;
<a name="l00678"></a>00678     <span class="keyword">const</span> <span class="keywordtype">char</span> *gname;
<a name="l00679"></a>00679     <span class="keyword">enum</span> mwSametimeGroupType gtype;
<a name="l00680"></a>00680     gboolean gopen;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_GROUP(gn)) <span class="keywordflow">continue</span>;
<a name="l00683"></a>00683     grp = (<a class="code" href="struct___purple_group.html">PurpleGroup</a> *) gn;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685     <span class="comment">/* the group&#39;s type (normal or dynamic) */</span>
<a name="l00686"></a>00686     gtype = purple_blist_node_get_int(gn, GROUP_KEY_TYPE);
<a name="l00687"></a>00687     <span class="keywordflow">if</span>(! gtype) gtype = mwSametimeGroup_NORMAL;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     <span class="comment">/* if it&#39;s a normal group with none of our people in it, skip it */</span>
<a name="l00690"></a>00690     <span class="keywordflow">if</span>(gtype == mwSametimeGroup_NORMAL &amp;&amp; !purple_group_on_account(grp, acct))
<a name="l00691"></a>00691       <span class="keywordflow">continue</span>;
<a name="l00692"></a>00692 
<a name="l00693"></a>00693     <span class="comment">/* if the group has an owner and we&#39;re not it, skip it */</span>
<a name="l00694"></a>00694     owner = purple_blist_node_get_string(gn, GROUP_KEY_OWNER);
<a name="l00695"></a>00695     <span class="keywordflow">if</span>(owner &amp;&amp; strcmp(owner, purple_account_get_username(acct)))
<a name="l00696"></a>00696       <span class="keywordflow">continue</span>;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698     <span class="comment">/* the group&#39;s actual name may be different from the purple group&#39;s</span>
<a name="l00699"></a>00699 <span class="comment">       name. Find whichever is there */</span>
<a name="l00700"></a>00700     gname = purple_blist_node_get_string(gn, GROUP_KEY_NAME);
<a name="l00701"></a>00701     <span class="keywordflow">if</span>(! gname) gname = purple_group_get_name(grp);
<a name="l00702"></a>00702 
<a name="l00703"></a>00703     <span class="comment">/* we save this, but never actually honor it */</span>
<a name="l00704"></a>00704     gopen = ! purple_blist_node_get_bool(gn, GROUP_KEY_COLLAPSED);
<a name="l00705"></a>00705 
<a name="l00706"></a>00706     stg = mwSametimeGroup_new(stlist, gtype, gname);
<a name="l00707"></a>00707     mwSametimeGroup_setAlias(stg, purple_group_get_name(grp));
<a name="l00708"></a>00708     mwSametimeGroup_setOpen(stg, gopen);
<a name="l00709"></a>00709 
<a name="l00710"></a>00710     <span class="comment">/* don&#39;t attempt to put buddies in a dynamic group, it breaks</span>
<a name="l00711"></a>00711 <span class="comment">       other clients */</span>
<a name="l00712"></a>00712     <span class="keywordflow">if</span>(gtype == mwSametimeGroup_DYNAMIC)
<a name="l00713"></a>00713       <span class="keywordflow">continue</span>;
<a name="l00714"></a>00714 
<a name="l00715"></a>00715     <span class="keywordflow">for</span>(cn = purple_blist_node_get_first_child(gn);
<a name="l00716"></a>00716                         cn;
<a name="l00717"></a>00717                         cn = purple_blist_node_get_sibling_next(cn)) {
<a name="l00718"></a>00718       <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_CONTACT(cn)) <span class="keywordflow">continue</span>;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720       <span class="keywordflow">for</span>(bn = purple_blist_node_get_first_child(cn);
<a name="l00721"></a>00721                           bn;
<a name="l00722"></a>00722                           bn = purple_blist_node_get_sibling_next(bn)) {
<a name="l00723"></a>00723         <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_BUDDY(bn)) <span class="keywordflow">continue</span>;
<a name="l00724"></a>00724         <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_SHOULD_SAVE(bn)) <span class="keywordflow">continue</span>;
<a name="l00725"></a>00725 
<a name="l00726"></a>00726         bdy = (<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *) bn;
<a name="l00727"></a>00727 
<a name="l00728"></a>00728         <span class="keywordflow">if</span>(purple_buddy_get_account(bdy) == acct) {
<a name="l00729"></a>00729           <span class="keyword">struct </span>mwSametimeUser *stu;
<a name="l00730"></a>00730           <span class="keyword">enum</span> mwSametimeUserType utype;
<a name="l00731"></a>00731 
<a name="l00732"></a>00732           idb.user = (<span class="keywordtype">char</span> *)purple_buddy_get_name(bdy);
<a name="l00733"></a>00733 
<a name="l00734"></a>00734           utype = purple_blist_node_get_int(bn, BUDDY_KEY_TYPE);
<a name="l00735"></a>00735           <span class="keywordflow">if</span>(! utype) utype = mwSametimeUser_NORMAL;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737           stu = mwSametimeUser_new(stg, utype, &amp;idb);
<a name="l00738"></a>00738           mwSametimeUser_setShortName(stu, purple_buddy_get_server_alias(bdy));
<a name="l00739"></a>00739           mwSametimeUser_setAlias(stu, purple_buddy_get_local_buddy_alias(bdy));
<a name="l00740"></a>00740         }
<a name="l00741"></a>00741       }
<a name="l00742"></a>00742     }
<a name="l00743"></a>00743   }
<a name="l00744"></a>00744 }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_store(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd) {
<a name="l00748"></a>00748 
<a name="l00749"></a>00749   <span class="keyword">struct </span>mwSametimeList *stlist;
<a name="l00750"></a>00750   <span class="keyword">struct </span>mwServiceStorage *srvc;
<a name="l00751"></a>00751   <span class="keyword">struct </span>mwStorageUnit *unit;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l00754"></a>00754 
<a name="l00755"></a>00755   <span class="keyword">struct </span>mwPutBuffer *b;
<a name="l00756"></a>00756   <span class="keyword">struct </span>mwOpaque *o;
<a name="l00757"></a>00757 
<a name="l00758"></a>00758   g_return_if_fail(pd != NULL);
<a name="l00759"></a>00759 
<a name="l00760"></a>00760   srvc = pd-&gt;srvc_store;
<a name="l00761"></a>00761   g_return_if_fail(srvc != NULL);
<a name="l00762"></a>00762 
<a name="l00763"></a>00763   gc = pd-&gt;gc;
<a name="l00764"></a>00764 
<a name="l00765"></a>00765   <span class="keywordflow">if</span>(BLIST_PREF_IS_LOCAL() || BLIST_PREF_IS_MERGE()) {
<a name="l00766"></a>00766     DEBUG_INFO(<span class="stringliteral">&quot;preferences indicate not to save remote blist\n&quot;</span>);
<a name="l00767"></a>00767     <span class="keywordflow">return</span>;
<a name="l00768"></a>00768 
<a name="l00769"></a>00769   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(MW_SERVICE_IS_DEAD(srvc)) {
<a name="l00770"></a>00770     DEBUG_INFO(<span class="stringliteral">&quot;aborting save of blist: storage service is not alive\n&quot;</span>);
<a name="l00771"></a>00771     <span class="keywordflow">return</span>;
<a name="l00772"></a>00772 
<a name="l00773"></a>00773   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(BLIST_PREF_IS_STORE() || BLIST_PREF_IS_SYNCH()) {
<a name="l00774"></a>00774     DEBUG_INFO(<span class="stringliteral">&quot;saving remote blist\n&quot;</span>);
<a name="l00775"></a>00775 
<a name="l00776"></a>00776   } <span class="keywordflow">else</span> {
<a name="l00777"></a>00777     g_return_if_reached();
<a name="l00778"></a>00778   }
<a name="l00779"></a>00779 
<a name="l00780"></a>00780   <span class="comment">/* create and export to a list object */</span>
<a name="l00781"></a>00781   stlist = mwSametimeList_new();
<a name="l00782"></a>00782   blist_export(gc, stlist);
<a name="l00783"></a>00783 
<a name="l00784"></a>00784   <span class="comment">/* write it to a buffer */</span>
<a name="l00785"></a>00785   b = mwPutBuffer_new();
<a name="l00786"></a>00786   mwSametimeList_put(b, stlist);
<a name="l00787"></a>00787   mwSametimeList_free(stlist);
<a name="l00788"></a>00788 
<a name="l00789"></a>00789   <span class="comment">/* put the buffer contents into a storage unit */</span>
<a name="l00790"></a>00790   unit = mwStorageUnit_new(mwStore_AWARE_LIST);
<a name="l00791"></a>00791   o = mwStorageUnit_asOpaque(unit);
<a name="l00792"></a>00792   mwPutBuffer_finalize(o, b);
<a name="l00793"></a>00793 
<a name="l00794"></a>00794   <span class="comment">/* save the storage unit to the service */</span>
<a name="l00795"></a>00795   mwServiceStorage_save(srvc, unit, NULL, NULL, NULL);
<a name="l00796"></a>00796 }
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 
<a name="l00799"></a>00799 <span class="keyword">static</span> gboolean blist_save_cb(gpointer data) {
<a name="l00800"></a>00800   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = data;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802   blist_store(pd);
<a name="l00803"></a>00803   pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#acac54485b7d345e826b6942f5f0186d6">save_event</a> = 0;
<a name="l00804"></a>00804   <span class="keywordflow">return</span> FALSE;
<a name="l00805"></a>00805 }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 
<a name="l00809"></a>00809 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_schedule(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd) {
<a name="l00810"></a>00810   <span class="keywordflow">if</span>(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#acac54485b7d345e826b6942f5f0186d6">save_event</a>) <span class="keywordflow">return</span>;
<a name="l00811"></a>00811 
<a name="l00812"></a>00812   pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#acac54485b7d345e826b6942f5f0186d6">save_event</a> = <a class="code" href="eventloop_8c.html#a17752ee1277e09350a612b0b88921fc5">purple_timeout_add_seconds</a>(BLIST_SAVE_SECONDS,
<a name="l00813"></a>00813                                     blist_save_cb, pd);
<a name="l00814"></a>00814 }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 <span class="keyword">static</span> gboolean buddy_is_external(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *b) {
<a name="l00818"></a>00818   g_return_val_if_fail(b != NULL, FALSE);
<a name="l00819"></a>00819   <span class="keywordflow">return</span> purple_str_has_prefix(purple_buddy_get_name(b), <span class="stringliteral">&quot;@E &quot;</span>);
<a name="l00820"></a>00820 }
<a name="l00821"></a>00821 
<a name="l00822"></a>00822 
<a name="l00825"></a>00825 <span class="keyword">static</span> <span class="keywordtype">void</span> buddy_add(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd,
<a name="l00826"></a>00826                       <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy) {
<a name="l00827"></a>00827 
<a name="l00828"></a>00828   <span class="keyword">struct </span>mwAwareIdBlock idb = { mwAware_USER, (<span class="keywordtype">char</span> *) purple_buddy_get_name(buddy), NULL };
<a name="l00829"></a>00829   <span class="keyword">struct </span>mwAwareList *list;
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group;
<a name="l00832"></a>00832   GList *add;
<a name="l00833"></a>00833 
<a name="l00834"></a>00834   add = g_list_prepend(NULL, &amp;idb);
<a name="l00835"></a>00835 
<a name="l00836"></a>00836   group = purple_buddy_get_group(buddy);
<a name="l00837"></a>00837   list = list_ensure(pd, group);
<a name="l00838"></a>00838 
<a name="l00839"></a>00839   <span class="keywordflow">if</span>(mwAwareList_addAware(list, add)) {
<a name="l00840"></a>00840     purple_blist_remove_buddy(buddy);
<a name="l00841"></a>00841   }
<a name="l00842"></a>00842 
<a name="l00843"></a>00843   blist_schedule(pd);
<a name="l00844"></a>00844 
<a name="l00845"></a>00845   g_list_free(add);
<a name="l00846"></a>00846 }
<a name="l00847"></a>00847 
<a name="l00848"></a>00848 
<a name="l00851"></a>00851 <span class="keyword">static</span> <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy_ensure(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group,
<a name="l00852"></a>00852                                <span class="keyword">struct</span> mwSametimeUser *stuser) {
<a name="l00853"></a>00853 
<a name="l00854"></a>00854   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l00855"></a>00855   <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy;
<a name="l00856"></a>00856   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct = purple_connection_get_account(gc);
<a name="l00857"></a>00857 
<a name="l00858"></a>00858   <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span> = mwSametimeUser_getUser(stuser);
<a name="l00859"></a>00859   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = mwSametimeUser_getShortName(stuser);
<a name="l00860"></a>00860   <span class="keyword">const</span> <span class="keywordtype">char</span> *alias = mwSametimeUser_getAlias(stuser);
<a name="l00861"></a>00861   <span class="keyword">enum</span> mwSametimeUserType type = mwSametimeUser_getType(stuser);
<a name="l00862"></a>00862 
<a name="l00863"></a>00863   g_return_val_if_fail(<span class="keywordtype">id</span> != NULL, NULL);
<a name="l00864"></a>00864   g_return_val_if_fail(strlen(<span class="keywordtype">id</span>) &gt; 0, NULL);
<a name="l00865"></a>00865 
<a name="l00866"></a>00866   buddy = purple_find_buddy_in_group(acct, <span class="keywordtype">id</span>, group);
<a name="l00867"></a>00867   <span class="keywordflow">if</span>(! buddy) {
<a name="l00868"></a>00868     buddy = purple_buddy_new(acct, <span class="keywordtype">id</span>, alias);
<a name="l00869"></a>00869 
<a name="l00870"></a>00870     purple_blist_add_buddy(buddy, NULL, group, NULL);
<a name="l00871"></a>00871     buddy_add(pd, buddy);
<a name="l00872"></a>00872   }
<a name="l00873"></a>00873 
<a name="l00874"></a>00874   purple_blist_alias_buddy(buddy, alias);
<a name="l00875"></a>00875   purple_blist_server_alias_buddy(buddy, name);
<a name="l00876"></a>00876   purple_blist_node_set_string((<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) buddy, BUDDY_KEY_NAME, name);
<a name="l00877"></a>00877   purple_blist_node_set_int((<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) buddy, BUDDY_KEY_TYPE, type);
<a name="l00878"></a>00878 
<a name="l00879"></a>00879   <span class="keywordflow">return</span> buddy;
<a name="l00880"></a>00880 }
<a name="l00881"></a>00881 
<a name="l00882"></a>00882 
<a name="l00884"></a>00884 <span class="keyword">static</span> <span class="keywordtype">void</span> group_add(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd,
<a name="l00885"></a>00885                       <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group) {
<a name="l00886"></a>00886 
<a name="l00887"></a>00887   <span class="keyword">struct </span>mwAwareIdBlock idb = { mwAware_GROUP, NULL, NULL };
<a name="l00888"></a>00888   <span class="keyword">struct </span>mwAwareList *list;
<a name="l00889"></a>00889   <span class="keyword">const</span> <span class="keywordtype">char</span> *n;
<a name="l00890"></a>00890   GList *add;
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   n = purple_blist_node_get_string((<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) group, GROUP_KEY_NAME);
<a name="l00893"></a>00893   <span class="keywordflow">if</span>(! n) n = purple_group_get_name(group);
<a name="l00894"></a>00894 
<a name="l00895"></a>00895   idb.user = (<span class="keywordtype">char</span> *) n;
<a name="l00896"></a>00896   add = g_list_prepend(NULL, &amp;idb);
<a name="l00897"></a>00897 
<a name="l00898"></a>00898   list = list_ensure(pd, group);
<a name="l00899"></a>00899   mwAwareList_addAware(list, add);
<a name="l00900"></a>00900   g_list_free(add);
<a name="l00901"></a>00901 }
<a name="l00902"></a>00902 
<a name="l00903"></a>00903 
<a name="l00906"></a>00906 <span class="keyword">static</span> <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group_ensure(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l00907"></a>00907                                <span class="keyword">struct</span> mwSametimeGroup *stgroup) {
<a name="l00908"></a>00908   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l00909"></a>00909   <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group = NULL;
<a name="l00910"></a>00910   <a class="code" href="struct___purple_buddy_list.html">PurpleBuddyList</a> *blist;
<a name="l00911"></a>00911   <a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *gn;
<a name="l00912"></a>00912   <span class="keyword">const</span> <span class="keywordtype">char</span> *name, *alias, *owner;
<a name="l00913"></a>00913   <span class="keyword">enum</span> mwSametimeGroupType type;
<a name="l00914"></a>00914 
<a name="l00915"></a>00915   acct = purple_connection_get_account(gc);
<a name="l00916"></a>00916   owner = purple_account_get_username(acct);
<a name="l00917"></a>00917 
<a name="l00918"></a>00918   blist = purple_get_blist();
<a name="l00919"></a>00919   g_return_val_if_fail(blist != NULL, NULL);
<a name="l00920"></a>00920 
<a name="l00921"></a>00921   name = mwSametimeGroup_getName(stgroup);
<a name="l00922"></a>00922   alias = mwSametimeGroup_getAlias(stgroup);
<a name="l00923"></a>00923   type = mwSametimeGroup_getType(stgroup);
<a name="l00924"></a>00924 
<a name="l00925"></a>00925   <span class="keywordflow">if</span> (!name) {
<a name="l00926"></a>00926     DEBUG_WARN(<span class="stringliteral">&quot;Can&#39;t ensure a null group\n&quot;</span>);
<a name="l00927"></a>00927     <span class="keywordflow">return</span> NULL;
<a name="l00928"></a>00928   }
<a name="l00929"></a>00929 
<a name="l00930"></a>00930   <span class="keywordflow">if</span> (!name) {
<a name="l00931"></a>00931     DEBUG_WARN(<span class="stringliteral">&quot;Can&#39;t ensure a null group\n&quot;</span>);
<a name="l00932"></a>00932     <span class="keywordflow">return</span> NULL;
<a name="l00933"></a>00933   }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935   DEBUG_INFO(<span class="stringliteral">&quot;attempting to ensure group %s, called %s\n&quot;</span>,
<a name="l00936"></a>00936              NSTR(name), NSTR(alias));
<a name="l00937"></a>00937 
<a name="l00938"></a>00938   <span class="comment">/* first attempt at finding the group, by the name key */</span>
<a name="l00939"></a>00939   <span class="keywordflow">for</span>(gn = purple_blist_get_root(); gn;
<a name="l00940"></a>00940                   gn = purple_blist_node_get_sibling_next(gn)) {
<a name="l00941"></a>00941     <span class="keyword">const</span> <span class="keywordtype">char</span> *n, *o;
<a name="l00942"></a>00942     <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_GROUP(gn)) <span class="keywordflow">continue</span>;
<a name="l00943"></a>00943     n = purple_blist_node_get_string(gn, GROUP_KEY_NAME);
<a name="l00944"></a>00944     o = purple_blist_node_get_string(gn, GROUP_KEY_OWNER);
<a name="l00945"></a>00945 
<a name="l00946"></a>00946     DEBUG_INFO(<span class="stringliteral">&quot;found group named %s, owned by %s\n&quot;</span>, NSTR(n), NSTR(o));
<a name="l00947"></a>00947 
<a name="l00948"></a>00948     <span class="keywordflow">if</span>(n &amp;&amp; !strcmp(n, name)) {
<a name="l00949"></a>00949       <span class="keywordflow">if</span>(!o || !strcmp(o, owner)) {
<a name="l00950"></a>00950         DEBUG_INFO(<span class="stringliteral">&quot;that&#39;ll work\n&quot;</span>);
<a name="l00951"></a>00951         group = (<a class="code" href="struct___purple_group.html">PurpleGroup</a> *) gn;
<a name="l00952"></a>00952         <span class="keywordflow">break</span>;
<a name="l00953"></a>00953       }
<a name="l00954"></a>00954     }
<a name="l00955"></a>00955   }
<a name="l00956"></a>00956 
<a name="l00957"></a>00957   <span class="comment">/* try again, by alias */</span>
<a name="l00958"></a>00958   <span class="keywordflow">if</span>(! group) {
<a name="l00959"></a>00959     DEBUG_INFO(<span class="stringliteral">&quot;searching for group by alias %s\n&quot;</span>, NSTR(alias));
<a name="l00960"></a>00960     group = purple_find_group(alias);
<a name="l00961"></a>00961   }
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   <span class="comment">/* oh well, no such group. Let&#39;s create it! */</span>
<a name="l00964"></a>00964   <span class="keywordflow">if</span>(! group) {
<a name="l00965"></a>00965     DEBUG_INFO(<span class="stringliteral">&quot;creating group\n&quot;</span>);
<a name="l00966"></a>00966     group = purple_group_new(alias);
<a name="l00967"></a>00967     purple_blist_add_group(group, NULL);
<a name="l00968"></a>00968   }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970   gn = (<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) group;
<a name="l00971"></a>00971   purple_blist_node_set_string(gn, GROUP_KEY_NAME, name);
<a name="l00972"></a>00972   purple_blist_node_set_int(gn, GROUP_KEY_TYPE, type);
<a name="l00973"></a>00973 
<a name="l00974"></a>00974   <span class="keywordflow">if</span>(type == mwSametimeGroup_DYNAMIC) {
<a name="l00975"></a>00975     purple_blist_node_set_string(gn, GROUP_KEY_OWNER, owner);
<a name="l00976"></a>00976     group_add(gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>, group);
<a name="l00977"></a>00977   }
<a name="l00978"></a>00978 
<a name="l00979"></a>00979   <span class="keywordflow">return</span> group;
<a name="l00980"></a>00980 }
<a name="l00981"></a>00981 
<a name="l00982"></a>00982 
<a name="l00984"></a>00984 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_merge(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">struct</span> mwSametimeList *stlist) {
<a name="l00985"></a>00985   <span class="keyword">struct </span>mwSametimeGroup *stgroup;
<a name="l00986"></a>00986   <span class="keyword">struct </span>mwSametimeUser *stuser;
<a name="l00987"></a>00987 
<a name="l00988"></a>00988   <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group;
<a name="l00989"></a>00989   <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy;
<a name="l00990"></a>00990 
<a name="l00991"></a>00991   GList *gl, *gtl, *ul, *utl;
<a name="l00992"></a>00992 
<a name="l00993"></a>00993   gl = gtl = mwSametimeList_getGroups(stlist);
<a name="l00994"></a>00994   <span class="keywordflow">for</span>(; gl; gl = gl-&gt;next) {
<a name="l00995"></a>00995 
<a name="l00996"></a>00996     stgroup = (<span class="keyword">struct </span>mwSametimeGroup *) gl-&gt;data;
<a name="l00997"></a>00997     group = group_ensure(gc, stgroup);
<a name="l00998"></a>00998 
<a name="l00999"></a>00999     ul = utl = mwSametimeGroup_getUsers(stgroup);
<a name="l01000"></a>01000     <span class="keywordflow">for</span>(; ul; ul = ul-&gt;next) {
<a name="l01001"></a>01001 
<a name="l01002"></a>01002       stuser = (<span class="keyword">struct </span>mwSametimeUser *) ul-&gt;data;
<a name="l01003"></a>01003       buddy = buddy_ensure(gc, group, stuser);
<a name="l01004"></a>01004     }
<a name="l01005"></a>01005     g_list_free(utl);
<a name="l01006"></a>01006   }
<a name="l01007"></a>01007   g_list_free(gtl);
<a name="l01008"></a>01008 }
<a name="l01009"></a>01009 
<a name="l01010"></a>01010 
<a name="l01013"></a>01013 <span class="keyword">static</span> <span class="keywordtype">void</span> group_clear(<a class="code" href="struct___purple_group.html">PurpleGroup</a> *group, <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct, gboolean del) {
<a name="l01014"></a>01014   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l01015"></a>01015   GList *prune = NULL;
<a name="l01016"></a>01016   <a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *gn, *cn, *bn;
<a name="l01017"></a>01017 
<a name="l01018"></a>01018   g_return_if_fail(group != NULL);
<a name="l01019"></a>01019 
<a name="l01020"></a>01020   DEBUG_INFO(<span class="stringliteral">&quot;clearing members from pruned group %s\n&quot;</span>, NSTR(purple_group_get_name(group)));
<a name="l01021"></a>01021 
<a name="l01022"></a>01022   gc = purple_account_get_connection(acct);
<a name="l01023"></a>01023   g_return_if_fail(gc != NULL);
<a name="l01024"></a>01024 
<a name="l01025"></a>01025   gn = (<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) group;
<a name="l01026"></a>01026 
<a name="l01027"></a>01027   <span class="keywordflow">for</span>(cn = purple_blist_node_get_first_child(gn);
<a name="l01028"></a>01028                   cn;
<a name="l01029"></a>01029                   cn = purple_blist_node_get_sibling_next(cn)) {
<a name="l01030"></a>01030     <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_CONTACT(cn)) <span class="keywordflow">continue</span>;
<a name="l01031"></a>01031 
<a name="l01032"></a>01032     <span class="keywordflow">for</span>(bn = purple_blist_node_get_first_child(cn);
<a name="l01033"></a>01033                         bn;
<a name="l01034"></a>01034                         bn = purple_blist_node_get_sibling_next(bn)) {
<a name="l01035"></a>01035       <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *gb = (<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *) bn;
<a name="l01036"></a>01036 
<a name="l01037"></a>01037       <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_BUDDY(bn)) <span class="keywordflow">continue</span>;
<a name="l01038"></a>01038 
<a name="l01039"></a>01039       <span class="keywordflow">if</span>(purple_buddy_get_account(gb) == acct) {
<a name="l01040"></a>01040         DEBUG_INFO(<span class="stringliteral">&quot;clearing %s from group\n&quot;</span>, NSTR(purple_buddy_get_name(gb)));
<a name="l01041"></a>01041         prune = g_list_prepend(prune, gb);
<a name="l01042"></a>01042       }
<a name="l01043"></a>01043     }
<a name="l01044"></a>01044   }
<a name="l01045"></a>01045 
<a name="l01046"></a>01046   <span class="comment">/* quickly unsubscribe from presence for the entire group */</span>
<a name="l01047"></a>01047   purple_account_remove_group(acct, group);
<a name="l01048"></a>01048 
<a name="l01049"></a>01049   <span class="comment">/* remove blist entries that need to go */</span>
<a name="l01050"></a>01050   <span class="keywordflow">while</span>(prune) {
<a name="l01051"></a>01051     purple_blist_remove_buddy(prune-&gt;data);
<a name="l01052"></a>01052     prune = g_list_delete_link(prune, prune);
<a name="l01053"></a>01053   }
<a name="l01054"></a>01054   DEBUG_INFO(<span class="stringliteral">&quot;cleared buddies\n&quot;</span>);
<a name="l01055"></a>01055 
<a name="l01056"></a>01056   <span class="comment">/* optionally remove group from blist */</span>
<a name="l01057"></a>01057   <span class="keywordflow">if</span>(del &amp;&amp; !purple_blist_get_group_size(group, TRUE)) {
<a name="l01058"></a>01058     DEBUG_INFO(<span class="stringliteral">&quot;removing empty group\n&quot;</span>);
<a name="l01059"></a>01059     purple_blist_remove_group(group);
<a name="l01060"></a>01060   }
<a name="l01061"></a>01061 }
<a name="l01062"></a>01062 
<a name="l01063"></a>01063 
<a name="l01065"></a>01065 <span class="keyword">static</span> <span class="keywordtype">void</span> group_prune(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group,
<a name="l01066"></a>01066                         <span class="keyword">struct</span> mwSametimeGroup *stgroup) {
<a name="l01067"></a>01067 
<a name="l01068"></a>01068   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l01069"></a>01069   <a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *gn, *cn, *bn;
<a name="l01070"></a>01070 
<a name="l01071"></a>01071   GHashTable *stusers;
<a name="l01072"></a>01072   GList *prune = NULL;
<a name="l01073"></a>01073   GList *ul, *utl;
<a name="l01074"></a>01074 
<a name="l01075"></a>01075   g_return_if_fail(group != NULL);
<a name="l01076"></a>01076 
<a name="l01077"></a>01077   DEBUG_INFO(<span class="stringliteral">&quot;pruning membership of group %s\n&quot;</span>, NSTR(purple_group_get_name(group)));
<a name="l01078"></a>01078 
<a name="l01079"></a>01079   acct = purple_connection_get_account(gc);
<a name="l01080"></a>01080   g_return_if_fail(acct != NULL);
<a name="l01081"></a>01081 
<a name="l01082"></a>01082   stusers = g_hash_table_new(g_str_hash, g_str_equal);
<a name="l01083"></a>01083 
<a name="l01084"></a>01084   <span class="comment">/* build a hash table for quick lookup while pruning the group</span>
<a name="l01085"></a>01085 <span class="comment">     contents */</span>
<a name="l01086"></a>01086   utl = mwSametimeGroup_getUsers(stgroup);
<a name="l01087"></a>01087   <span class="keywordflow">for</span>(ul = utl; ul; ul = ul-&gt;next) {
<a name="l01088"></a>01088     <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span> = mwSametimeUser_getUser(ul-&gt;data);
<a name="l01089"></a>01089     g_hash_table_insert(stusers, (<span class="keywordtype">char</span> *) <span class="keywordtype">id</span>, ul-&gt;data);
<a name="l01090"></a>01090     DEBUG_INFO(<span class="stringliteral">&quot;server copy has %s\n&quot;</span>, NSTR(<span class="keywordtype">id</span>));
<a name="l01091"></a>01091   }
<a name="l01092"></a>01092   g_list_free(utl);
<a name="l01093"></a>01093 
<a name="l01094"></a>01094   gn = (<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) group;
<a name="l01095"></a>01095 
<a name="l01096"></a>01096   <span class="keywordflow">for</span>(cn = purple_blist_node_get_first_child(gn);
<a name="l01097"></a>01097                   cn;
<a name="l01098"></a>01098                   cn = purple_blist_node_get_sibling_next(cn)) {
<a name="l01099"></a>01099     <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_CONTACT(cn)) <span class="keywordflow">continue</span>;
<a name="l01100"></a>01100 
<a name="l01101"></a>01101     <span class="keywordflow">for</span>(bn = purple_blist_node_get_first_child(cn);
<a name="l01102"></a>01102                         bn;
<a name="l01103"></a>01103                         bn = purple_blist_node_get_sibling_next(bn)) {
<a name="l01104"></a>01104       <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *gb = (<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *) bn;
<a name="l01105"></a>01105 
<a name="l01106"></a>01106       <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_BUDDY(bn)) <span class="keywordflow">continue</span>;
<a name="l01107"></a>01107 
<a name="l01108"></a>01108       <span class="comment">/* if the account is correct and they&#39;re not in our table, mark</span>
<a name="l01109"></a>01109 <span class="comment">         them for pruning */</span>
<a name="l01110"></a>01110       <span class="keywordflow">if</span>(purple_buddy_get_account(gb) == acct &amp;&amp; !g_hash_table_lookup(stusers, purple_buddy_get_name(gb))) {
<a name="l01111"></a>01111         DEBUG_INFO(<span class="stringliteral">&quot;marking %s for pruning\n&quot;</span>, NSTR(purple_buddy_get_name(gb)));
<a name="l01112"></a>01112         prune = g_list_prepend(prune, gb);
<a name="l01113"></a>01113       }
<a name="l01114"></a>01114     }
<a name="l01115"></a>01115   }
<a name="l01116"></a>01116   DEBUG_INFO(<span class="stringliteral">&quot;done marking\n&quot;</span>);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   g_hash_table_destroy(stusers);
<a name="l01119"></a>01119 
<a name="l01120"></a>01120   <span class="keywordflow">if</span>(prune) {
<a name="l01121"></a>01121     purple_account_remove_buddies(acct, prune, NULL);
<a name="l01122"></a>01122     <span class="keywordflow">while</span>(prune) {
<a name="l01123"></a>01123       purple_blist_remove_buddy(prune-&gt;data);
<a name="l01124"></a>01124       prune = g_list_delete_link(prune, prune);
<a name="l01125"></a>01125     }
<a name="l01126"></a>01126   }
<a name="l01127"></a>01127 }
<a name="l01128"></a>01128 
<a name="l01129"></a>01129 
<a name="l01132"></a>01132 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_sync(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">struct</span> mwSametimeList *stlist) {
<a name="l01133"></a>01133 
<a name="l01134"></a>01134   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l01135"></a>01135   <a class="code" href="struct___purple_buddy_list.html">PurpleBuddyList</a> *blist;
<a name="l01136"></a>01136   <a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *gn;
<a name="l01137"></a>01137 
<a name="l01138"></a>01138   GHashTable *stgroups;
<a name="l01139"></a>01139   GList *g_prune = NULL;
<a name="l01140"></a>01140 
<a name="l01141"></a>01141   GList *gl, *gtl;
<a name="l01142"></a>01142 
<a name="l01143"></a>01143   <span class="keyword">const</span> <span class="keywordtype">char</span> *acct_n;
<a name="l01144"></a>01144 
<a name="l01145"></a>01145   DEBUG_INFO(<span class="stringliteral">&quot;synchronizing local buddy list from server list\n&quot;</span>);
<a name="l01146"></a>01146 
<a name="l01147"></a>01147   acct = purple_connection_get_account(gc);
<a name="l01148"></a>01148   g_return_if_fail(acct != NULL);
<a name="l01149"></a>01149 
<a name="l01150"></a>01150   acct_n = purple_account_get_username(acct);
<a name="l01151"></a>01151 
<a name="l01152"></a>01152   blist = purple_get_blist();
<a name="l01153"></a>01153   g_return_if_fail(blist != NULL);
<a name="l01154"></a>01154 
<a name="l01155"></a>01155   <span class="comment">/* build a hash table for quick lookup while pruning the local</span>
<a name="l01156"></a>01156 <span class="comment">     list, mapping group name to group structure */</span>
<a name="l01157"></a>01157   stgroups = g_hash_table_new(g_str_hash, g_str_equal);
<a name="l01158"></a>01158 
<a name="l01159"></a>01159   gtl = mwSametimeList_getGroups(stlist);
<a name="l01160"></a>01160   <span class="keywordflow">for</span>(gl = gtl; gl; gl = gl-&gt;next) {
<a name="l01161"></a>01161     <span class="keyword">const</span> <span class="keywordtype">char</span> *name = mwSametimeGroup_getName(gl-&gt;data);
<a name="l01162"></a>01162     g_hash_table_insert(stgroups, (<span class="keywordtype">char</span> *) name, gl-&gt;data);
<a name="l01163"></a>01163   }
<a name="l01164"></a>01164   g_list_free(gtl);
<a name="l01165"></a>01165 
<a name="l01166"></a>01166   <span class="comment">/* find all groups which should be pruned from the local list */</span>
<a name="l01167"></a>01167   <span class="keywordflow">for</span>(gn = purple_blist_get_root(); gn;
<a name="l01168"></a>01168                   gn = purple_blist_node_get_sibling_next(gn)) {
<a name="l01169"></a>01169     <a class="code" href="struct___purple_group.html">PurpleGroup</a> *grp = (<a class="code" href="struct___purple_group.html">PurpleGroup</a> *) gn;
<a name="l01170"></a>01170     <span class="keyword">const</span> <span class="keywordtype">char</span> *gname, *owner;
<a name="l01171"></a>01171     <span class="keyword">struct </span>mwSametimeGroup *stgrp;
<a name="l01172"></a>01172 
<a name="l01173"></a>01173     <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_GROUP(gn)) <span class="keywordflow">continue</span>;
<a name="l01174"></a>01174 
<a name="l01175"></a>01175     <span class="comment">/* group not belonging to this account */</span>
<a name="l01176"></a>01176     <span class="keywordflow">if</span>(! purple_group_on_account(grp, acct))
<a name="l01177"></a>01177       <span class="keywordflow">continue</span>;
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     <span class="comment">/* dynamic group belonging to this account. don&#39;t prune contents */</span>
<a name="l01180"></a>01180     owner = purple_blist_node_get_string(gn, GROUP_KEY_OWNER);
<a name="l01181"></a>01181     <span class="keywordflow">if</span>(owner &amp;&amp; !strcmp(owner, acct_n))
<a name="l01182"></a>01182        <span class="keywordflow">continue</span>;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184     <span class="comment">/* we actually are synching by this key as opposed to the group</span>
<a name="l01185"></a>01185 <span class="comment">       title, which can be different things in the st list */</span>
<a name="l01186"></a>01186     gname = purple_blist_node_get_string(gn, GROUP_KEY_NAME);
<a name="l01187"></a>01187     <span class="keywordflow">if</span>(! gname) gname = purple_group_get_name(grp);
<a name="l01188"></a>01188 
<a name="l01189"></a>01189     stgrp = g_hash_table_lookup(stgroups, gname);
<a name="l01190"></a>01190     <span class="keywordflow">if</span>(! stgrp) {
<a name="l01191"></a>01191       <span class="comment">/* remove the whole group */</span>
<a name="l01192"></a>01192       DEBUG_INFO(<span class="stringliteral">&quot;marking group %s for pruning\n&quot;</span>, purple_group_get_name(grp));
<a name="l01193"></a>01193       g_prune = g_list_prepend(g_prune, grp);
<a name="l01194"></a>01194 
<a name="l01195"></a>01195     } <span class="keywordflow">else</span> {
<a name="l01196"></a>01196       <span class="comment">/* synch the group contents */</span>
<a name="l01197"></a>01197       group_prune(gc, grp, stgrp);
<a name="l01198"></a>01198     }
<a name="l01199"></a>01199   }
<a name="l01200"></a>01200   DEBUG_INFO(<span class="stringliteral">&quot;done marking groups\n&quot;</span>);
<a name="l01201"></a>01201 
<a name="l01202"></a>01202   <span class="comment">/* don&#39;t need this anymore */</span>
<a name="l01203"></a>01203   g_hash_table_destroy(stgroups);
<a name="l01204"></a>01204 
<a name="l01205"></a>01205   <span class="comment">/* prune all marked groups */</span>
<a name="l01206"></a>01206   <span class="keywordflow">while</span>(g_prune) {
<a name="l01207"></a>01207     <a class="code" href="struct___purple_group.html">PurpleGroup</a> *grp = g_prune-&gt;data;
<a name="l01208"></a>01208     <a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *gn = (<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) grp;
<a name="l01209"></a>01209     <span class="keyword">const</span> <span class="keywordtype">char</span> *owner;
<a name="l01210"></a>01210     gboolean del = TRUE;
<a name="l01211"></a>01211 
<a name="l01212"></a>01212     owner = purple_blist_node_get_string(gn, GROUP_KEY_OWNER);
<a name="l01213"></a>01213     <span class="keywordflow">if</span>(owner &amp;&amp; strcmp(owner, acct_n)) {
<a name="l01214"></a>01214       <span class="comment">/* it&#39;s a specialty group belonging to another account with some</span>
<a name="l01215"></a>01215 <span class="comment">         of our members in it, so don&#39;t fully delete it */</span>
<a name="l01216"></a>01216       del = FALSE;
<a name="l01217"></a>01217     }
<a name="l01218"></a>01218 
<a name="l01219"></a>01219     group_clear(g_prune-&gt;data, acct, del);
<a name="l01220"></a>01220     g_prune = g_list_delete_link(g_prune, g_prune);
<a name="l01221"></a>01221   }
<a name="l01222"></a>01222 
<a name="l01223"></a>01223   <span class="comment">/* done with the pruning, let&#39;s merge in the additions */</span>
<a name="l01224"></a>01224   blist_merge(gc, stlist);
<a name="l01225"></a>01225 }
<a name="l01226"></a>01226 
<a name="l01227"></a>01227 
<a name="l01230"></a>01230 <span class="keyword">static</span> <span class="keywordtype">void</span> fetch_blist_cb(<span class="keyword">struct</span> mwServiceStorage *srvc,
<a name="l01231"></a>01231                            guint32 result, <span class="keyword">struct</span> mwStorageUnit *item,
<a name="l01232"></a>01232                            gpointer data) {
<a name="l01233"></a>01233 
<a name="l01234"></a>01234   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = data;
<a name="l01235"></a>01235   <span class="keyword">struct </span>mwSametimeList *stlist;
<a name="l01236"></a>01236 
<a name="l01237"></a>01237   <span class="keyword">struct </span>mwGetBuffer *b;
<a name="l01238"></a>01238 
<a name="l01239"></a>01239   g_return_if_fail(result == ERR_SUCCESS);
<a name="l01240"></a>01240 
<a name="l01241"></a>01241   <span class="comment">/* check our preferences for loading */</span>
<a name="l01242"></a>01242   <span class="keywordflow">if</span>(BLIST_PREF_IS_LOCAL()) {
<a name="l01243"></a>01243     DEBUG_INFO(<span class="stringliteral">&quot;preferences indicate not to load remote buddy list\n&quot;</span>);
<a name="l01244"></a>01244     <span class="keywordflow">return</span>;
<a name="l01245"></a>01245   }
<a name="l01246"></a>01246 
<a name="l01247"></a>01247   b = mwGetBuffer_wrap(mwStorageUnit_asOpaque(item));
<a name="l01248"></a>01248 
<a name="l01249"></a>01249   stlist = mwSametimeList_new();
<a name="l01250"></a>01250   mwSametimeList_get(b, stlist);
<a name="l01251"></a>01251 
<a name="l01252"></a>01252   <span class="comment">/* merge or synch depending on preferences */</span>
<a name="l01253"></a>01253   <span class="keywordflow">if</span>(BLIST_PREF_IS_MERGE() || BLIST_PREF_IS_STORE()) {
<a name="l01254"></a>01254     blist_merge(pd-&gt;gc, stlist);
<a name="l01255"></a>01255 
<a name="l01256"></a>01256   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(BLIST_PREF_IS_SYNCH()) {
<a name="l01257"></a>01257     blist_sync(pd-&gt;gc, stlist);
<a name="l01258"></a>01258   }
<a name="l01259"></a>01259 
<a name="l01260"></a>01260   mwSametimeList_free(stlist);
<a name="l01261"></a>01261   mwGetBuffer_free(b);
<a name="l01262"></a>01262 }
<a name="l01263"></a>01263 
<a name="l01264"></a>01264 
<a name="l01266"></a>01266 <span class="keyword">static</span> <span class="keywordtype">void</span> conversation_created_cb(<a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *g_conv,
<a name="l01267"></a>01267                                     <span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd) {
<a name="l01268"></a>01268 
<a name="l01269"></a>01269   <span class="comment">/* we need to tell the IM service to negotiate features for the</span>
<a name="l01270"></a>01270 <span class="comment">     conversation right away, otherwise it&#39;ll wait until the first</span>
<a name="l01271"></a>01271 <span class="comment">     message is sent before offering NotesBuddy features. Therefore</span>
<a name="l01272"></a>01272 <span class="comment">     whenever Purple creates a conversation, we&#39;ll immediately open the</span>
<a name="l01273"></a>01273 <span class="comment">     channel to the other side and figure out what the target can</span>
<a name="l01274"></a>01274 <span class="comment">     handle. Unfortunately, this makes us vulnerable to Psychic Mode,</span>
<a name="l01275"></a>01275 <span class="comment">     whereas a more lazy negotiation based on the first message</span>
<a name="l01276"></a>01276 <span class="comment">     would not */</span>
<a name="l01277"></a>01277 
<a name="l01278"></a>01278   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l01279"></a>01279   <span class="keyword">struct </span>mwIdBlock who = { 0, 0 };
<a name="l01280"></a>01280   <span class="keyword">struct </span>mwConversation *conv;
<a name="l01281"></a>01281 
<a name="l01282"></a>01282   gc = purple_conversation_get_gc(g_conv);
<a name="l01283"></a>01283   <span class="keywordflow">if</span>(pd-&gt;gc != gc)
<a name="l01284"></a>01284     <span class="keywordflow">return</span>; <span class="comment">/* not ours */</span>
<a name="l01285"></a>01285 
<a name="l01286"></a>01286   <span class="keywordflow">if</span>(purple_conversation_get_type(g_conv) != <a class="code" href="conversation_8h.html#a9e9f3ae232444332eb34f16aef64f721a4e1c3df052e10fb1b3789ce5925496ab">PURPLE_CONV_TYPE_IM</a>)
<a name="l01287"></a>01287     <span class="keywordflow">return</span>; <span class="comment">/* wrong type */</span>
<a name="l01288"></a>01288 
<a name="l01289"></a>01289   who.user = (<span class="keywordtype">char</span> *) purple_conversation_get_name(g_conv);
<a name="l01290"></a>01290   conv = mwServiceIm_getConversation(pd-&gt;srvc_im, &amp;who);
<a name="l01291"></a>01291 
<a name="l01292"></a>01292   convo_features(conv);
<a name="l01293"></a>01293 
<a name="l01294"></a>01294   <span class="keywordflow">if</span>(mwConversation_isClosed(conv))
<a name="l01295"></a>01295     mwConversation_open(conv);
<a name="l01296"></a>01296 }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298 
<a name="l01299"></a>01299 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_menu_nab(<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *node, gpointer data) {
<a name="l01300"></a>01300   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = data;
<a name="l01301"></a>01301   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l01302"></a>01302 
<a name="l01303"></a>01303   <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group = (<a class="code" href="struct___purple_group.html">PurpleGroup</a> *) node;
<a name="l01304"></a>01304 
<a name="l01305"></a>01305   GString *str;
<a name="l01306"></a>01306   <span class="keywordtype">char</span> *tmp;
<a name="l01307"></a>01307   <span class="keyword">const</span> <span class="keywordtype">char</span> *gname;
<a name="l01308"></a>01308 
<a name="l01309"></a>01309   g_return_if_fail(pd != NULL);
<a name="l01310"></a>01310 
<a name="l01311"></a>01311   gc = pd-&gt;gc;
<a name="l01312"></a>01312   g_return_if_fail(gc != NULL);
<a name="l01313"></a>01313 
<a name="l01314"></a>01314   g_return_if_fail(PURPLE_BLIST_NODE_IS_GROUP(node));
<a name="l01315"></a>01315 
<a name="l01316"></a>01316   str = g_string_new(NULL);
<a name="l01317"></a>01317 
<a name="l01318"></a>01318   tmp = (<span class="keywordtype">char</span> *) purple_blist_node_get_string(node, GROUP_KEY_NAME);
<a name="l01319"></a>01319   gname = purple_group_get_name(group);
<a name="l01320"></a>01320 
<a name="l01321"></a>01321   g_string_append_printf(str, _(<span class="stringliteral">&quot;&lt;b&gt;Group Title:&lt;/b&gt; %s&lt;br&gt;&quot;</span>), gname);
<a name="l01322"></a>01322   g_string_append_printf(str, _(<span class="stringliteral">&quot;&lt;b&gt;Notes Group ID:&lt;/b&gt; %s&lt;br&gt;&quot;</span>), tmp);
<a name="l01323"></a>01323 
<a name="l01324"></a>01324   tmp = g_strdup_printf(_(<span class="stringliteral">&quot;Info for Group %s&quot;</span>), gname);
<a name="l01325"></a>01325 
<a name="l01326"></a>01326   purple_notify_formatted(gc, tmp, _(<span class="stringliteral">&quot;Notes Address Book Information&quot;</span>),
<a name="l01327"></a>01327                         NULL, str-&gt;str, NULL, NULL);
<a name="l01328"></a>01328 
<a name="l01329"></a>01329   g_free(tmp);
<a name="l01330"></a>01330   g_string_free(str, TRUE);
<a name="l01331"></a>01331 }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333 
<a name="l01337"></a>01337 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_node_menu_cb(<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *node,
<a name="l01338"></a>01338                                GList **menu, <span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd) {
<a name="l01339"></a>01339   <span class="keyword">const</span> <span class="keywordtype">char</span> *owner;
<a name="l01340"></a>01340   <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group;
<a name="l01341"></a>01341   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l01342"></a>01342   <a class="code" href="struct___purple_menu_action.html">PurpleMenuAction</a> *act;
<a name="l01343"></a>01343 
<a name="l01344"></a>01344   <span class="comment">/* we only want groups */</span>
<a name="l01345"></a>01345   <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_GROUP(node)) <span class="keywordflow">return</span>;
<a name="l01346"></a>01346   group = (<a class="code" href="struct___purple_group.html">PurpleGroup</a> *) node;
<a name="l01347"></a>01347 
<a name="l01348"></a>01348   acct = purple_connection_get_account(pd-&gt;gc);
<a name="l01349"></a>01349   g_return_if_fail(acct != NULL);
<a name="l01350"></a>01350 
<a name="l01351"></a>01351   <span class="comment">/* better make sure we&#39;re connected */</span>
<a name="l01352"></a>01352   <span class="keywordflow">if</span>(! purple_account_is_connected(acct)) <span class="keywordflow">return</span>;
<a name="l01353"></a>01353 
<a name="l01354"></a>01354 <span class="preprocessor">#if 0</span>
<a name="l01355"></a>01355 <span class="preprocessor"></span>  <span class="comment">/* if there&#39;s anyone in the group for this acct, offer to invite</span>
<a name="l01356"></a>01356 <span class="comment">     them all to a conference */</span>
<a name="l01357"></a>01357   <span class="keywordflow">if</span>(purple_group_on_account(group, acct)) {
<a name="l01358"></a>01358     act = purple_menu_action_new(_(<span class="stringliteral">&quot;Invite Group to Conference...&quot;</span>),
<a name="l01359"></a>01359                                PURPLE_CALLBACK(blist_menu_group_invite),
<a name="l01360"></a>01360                                pd, NULL);
<a name="l01361"></a>01361     *menu = g_list_append(*menu, NULL);
<a name="l01362"></a>01362   }
<a name="l01363"></a>01363 <span class="preprocessor">#endif</span>
<a name="l01364"></a>01364 <span class="preprocessor"></span>
<a name="l01365"></a>01365   <span class="comment">/* check if it&#39;s a NAB group for this account */</span>
<a name="l01366"></a>01366   owner = purple_blist_node_get_string(node, GROUP_KEY_OWNER);
<a name="l01367"></a>01367   <span class="keywordflow">if</span>(owner &amp;&amp; !strcmp(owner, purple_account_get_username(acct))) {
<a name="l01368"></a>01368     act = purple_menu_action_new(_(<span class="stringliteral">&quot;Get Notes Address Book Info&quot;</span>),
<a name="l01369"></a>01369                                PURPLE_CALLBACK(blist_menu_nab), pd, NULL);
<a name="l01370"></a>01370     *menu = g_list_append(*menu, act);
<a name="l01371"></a>01371   }
<a name="l01372"></a>01372 }
<a name="l01373"></a>01373 
<a name="l01374"></a>01374 
<a name="l01375"></a>01375 <span class="comment">/* lifted this from oldstatus, since HEAD doesn&#39;t do this at login</span>
<a name="l01376"></a>01376 <span class="comment">   anymore. */</span>
<a name="l01377"></a>01377 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_init(<a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct) {
<a name="l01378"></a>01378   <a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *gnode, *cnode, *bnode;
<a name="l01379"></a>01379   GList *add_buds = NULL;
<a name="l01380"></a>01380 
<a name="l01381"></a>01381   <span class="keywordflow">for</span>(gnode = purple_blist_get_root(); gnode;
<a name="l01382"></a>01382                   gnode = purple_blist_node_get_sibling_next(gnode)) {
<a name="l01383"></a>01383     <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_GROUP(gnode)) <span class="keywordflow">continue</span>;
<a name="l01384"></a>01384 
<a name="l01385"></a>01385     <span class="keywordflow">for</span>(cnode = purple_blist_node_get_first_child(gnode);
<a name="l01386"></a>01386                         cnode;
<a name="l01387"></a>01387                         cnode = purple_blist_node_get_sibling_next(cnode)) {
<a name="l01388"></a>01388       <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_CONTACT(cnode))
<a name="l01389"></a>01389         <span class="keywordflow">continue</span>;
<a name="l01390"></a>01390       <span class="keywordflow">for</span>(bnode = purple_blist_node_get_first_child(cnode);
<a name="l01391"></a>01391                           bnode;
<a name="l01392"></a>01392                           bnode = purple_blist_node_get_sibling_next(bnode)) {
<a name="l01393"></a>01393         <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *b;
<a name="l01394"></a>01394         <span class="keywordflow">if</span>(!PURPLE_BLIST_NODE_IS_BUDDY(bnode))
<a name="l01395"></a>01395           <span class="keywordflow">continue</span>;
<a name="l01396"></a>01396 
<a name="l01397"></a>01397         b = (<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *)bnode;
<a name="l01398"></a>01398         <span class="keywordflow">if</span>(purple_buddy_get_account(b) == acct) {
<a name="l01399"></a>01399           add_buds = g_list_append(add_buds, b);
<a name="l01400"></a>01400         }
<a name="l01401"></a>01401       }
<a name="l01402"></a>01402     }
<a name="l01403"></a>01403   }
<a name="l01404"></a>01404 
<a name="l01405"></a>01405   <span class="keywordflow">if</span>(add_buds) {
<a name="l01406"></a>01406     purple_account_add_buddies(acct, add_buds);
<a name="l01407"></a>01407     g_list_free(add_buds);
<a name="l01408"></a>01408   }
<a name="l01409"></a>01409 }
<a name="l01410"></a>01410 
<a name="l01411"></a>01411 
<a name="l01413"></a>01413 <span class="keyword">static</span> <span class="keywordtype">void</span> services_starting(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd) {
<a name="l01414"></a>01414 
<a name="l01415"></a>01415   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l01416"></a>01416   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l01417"></a>01417   <span class="keyword">struct </span>mwStorageUnit *unit;
<a name="l01418"></a>01418   <a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *l;
<a name="l01419"></a>01419 
<a name="l01420"></a>01420   gc = pd-&gt;gc;
<a name="l01421"></a>01421   acct = purple_connection_get_account(gc);
<a name="l01422"></a>01422 
<a name="l01423"></a>01423   <span class="comment">/* grab the buddy list from the server */</span>
<a name="l01424"></a>01424   unit = mwStorageUnit_new(mwStore_AWARE_LIST);
<a name="l01425"></a>01425   mwServiceStorage_load(pd-&gt;srvc_store, unit, fetch_blist_cb, pd, NULL);
<a name="l01426"></a>01426 
<a name="l01427"></a>01427   <span class="comment">/* find all the NAB groups and subscribe to them */</span>
<a name="l01428"></a>01428   <span class="keywordflow">for</span>(l = purple_blist_get_root(); l;
<a name="l01429"></a>01429                   l = purple_blist_node_get_sibling_next(l)) {
<a name="l01430"></a>01430     <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group = (<a class="code" href="struct___purple_group.html">PurpleGroup</a> *) l;
<a name="l01431"></a>01431     <span class="keyword">enum</span> mwSametimeGroupType gt;
<a name="l01432"></a>01432     <span class="keyword">const</span> <span class="keywordtype">char</span> *owner;
<a name="l01433"></a>01433 
<a name="l01434"></a>01434     <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_GROUP(l)) <span class="keywordflow">continue</span>;
<a name="l01435"></a>01435 
<a name="l01436"></a>01436     <span class="comment">/* if the group is ownerless, or has an owner and we&#39;re not it,</span>
<a name="l01437"></a>01437 <span class="comment">       skip it */</span>
<a name="l01438"></a>01438     owner = purple_blist_node_get_string(l, GROUP_KEY_OWNER);
<a name="l01439"></a>01439     <span class="keywordflow">if</span>(!owner || strcmp(owner, purple_account_get_username(acct)))
<a name="l01440"></a>01440       <span class="keywordflow">continue</span>;
<a name="l01441"></a>01441 
<a name="l01442"></a>01442     gt = purple_blist_node_get_int(l, GROUP_KEY_TYPE);
<a name="l01443"></a>01443     <span class="keywordflow">if</span>(gt == mwSametimeGroup_DYNAMIC)
<a name="l01444"></a>01444       group_add(pd, group);
<a name="l01445"></a>01445   }
<a name="l01446"></a>01446 
<a name="l01447"></a>01447   <span class="comment">/* set the aware attributes */</span>
<a name="l01448"></a>01448   <span class="comment">/* indicate we understand what AV prefs are, but don&#39;t support any */</span>
<a name="l01449"></a>01449   mwServiceAware_setAttributeBoolean(pd-&gt;srvc_aware,
<a name="l01450"></a>01450                                      mwAttribute_AV_PREFS_SET, TRUE);
<a name="l01451"></a>01451   mwServiceAware_unsetAttribute(pd-&gt;srvc_aware, mwAttribute_MICROPHONE);
<a name="l01452"></a>01452   mwServiceAware_unsetAttribute(pd-&gt;srvc_aware, mwAttribute_SPEAKERS);
<a name="l01453"></a>01453   mwServiceAware_unsetAttribute(pd-&gt;srvc_aware, mwAttribute_VIDEO_CAMERA);
<a name="l01454"></a>01454 
<a name="l01455"></a>01455   <span class="comment">/* ... but we can do file transfers! */</span>
<a name="l01456"></a>01456   mwServiceAware_setAttributeBoolean(pd-&gt;srvc_aware,
<a name="l01457"></a>01457                                      mwAttribute_FILE_TRANSFER, TRUE);
<a name="l01458"></a>01458 
<a name="l01459"></a>01459   blist_init(acct);
<a name="l01460"></a>01460 }
<a name="l01461"></a>01461 
<a name="l01462"></a>01462 
<a name="l01463"></a>01463 <span class="keyword">static</span> <span class="keywordtype">void</span> session_loginRedirect(<span class="keyword">struct</span> mwSession *session,
<a name="l01464"></a>01464                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *host) {
<a name="l01465"></a>01465   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l01466"></a>01466   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l01467"></a>01467   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *account;
<a name="l01468"></a>01468   guint port;
<a name="l01469"></a>01469   <span class="keyword">const</span> <span class="keywordtype">char</span> *current_host;
<a name="l01470"></a>01470 
<a name="l01471"></a>01471   pd = mwSession_getClientData(session);
<a name="l01472"></a>01472   gc = pd-&gt;gc;
<a name="l01473"></a>01473   account = purple_connection_get_account(gc);
<a name="l01474"></a>01474   port = purple_account_get_int(account, MW_KEY_PORT, MW_PLUGIN_DEFAULT_PORT);
<a name="l01475"></a>01475   current_host = purple_account_get_string(account, MW_KEY_HOST,
<a name="l01476"></a>01476                                          MW_PLUGIN_DEFAULT_HOST);
<a name="l01477"></a>01477 
<a name="l01478"></a>01478   <span class="keywordflow">if</span>(purple_account_get_bool(account, MW_KEY_FORCE, FALSE) ||
<a name="l01479"></a>01479      !host || (! strcmp(current_host, host)) ||
<a name="l01480"></a>01480      (purple_proxy_connect(gc, account, host, port, connect_cb, pd) == NULL)) {
<a name="l01481"></a>01481 
<a name="l01482"></a>01482     <span class="comment">/* if we&#39;re configured to force logins, or if we&#39;re being</span>
<a name="l01483"></a>01483 <span class="comment">       redirected to the already configured host, or if we couldn&#39;t</span>
<a name="l01484"></a>01484 <span class="comment">       connect to the new host, we&#39;ll force the login instead */</span>
<a name="l01485"></a>01485 
<a name="l01486"></a>01486     mwSession_forceLogin(session);
<a name="l01487"></a>01487   }
<a name="l01488"></a>01488 }
<a name="l01489"></a>01489 
<a name="l01490"></a>01490 
<a name="l01491"></a>01491 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_set_status(<a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct, <a class="code" href="struct___purple_status.html">PurpleStatus</a> *status);
<a name="l01492"></a>01492 
<a name="l01493"></a>01493 
<a name="l01497"></a>01497 <span class="keyword">static</span> <span class="keywordtype">void</span> session_started(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd) {
<a name="l01498"></a>01498   <a class="code" href="struct___purple_status.html">PurpleStatus</a> *status;
<a name="l01499"></a>01499   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l01500"></a>01500 
<a name="l01501"></a>01501   <span class="comment">/* set out initial status */</span>
<a name="l01502"></a>01502   acct = purple_connection_get_account(pd-&gt;gc);
<a name="l01503"></a>01503   status = purple_account_get_active_status(acct);
<a name="l01504"></a>01504   mw_prpl_set_status(acct, status);
<a name="l01505"></a>01505 
<a name="l01506"></a>01506   <span class="comment">/* start watching for new conversations */</span>
<a name="l01507"></a>01507   <a class="code" href="signals_8c.html#a5c2736631c4885c33ac650b7691317eb">purple_signal_connect</a>(purple_conversations_get_handle(),
<a name="l01508"></a>01508                       <span class="stringliteral">&quot;conversation-created&quot;</span>, pd,
<a name="l01509"></a>01509                       PURPLE_CALLBACK(conversation_created_cb), pd);
<a name="l01510"></a>01510 
<a name="l01511"></a>01511   <span class="comment">/* watch for group extended menu items */</span>
<a name="l01512"></a>01512   <a class="code" href="signals_8c.html#a5c2736631c4885c33ac650b7691317eb">purple_signal_connect</a>(purple_blist_get_handle(),
<a name="l01513"></a>01513                       <span class="stringliteral">&quot;blist-node-extended-menu&quot;</span>, pd,
<a name="l01514"></a>01514                       PURPLE_CALLBACK(blist_node_menu_cb), pd);
<a name="l01515"></a>01515 
<a name="l01516"></a>01516   <span class="comment">/* use our services to do neat things */</span>
<a name="l01517"></a>01517   services_starting(pd);
<a name="l01518"></a>01518 }
<a name="l01519"></a>01519 
<a name="l01520"></a>01520 
<a name="l01521"></a>01521 <span class="keyword">static</span> <span class="keywordtype">void</span> session_stopping(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd) {
<a name="l01522"></a>01522   <span class="comment">/* stop watching the signals from session_started */</span>
<a name="l01523"></a>01523   <a class="code" href="signals_8c.html#a90053d26148c691eae5f7d2c7d578c8d">purple_signals_disconnect_by_handle</a>(pd);
<a name="l01524"></a>01524 }
<a name="l01525"></a>01525 
<a name="l01526"></a>01526 
<a name="l01527"></a>01527 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_session_stateChange(<span class="keyword">struct</span> mwSession *session,
<a name="l01528"></a>01528                                    <span class="keyword">enum</span> mwSessionState state,
<a name="l01529"></a>01529                                    gpointer info) {
<a name="l01530"></a>01530   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l01531"></a>01531   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l01532"></a>01532   <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = NULL;
<a name="l01533"></a>01533 
<a name="l01534"></a>01534   pd = mwSession_getClientData(session);
<a name="l01535"></a>01535   gc = pd-&gt;gc;
<a name="l01536"></a>01536 
<a name="l01537"></a>01537   <span class="keywordflow">switch</span>(state) {
<a name="l01538"></a>01538   <span class="keywordflow">case</span> mwSession_STARTING:
<a name="l01539"></a>01539     msg = _(<span class="stringliteral">&quot;Sending Handshake&quot;</span>);
<a name="l01540"></a>01540     purple_connection_update_progress(gc, msg, 2, MW_CONNECT_STEPS);
<a name="l01541"></a>01541     <span class="keywordflow">break</span>;
<a name="l01542"></a>01542 
<a name="l01543"></a>01543   <span class="keywordflow">case</span> mwSession_HANDSHAKE:
<a name="l01544"></a>01544     msg = _(<span class="stringliteral">&quot;Waiting for Handshake Acknowledgement&quot;</span>);
<a name="l01545"></a>01545     purple_connection_update_progress(gc, msg, 3, MW_CONNECT_STEPS);
<a name="l01546"></a>01546     <span class="keywordflow">break</span>;
<a name="l01547"></a>01547 
<a name="l01548"></a>01548   <span class="keywordflow">case</span> mwSession_HANDSHAKE_ACK:
<a name="l01549"></a>01549     msg = _(<span class="stringliteral">&quot;Handshake Acknowledged, Sending Login&quot;</span>);
<a name="l01550"></a>01550     purple_connection_update_progress(gc, msg, 4, MW_CONNECT_STEPS);
<a name="l01551"></a>01551     <span class="keywordflow">break</span>;
<a name="l01552"></a>01552 
<a name="l01553"></a>01553   <span class="keywordflow">case</span> mwSession_LOGIN:
<a name="l01554"></a>01554     msg = _(<span class="stringliteral">&quot;Waiting for Login Acknowledgement&quot;</span>);
<a name="l01555"></a>01555     purple_connection_update_progress(gc, msg, 5, MW_CONNECT_STEPS);
<a name="l01556"></a>01556     <span class="keywordflow">break</span>;
<a name="l01557"></a>01557 
<a name="l01558"></a>01558   <span class="keywordflow">case</span> mwSession_LOGIN_REDIR:
<a name="l01559"></a>01559     msg = _(<span class="stringliteral">&quot;Login Redirected&quot;</span>);
<a name="l01560"></a>01560     purple_connection_update_progress(gc, msg, 6, MW_CONNECT_STEPS);
<a name="l01561"></a>01561     session_loginRedirect(session, info);
<a name="l01562"></a>01562     <span class="keywordflow">break</span>;
<a name="l01563"></a>01563 
<a name="l01564"></a>01564   <span class="keywordflow">case</span> mwSession_LOGIN_CONT:
<a name="l01565"></a>01565     msg = _(<span class="stringliteral">&quot;Forcing Login&quot;</span>);
<a name="l01566"></a>01566     purple_connection_update_progress(gc, msg, 7, MW_CONNECT_STEPS);
<a name="l01567"></a>01567 
<a name="l01568"></a>01568   <span class="keywordflow">case</span> mwSession_LOGIN_ACK:
<a name="l01569"></a>01569     msg = _(<span class="stringliteral">&quot;Login Acknowledged&quot;</span>);
<a name="l01570"></a>01570     purple_connection_update_progress(gc, msg, 8, MW_CONNECT_STEPS);
<a name="l01571"></a>01571     <span class="keywordflow">break</span>;
<a name="l01572"></a>01572 
<a name="l01573"></a>01573   <span class="keywordflow">case</span> mwSession_STARTED:
<a name="l01574"></a>01574     msg = _(<span class="stringliteral">&quot;Starting Services&quot;</span>);
<a name="l01575"></a>01575     purple_connection_update_progress(gc, msg, 9, MW_CONNECT_STEPS);
<a name="l01576"></a>01576 
<a name="l01577"></a>01577     session_started(pd);
<a name="l01578"></a>01578 
<a name="l01579"></a>01579     msg = _(<span class="stringliteral">&quot;Connected&quot;</span>);
<a name="l01580"></a>01580     purple_connection_update_progress(gc, msg, 10, MW_CONNECT_STEPS);
<a name="l01581"></a>01581     purple_connection_set_state(gc, <a class="code" href="connection_8h.html#afba52f486d090ff5e2d1189fd93fff2ca76b07b6cf140a5f65d41791f9b09aaf8">PURPLE_CONNECTED</a>);
<a name="l01582"></a>01582     <span class="keywordflow">break</span>;
<a name="l01583"></a>01583 
<a name="l01584"></a>01584   <span class="keywordflow">case</span> mwSession_STOPPING:
<a name="l01585"></a>01585 
<a name="l01586"></a>01586     session_stopping(pd);
<a name="l01587"></a>01587 
<a name="l01588"></a>01588     <span class="keywordflow">if</span>(GPOINTER_TO_UINT(info) &amp; ERR_FAILURE) {
<a name="l01589"></a>01589       <span class="keywordtype">char</span> *err = mwError(GPOINTER_TO_UINT(info));
<a name="l01590"></a>01590       <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4d">PurpleConnectionError</a> reason;
<a name="l01591"></a>01591       <span class="keywordflow">switch</span> (GPOINTER_TO_UINT(info)) {
<a name="l01592"></a>01592       <span class="keywordflow">case</span> VERSION_MISMATCH:
<a name="l01593"></a>01593         reason = <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4dac75515e26e28365555ad227717317ffa">PURPLE_CONNECTION_ERROR_OTHER_ERROR</a>;
<a name="l01594"></a>01594         <span class="keywordflow">break</span>;
<a name="l01595"></a>01595 
<a name="l01596"></a>01596       <span class="keywordflow">case</span> USER_RESTRICTED:
<a name="l01597"></a>01597       <span class="keywordflow">case</span> INCORRECT_LOGIN:
<a name="l01598"></a>01598       <span class="keywordflow">case</span> USER_UNREGISTERED:
<a name="l01599"></a>01599       <span class="keywordflow">case</span> GUEST_IN_USE:
<a name="l01600"></a>01600         reason = <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4dadd884939b748d1cd207fb529af928f28">PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED</a>;
<a name="l01601"></a>01601         <span class="keywordflow">break</span>;
<a name="l01602"></a>01602 
<a name="l01603"></a>01603       <span class="keywordflow">case</span> ENCRYPT_MISMATCH:
<a name="l01604"></a>01604       <span class="keywordflow">case</span> ERR_ENCRYPT_NO_SUPPORT:
<a name="l01605"></a>01605       <span class="keywordflow">case</span> ERR_NO_COMMON_ENCRYPT:
<a name="l01606"></a>01606         reason = <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4dae6f9caf65f4cbbdb9b2929462d3d0aab">PURPLE_CONNECTION_ERROR_ENCRYPTION_ERROR</a>;
<a name="l01607"></a>01607         <span class="keywordflow">break</span>;
<a name="l01608"></a>01608 
<a name="l01609"></a>01609       <span class="keywordflow">case</span> VERIFICATION_DOWN:
<a name="l01610"></a>01610         reason = <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4dacacab1a9719061afa010fa4189a3d52a">PURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE</a>;
<a name="l01611"></a>01611         <span class="keywordflow">break</span>;
<a name="l01612"></a>01612 
<a name="l01613"></a>01613       <span class="keywordflow">case</span> MULTI_SERVER_LOGIN:
<a name="l01614"></a>01614       <span class="keywordflow">case</span> MULTI_SERVER_LOGIN2:
<a name="l01615"></a>01615         reason = <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4da01d01468d36799111033580134e42cf4">PURPLE_CONNECTION_ERROR_NAME_IN_USE</a>;
<a name="l01616"></a>01616         <span class="keywordflow">break</span>;
<a name="l01617"></a>01617 
<a name="l01618"></a>01618       <span class="keywordflow">default</span>:
<a name="l01619"></a>01619         reason = <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4dae83601cb8c581624c7af7dd81b5eaac9">PURPLE_CONNECTION_ERROR_NETWORK_ERROR</a>;
<a name="l01620"></a>01620       }
<a name="l01621"></a>01621       purple_connection_error_reason(gc, reason, err);
<a name="l01622"></a>01622       g_free(err);
<a name="l01623"></a>01623     }
<a name="l01624"></a>01624     <span class="keywordflow">break</span>;
<a name="l01625"></a>01625 
<a name="l01626"></a>01626   <span class="keywordflow">case</span> mwSession_STOPPED:
<a name="l01627"></a>01627     <span class="keywordflow">break</span>;
<a name="l01628"></a>01628 
<a name="l01629"></a>01629   <span class="keywordflow">case</span> mwSession_UNKNOWN:
<a name="l01630"></a>01630   <span class="keywordflow">default</span>:
<a name="l01631"></a>01631     DEBUG_WARN(<span class="stringliteral">&quot;session in unknown state\n&quot;</span>);
<a name="l01632"></a>01632   }
<a name="l01633"></a>01633 }
<a name="l01634"></a>01634 
<a name="l01635"></a>01635 
<a name="l01636"></a>01636 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_session_setPrivacyInfo(<span class="keyword">struct</span> mwSession *session) {
<a name="l01637"></a>01637   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l01638"></a>01638   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l01639"></a>01639   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l01640"></a>01640   <span class="keyword">struct </span>mwPrivacyInfo *privacy;
<a name="l01641"></a>01641   GSList *l, **ll;
<a name="l01642"></a>01642   guint count;
<a name="l01643"></a>01643 
<a name="l01644"></a>01644   DEBUG_INFO(<span class="stringliteral">&quot;privacy information set from server\n&quot;</span>);
<a name="l01645"></a>01645 
<a name="l01646"></a>01646   g_return_if_fail(session != NULL);
<a name="l01647"></a>01647 
<a name="l01648"></a>01648   pd = mwSession_getClientData(session);
<a name="l01649"></a>01649   g_return_if_fail(pd != NULL);
<a name="l01650"></a>01650 
<a name="l01651"></a>01651   gc = pd-&gt;gc;
<a name="l01652"></a>01652   g_return_if_fail(gc != NULL);
<a name="l01653"></a>01653 
<a name="l01654"></a>01654   acct = purple_connection_get_account(gc);
<a name="l01655"></a>01655   g_return_if_fail(acct != NULL);
<a name="l01656"></a>01656 
<a name="l01657"></a>01657   privacy = mwSession_getPrivacyInfo(session);
<a name="l01658"></a>01658   count = privacy-&gt;count;
<a name="l01659"></a>01659 
<a name="l01660"></a>01660   ll = (privacy-&gt;deny)? &amp;acct-&gt;<a class="code" href="struct___purple_account.html#a2ae4cc7ca75d07b1f21fad9ed7f5f265">deny</a>: &amp;acct-&gt;<a class="code" href="struct___purple_account.html#abdcff8170459c1ff09ec87d984bf4e7f">permit</a>;
<a name="l01661"></a>01661   <span class="keywordflow">for</span>(l = *ll; l; l = l-&gt;next) g_free(l-&gt;data);
<a name="l01662"></a>01662   g_slist_free(*ll);
<a name="l01663"></a>01663   l = *ll = NULL;
<a name="l01664"></a>01664 
<a name="l01665"></a>01665   <span class="keywordflow">while</span>(count--) {
<a name="l01666"></a>01666     <span class="keyword">struct </span>mwUserItem *u = privacy-&gt;users + count;
<a name="l01667"></a>01667     l = g_slist_prepend(l, g_strdup(u-&gt;id));
<a name="l01668"></a>01668   }
<a name="l01669"></a>01669   *ll = l;
<a name="l01670"></a>01670 }
<a name="l01671"></a>01671 
<a name="l01672"></a>01672 
<a name="l01673"></a>01673 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_session_setUserStatus(<span class="keyword">struct</span> mwSession *session) {
<a name="l01674"></a>01674   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l01675"></a>01675   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l01676"></a>01676   <span class="keyword">struct </span>mwAwareIdBlock idb = { mwAware_USER, NULL, NULL };
<a name="l01677"></a>01677   <span class="keyword">struct </span>mwUserStatus *stat;
<a name="l01678"></a>01678 
<a name="l01679"></a>01679   g_return_if_fail(session != NULL);
<a name="l01680"></a>01680 
<a name="l01681"></a>01681   pd = mwSession_getClientData(session);
<a name="l01682"></a>01682   g_return_if_fail(pd != NULL);
<a name="l01683"></a>01683 
<a name="l01684"></a>01684   gc = pd-&gt;gc;
<a name="l01685"></a>01685   g_return_if_fail(gc != NULL);
<a name="l01686"></a>01686 
<a name="l01687"></a>01687   idb.user = mwSession_getProperty(session, mwSession_AUTH_USER_ID);
<a name="l01688"></a>01688   stat = mwSession_getUserStatus(session);
<a name="l01689"></a>01689 
<a name="l01690"></a>01690   <span class="comment">/* trigger an update of our own status if we&#39;re in the buddy list */</span>
<a name="l01691"></a>01691   mwServiceAware_setStatus(pd-&gt;srvc_aware, &amp;idb, stat);
<a name="l01692"></a>01692 }
<a name="l01693"></a>01693 
<a name="l01694"></a>01694 
<a name="l01695"></a>01695 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_session_admin(<span class="keyword">struct</span> mwSession *session,
<a name="l01696"></a>01696                              <span class="keyword">const</span> <span class="keywordtype">char</span> *text) {
<a name="l01697"></a>01697   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l01698"></a>01698   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l01699"></a>01699   <span class="keyword">const</span> <span class="keywordtype">char</span> *host;
<a name="l01700"></a>01700   <span class="keyword">const</span> <span class="keywordtype">char</span> *msg;
<a name="l01701"></a>01701   <span class="keywordtype">char</span> *prim;
<a name="l01702"></a>01702 
<a name="l01703"></a>01703   gc = session_to_gc(session);
<a name="l01704"></a>01704   g_return_if_fail(gc != NULL);
<a name="l01705"></a>01705 
<a name="l01706"></a>01706   acct = purple_connection_get_account(gc);
<a name="l01707"></a>01707   g_return_if_fail(acct != NULL);
<a name="l01708"></a>01708 
<a name="l01709"></a>01709   host = purple_account_get_string(acct, MW_KEY_HOST, NULL);
<a name="l01710"></a>01710 
<a name="l01711"></a>01711   msg = _(<span class="stringliteral">&quot;A Sametime administrator has issued the following announcement&quot;</span>
<a name="l01712"></a>01712            <span class="stringliteral">&quot; on server %s&quot;</span>);
<a name="l01713"></a>01713   prim = g_strdup_printf(msg, NSTR(host));
<a name="l01714"></a>01714 
<a name="l01715"></a>01715   purple_notify_message(gc, <a class="code" href="notify_8h.html#a15f1956721eee2abc1ba9ccda01c08c8a12a7c3c2102790cc9cb75d5f78e6c90a">PURPLE_NOTIFY_MSG_INFO</a>,
<a name="l01716"></a>01716                       _(<span class="stringliteral">&quot;Sametime Administrator Announcement&quot;</span>),
<a name="l01717"></a>01717                       prim, text, NULL, NULL);
<a name="l01718"></a>01718 
<a name="l01719"></a>01719   g_free(prim);
<a name="l01720"></a>01720 }
<a name="l01721"></a>01721 
<a name="l01722"></a>01722 
<a name="l01726"></a>01726 <span class="keyword">static</span> <span class="keywordtype">int</span> read_recv(<span class="keyword">struct</span> mwSession *session, <span class="keywordtype">int</span> sock) {
<a name="l01727"></a>01727   guchar buf[BUF_LEN];
<a name="l01728"></a>01728   <span class="keywordtype">int</span> len;
<a name="l01729"></a>01729 
<a name="l01730"></a>01730   len = read(sock, buf, BUF_LEN);
<a name="l01731"></a>01731   <span class="keywordflow">if</span>(len &gt; 0) {
<a name="l01732"></a>01732     mwSession_recv(session, buf, len);
<a name="l01733"></a>01733   }
<a name="l01734"></a>01734 
<a name="l01735"></a>01735   <span class="keywordflow">return</span> len;
<a name="l01736"></a>01736 }
<a name="l01737"></a>01737 
<a name="l01738"></a>01738 
<a name="l01741"></a>01741 <span class="keyword">static</span> <span class="keywordtype">void</span> read_cb(gpointer data, gint source, <a class="code" href="eventloop_8h.html#ae16a4b18f1da57dff1eb139e934fffb3">PurpleInputCondition</a> cond) {
<a name="l01742"></a>01742   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = data;
<a name="l01743"></a>01743   <span class="keywordtype">int</span> ret = 0, err = 0;
<a name="l01744"></a>01744 
<a name="l01745"></a>01745   g_return_if_fail(pd != NULL);
<a name="l01746"></a>01746 
<a name="l01747"></a>01747   ret = read_recv(pd-&gt;session, pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>);
<a name="l01748"></a>01748 
<a name="l01749"></a>01749   <span class="comment">/* normal operation ends here */</span>
<a name="l01750"></a>01750   <span class="keywordflow">if</span>(ret &gt; 0) <span class="keywordflow">return</span>;
<a name="l01751"></a>01751 
<a name="l01752"></a>01752   <span class="comment">/* fetch the global error value */</span>
<a name="l01753"></a>01753   err = errno;
<a name="l01754"></a>01754 
<a name="l01755"></a>01755   <span class="comment">/* read problem occurred if we&#39;re here, so we&#39;ll need to take care of</span>
<a name="l01756"></a>01756 <span class="comment">     it and clean up internal state */</span>
<a name="l01757"></a>01757 
<a name="l01758"></a>01758   <span class="keywordflow">if</span>(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>) {
<a name="l01759"></a>01759     close(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>);
<a name="l01760"></a>01760     pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a> = 0;
<a name="l01761"></a>01761   }
<a name="l01762"></a>01762 
<a name="l01763"></a>01763   <span class="keywordflow">if</span>(pd-&gt;gc-&gt;<a class="code" href="struct___purple_connection.html#a58491547528ab1611acab75d3eccbbbe">inpa</a>) {
<a name="l01764"></a>01764     <a class="code" href="eventloop_8c.html#ae309cb053b0e7984f10d9886367ed84e">purple_input_remove</a>(pd-&gt;gc-&gt;<a class="code" href="struct___purple_connection.html#a58491547528ab1611acab75d3eccbbbe">inpa</a>);
<a name="l01765"></a>01765     pd-&gt;gc-&gt;<a class="code" href="struct___purple_connection.html#a58491547528ab1611acab75d3eccbbbe">inpa</a> = 0;
<a name="l01766"></a>01766   }
<a name="l01767"></a>01767 
<a name="l01768"></a>01768   <span class="keywordflow">if</span>(! ret) {
<a name="l01769"></a>01769     DEBUG_INFO(<span class="stringliteral">&quot;connection reset\n&quot;</span>);
<a name="l01770"></a>01770     purple_connection_error_reason(pd-&gt;gc,
<a name="l01771"></a>01771                                    <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4dae83601cb8c581624c7af7dd81b5eaac9">PURPLE_CONNECTION_ERROR_NETWORK_ERROR</a>,
<a name="l01772"></a>01772                                    _(<span class="stringliteral">&quot;Server closed the connection&quot;</span>));
<a name="l01773"></a>01773 
<a name="l01774"></a>01774   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ret &lt; 0) {
<a name="l01775"></a>01775     <span class="keyword">const</span> gchar *err_str = g_strerror(err);
<a name="l01776"></a>01776     <span class="keywordtype">char</span> *msg = NULL;
<a name="l01777"></a>01777 
<a name="l01778"></a>01778     DEBUG_INFO(<span class="stringliteral">&quot;error in read callback: %s\n&quot;</span>, err_str);
<a name="l01779"></a>01779 
<a name="l01780"></a>01780     msg = g_strdup_printf(_(<span class="stringliteral">&quot;Lost connection with server: %s&quot;</span>), err_str);
<a name="l01781"></a>01781     purple_connection_error_reason(pd-&gt;gc,
<a name="l01782"></a>01782                                    <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4dae83601cb8c581624c7af7dd81b5eaac9">PURPLE_CONNECTION_ERROR_NETWORK_ERROR</a>,
<a name="l01783"></a>01783                                    msg);
<a name="l01784"></a>01784     g_free(msg);
<a name="l01785"></a>01785   }
<a name="l01786"></a>01786 }
<a name="l01787"></a>01787 
<a name="l01788"></a>01788 
<a name="l01791"></a>01791 <span class="keyword">static</span> <span class="keywordtype">void</span> connect_cb(gpointer data, gint source, <span class="keyword">const</span> gchar *error_message) {
<a name="l01792"></a>01792 
<a name="l01793"></a>01793   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = data;
<a name="l01794"></a>01794   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc = pd-&gt;gc;
<a name="l01795"></a>01795 
<a name="l01796"></a>01796   <span class="keywordflow">if</span>(source &lt; 0) {
<a name="l01797"></a>01797     <span class="comment">/* connection failed */</span>
<a name="l01798"></a>01798 
<a name="l01799"></a>01799     <span class="keywordflow">if</span>(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>) {
<a name="l01800"></a>01800       <span class="comment">/* this is a redirect connect, force login on existing socket */</span>
<a name="l01801"></a>01801       mwSession_forceLogin(pd-&gt;session);
<a name="l01802"></a>01802 
<a name="l01803"></a>01803     } <span class="keywordflow">else</span> {
<a name="l01804"></a>01804       <span class="comment">/* this is a regular connect, error out */</span>
<a name="l01805"></a>01805       gchar *tmp = g_strdup_printf(_(<span class="stringliteral">&quot;Unable to connect: %s&quot;</span>),
<a name="l01806"></a>01806           error_message);
<a name="l01807"></a>01807       purple_connection_error_reason(pd-&gt;gc,
<a name="l01808"></a>01808                                      <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4dae83601cb8c581624c7af7dd81b5eaac9">PURPLE_CONNECTION_ERROR_NETWORK_ERROR</a>,
<a name="l01809"></a>01809                                      tmp);
<a name="l01810"></a>01810       g_free(tmp);
<a name="l01811"></a>01811     }
<a name="l01812"></a>01812 
<a name="l01813"></a>01813     <span class="keywordflow">return</span>;
<a name="l01814"></a>01814   }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816   <span class="keywordflow">if</span>(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a>) {
<a name="l01817"></a>01817     <span class="comment">/* stop any existing login attempt */</span>
<a name="l01818"></a>01818     mwSession_stop(pd-&gt;session, ERR_SUCCESS);
<a name="l01819"></a>01819   }
<a name="l01820"></a>01820 
<a name="l01821"></a>01821   pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a116c50ac63563f111091ee2dd822a944">socket</a> = source;
<a name="l01822"></a>01822   gc-&gt;<a class="code" href="struct___purple_connection.html#a58491547528ab1611acab75d3eccbbbe">inpa</a> = <a class="code" href="eventloop_8c.html#ad4f7f5fdc0ee617d0e3fe358f04f838b">purple_input_add</a>(source, <a class="code" href="eventloop_8h.html#ae16a4b18f1da57dff1eb139e934fffb3a04a9339a9f5df8019b8afc3af679ec9e">PURPLE_INPUT_READ</a>,
<a name="l01823"></a>01823                             read_cb, pd);
<a name="l01824"></a>01824 
<a name="l01825"></a>01825   mwSession_start(pd-&gt;session);
<a name="l01826"></a>01826 }
<a name="l01827"></a>01827 
<a name="l01828"></a>01828 
<a name="l01829"></a>01829 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_session_announce(<span class="keyword">struct</span> mwSession *s,
<a name="l01830"></a>01830                                 <span class="keyword">struct</span> mwLoginInfo *from,
<a name="l01831"></a>01831                                 gboolean may_reply,
<a name="l01832"></a>01832                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *text) {
<a name="l01833"></a>01833   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l01834"></a>01834   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l01835"></a>01835   <a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *conv;
<a name="l01836"></a>01836   <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy;
<a name="l01837"></a>01837   <span class="keywordtype">char</span> *who = from-&gt;user_id;
<a name="l01838"></a>01838   <span class="keywordtype">char</span> *msg;
<a name="l01839"></a>01839 
<a name="l01840"></a>01840   pd = mwSession_getClientData(s);
<a name="l01841"></a>01841   acct = purple_connection_get_account(pd-&gt;gc);
<a name="l01842"></a>01842   conv = purple_find_conversation_with_account(<a class="code" href="conversation_8h.html#a9e9f3ae232444332eb34f16aef64f721a4e1c3df052e10fb1b3789ce5925496ab">PURPLE_CONV_TYPE_IM</a>, who, acct);
<a name="l01843"></a>01843   <span class="keywordflow">if</span>(! conv) conv = purple_conversation_new(<a class="code" href="conversation_8h.html#a9e9f3ae232444332eb34f16aef64f721a4e1c3df052e10fb1b3789ce5925496ab">PURPLE_CONV_TYPE_IM</a>, acct, who);
<a name="l01844"></a>01844 
<a name="l01845"></a>01845   buddy = purple_find_buddy(acct, who);
<a name="l01846"></a>01846   <span class="keywordflow">if</span>(buddy) who = (<span class="keywordtype">char</span> *) purple_buddy_get_contact_alias(buddy);
<a name="l01847"></a>01847 
<a name="l01848"></a>01848   who = g_strdup_printf(_(<span class="stringliteral">&quot;Announcement from %s&quot;</span>), who);
<a name="l01849"></a>01849   msg = purple_markup_linkify(text);
<a name="l01850"></a>01850 
<a name="l01851"></a>01851   purple_conversation_write(conv, who, msg ? msg : <span class="stringliteral">&quot;&quot;</span>, <a class="code" href="conversation_8h.html#a66e44dfdc0de2953d73f03fb806bf6f5ad91787cbf26661c31fe083036d514621">PURPLE_MESSAGE_RECV</a>, time(NULL));
<a name="l01852"></a>01852   g_free(who);
<a name="l01853"></a>01853   g_free(msg);
<a name="l01854"></a>01854 }
<a name="l01855"></a>01855 
<a name="l01856"></a>01856 
<a name="l01857"></a>01857 <span class="keyword">static</span> <span class="keyword">struct </span>mwSessionHandler mw_session_handler = {
<a name="l01858"></a>01858   mw_session_io_write,
<a name="l01859"></a>01859   mw_session_io_close,
<a name="l01860"></a>01860   mw_session_clear,
<a name="l01861"></a>01861   mw_session_stateChange,
<a name="l01862"></a>01862   mw_session_setPrivacyInfo,
<a name="l01863"></a>01863   mw_session_setUserStatus,
<a name="l01864"></a>01864   mw_session_admin,
<a name="l01865"></a>01865   mw_session_announce,
<a name="l01866"></a>01866 };
<a name="l01867"></a>01867 
<a name="l01868"></a>01868 
<a name="l01869"></a>01869 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_aware_on_attrib(<span class="keyword">struct</span> mwServiceAware *srvc,
<a name="l01870"></a>01870                                <span class="keyword">struct</span> mwAwareAttribute *attrib) {
<a name="l01871"></a>01871 
<a name="l01872"></a>01872   ; 
<a name="l01875"></a>01875 }
<a name="l01876"></a>01876 
<a name="l01877"></a>01877 
<a name="l01878"></a>01878 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_aware_clear(<span class="keyword">struct</span> mwServiceAware *srvc) {
<a name="l01879"></a>01879   ; <span class="comment">/* nothing for now */</span>
<a name="l01880"></a>01880 }
<a name="l01881"></a>01881 
<a name="l01882"></a>01882 
<a name="l01883"></a>01883 <span class="keyword">static</span> <span class="keyword">struct </span>mwAwareHandler mw_aware_handler = {
<a name="l01884"></a>01884   mw_aware_on_attrib,
<a name="l01885"></a>01885   mw_aware_clear,
<a name="l01886"></a>01886 };
<a name="l01887"></a>01887 
<a name="l01888"></a>01888 
<a name="l01889"></a>01889 <span class="keyword">static</span> <span class="keyword">struct </span>mwServiceAware *mw_srvc_aware_new(<span class="keyword">struct</span> mwSession *s) {
<a name="l01890"></a>01890   <span class="keyword">struct </span>mwServiceAware *srvc;
<a name="l01891"></a>01891   srvc = mwServiceAware_new(s, &amp;mw_aware_handler);
<a name="l01892"></a>01892   <span class="keywordflow">return</span> srvc;
<a name="l01893"></a>01893 };
<a name="l01894"></a>01894 
<a name="l01895"></a>01895 
<a name="l01896"></a>01896 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_conf_invited(<span class="keyword">struct</span> mwConference *conf,
<a name="l01897"></a>01897                             <span class="keyword">struct</span> mwLoginInfo *inviter,
<a name="l01898"></a>01898                             <span class="keyword">const</span> <span class="keywordtype">char</span> *invitation) {
<a name="l01899"></a>01899 
<a name="l01900"></a>01900   <span class="keyword">struct </span>mwServiceConference *srvc;
<a name="l01901"></a>01901   <span class="keyword">struct </span>mwSession *session;
<a name="l01902"></a>01902   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l01903"></a>01903   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l01904"></a>01904 
<a name="l01905"></a>01905   <span class="keywordtype">char</span> *c_inviter, *c_name, *c_topic, *c_invitation;
<a name="l01906"></a>01906   GHashTable *ht;
<a name="l01907"></a>01907 
<a name="l01908"></a>01908   srvc = mwConference_getService(conf);
<a name="l01909"></a>01909   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l01910"></a>01910   pd = mwSession_getClientData(session);
<a name="l01911"></a>01911   gc = pd-&gt;gc;
<a name="l01912"></a>01912 
<a name="l01913"></a>01913   ht = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, g_free);
<a name="l01914"></a>01914 
<a name="l01915"></a>01915   c_inviter = g_strdup(inviter-&gt;user_id);
<a name="l01916"></a>01916   g_hash_table_insert(ht, CHAT_KEY_CREATOR, c_inviter);
<a name="l01917"></a>01917 
<a name="l01918"></a>01918   c_name = g_strdup(mwConference_getName(conf));
<a name="l01919"></a>01919   g_hash_table_insert(ht, CHAT_KEY_NAME, c_name);
<a name="l01920"></a>01920 
<a name="l01921"></a>01921   c_topic = g_strdup(mwConference_getTitle(conf));
<a name="l01922"></a>01922   g_hash_table_insert(ht, CHAT_KEY_TOPIC, c_topic);
<a name="l01923"></a>01923 
<a name="l01924"></a>01924   c_invitation = g_strdup(invitation);
<a name="l01925"></a>01925   g_hash_table_insert(ht, CHAT_KEY_INVITE, c_invitation);
<a name="l01926"></a>01926 
<a name="l01927"></a>01927   DEBUG_INFO(<span class="stringliteral">&quot;received invitation from &#39;%s&#39; to join (&#39;%s&#39;,&#39;%s&#39;): &#39;%s&#39;\n&quot;</span>,
<a name="l01928"></a>01928              NSTR(c_inviter), NSTR(c_name),
<a name="l01929"></a>01929              NSTR(c_topic), NSTR(c_invitation));
<a name="l01930"></a>01930 
<a name="l01931"></a>01931   <span class="keywordflow">if</span>(! c_topic) c_topic = <span class="stringliteral">&quot;(no title)&quot;</span>;
<a name="l01932"></a>01932   <span class="keywordflow">if</span>(! c_invitation) c_invitation = <span class="stringliteral">&quot;(no message)&quot;</span>;
<a name="l01933"></a>01933   serv_got_chat_invite(gc, c_topic, c_inviter, c_invitation, ht);
<a name="l01934"></a>01934 }
<a name="l01935"></a>01935 
<a name="l01936"></a>01936 
<a name="l01937"></a>01937 <span class="comment">/* The following mess helps us relate a mwConference to a PurpleConvChat</span>
<a name="l01938"></a>01938 <span class="comment">   in the various forms by which either may be indicated */</span>
<a name="l01939"></a>01939 
<a name="l01940"></a>01940 <span class="preprocessor">#define CONF_TO_ID(conf)   (GPOINTER_TO_INT(conf))</span>
<a name="l01941"></a>01941 <span class="preprocessor"></span><span class="preprocessor">#define ID_TO_CONF(pd, id) (conf_find_by_id((pd), (id)))</span>
<a name="l01942"></a>01942 <span class="preprocessor"></span>
<a name="l01943"></a>01943 <span class="preprocessor">#define CHAT_TO_ID(chat)   (purple_conv_chat_get_id(chat))</span>
<a name="l01944"></a>01944 <span class="preprocessor"></span><span class="preprocessor">#define ID_TO_CHAT(id)     (purple_find_chat(id))</span>
<a name="l01945"></a>01945 <span class="preprocessor"></span>
<a name="l01946"></a>01946 <span class="preprocessor">#define CHAT_TO_CONF(pd, chat)  (ID_TO_CONF((pd), CHAT_TO_ID(chat)))</span>
<a name="l01947"></a>01947 <span class="preprocessor"></span><span class="preprocessor">#define CONF_TO_CHAT(conf)      (ID_TO_CHAT(CONF_TO_ID(conf)))</span>
<a name="l01948"></a>01948 <span class="preprocessor"></span>
<a name="l01949"></a>01949 
<a name="l01950"></a>01950 <span class="keyword">static</span> <span class="keyword">struct </span>mwConference *
<a name="l01951"></a>01951 conf_find_by_id(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd, <span class="keywordtype">int</span> <span class="keywordtype">id</span>) {
<a name="l01952"></a>01952 
<a name="l01953"></a>01953   <span class="keyword">struct </span>mwServiceConference *srvc = pd-&gt;srvc_conf;
<a name="l01954"></a>01954   <span class="keyword">struct </span>mwConference *conf = NULL;
<a name="l01955"></a>01955   GList *l, *ll;
<a name="l01956"></a>01956 
<a name="l01957"></a>01957   ll = mwServiceConference_getConferences(srvc);
<a name="l01958"></a>01958   <span class="keywordflow">for</span>(l = ll; l; l = l-&gt;next) {
<a name="l01959"></a>01959     <span class="keyword">struct </span>mwConference *c = l-&gt;data;
<a name="l01960"></a>01960     <a class="code" href="struct___purple_conv_chat.html">PurpleConvChat</a> *h = mwConference_getClientData(c);
<a name="l01961"></a>01961 
<a name="l01962"></a>01962     <span class="keywordflow">if</span>(CHAT_TO_ID(h) == <span class="keywordtype">id</span>) {
<a name="l01963"></a>01963       conf = c;
<a name="l01964"></a>01964       <span class="keywordflow">break</span>;
<a name="l01965"></a>01965     }
<a name="l01966"></a>01966   }
<a name="l01967"></a>01967   g_list_free(ll);
<a name="l01968"></a>01968 
<a name="l01969"></a>01969   <span class="keywordflow">return</span> conf;
<a name="l01970"></a>01970 }
<a name="l01971"></a>01971 
<a name="l01972"></a>01972 
<a name="l01973"></a>01973 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_conf_opened(<span class="keyword">struct</span> mwConference *conf, GList *members) {
<a name="l01974"></a>01974   <span class="keyword">struct </span>mwServiceConference *srvc;
<a name="l01975"></a>01975   <span class="keyword">struct </span>mwSession *session;
<a name="l01976"></a>01976   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l01977"></a>01977   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l01978"></a>01978   <a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *g_conf;
<a name="l01979"></a>01979 
<a name="l01980"></a>01980   <span class="keyword">const</span> <span class="keywordtype">char</span> *n = mwConference_getName(conf);
<a name="l01981"></a>01981   <span class="keyword">const</span> <span class="keywordtype">char</span> *t = mwConference_getTitle(conf);
<a name="l01982"></a>01982 
<a name="l01983"></a>01983   DEBUG_INFO(<span class="stringliteral">&quot;conf %s opened, %u initial members\n&quot;</span>,
<a name="l01984"></a>01984              NSTR(n), g_list_length(members));
<a name="l01985"></a>01985 
<a name="l01986"></a>01986   srvc = mwConference_getService(conf);
<a name="l01987"></a>01987   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l01988"></a>01988   pd = mwSession_getClientData(session);
<a name="l01989"></a>01989   gc = pd-&gt;gc;
<a name="l01990"></a>01990 
<a name="l01991"></a>01991   <span class="keywordflow">if</span>(! t) t = <span class="stringliteral">&quot;(no title)&quot;</span>;
<a name="l01992"></a>01992   g_conf = serv_got_joined_chat(gc, CONF_TO_ID(conf), t);
<a name="l01993"></a>01993 
<a name="l01994"></a>01994   mwConference_setClientData(conf, PURPLE_CONV_CHAT(g_conf), NULL);
<a name="l01995"></a>01995 
<a name="l01996"></a>01996   <span class="keywordflow">for</span>(; members; members = members-&gt;next) {
<a name="l01997"></a>01997     <span class="keyword">struct </span>mwLoginInfo *peer = members-&gt;data;
<a name="l01998"></a>01998     purple_conv_chat_add_user(PURPLE_CONV_CHAT(g_conf), peer-&gt;user_id,
<a name="l01999"></a>01999                             NULL, <a class="code" href="conversation_8h.html#a3635e89c9e02d67f03439d6524272754add974cbea163764e0caf40927d177ee0">PURPLE_CBFLAGS_NONE</a>, FALSE);
<a name="l02000"></a>02000   }
<a name="l02001"></a>02001 }
<a name="l02002"></a>02002 
<a name="l02003"></a>02003 
<a name="l02004"></a>02004 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_conf_closed(<span class="keyword">struct</span> mwConference *conf, guint32 reason) {
<a name="l02005"></a>02005   <span class="keyword">struct </span>mwServiceConference *srvc;
<a name="l02006"></a>02006   <span class="keyword">struct </span>mwSession *session;
<a name="l02007"></a>02007   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l02008"></a>02008   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l02009"></a>02009 
<a name="l02010"></a>02010   <span class="keyword">const</span> <span class="keywordtype">char</span> *n = mwConference_getName(conf);
<a name="l02011"></a>02011   <span class="keywordtype">char</span> *msg = mwError(reason);
<a name="l02012"></a>02012 
<a name="l02013"></a>02013   DEBUG_INFO(<span class="stringliteral">&quot;conf %s closed, 0x%08x\n&quot;</span>, NSTR(n), reason);
<a name="l02014"></a>02014 
<a name="l02015"></a>02015   srvc = mwConference_getService(conf);
<a name="l02016"></a>02016   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l02017"></a>02017   pd = mwSession_getClientData(session);
<a name="l02018"></a>02018   gc = pd-&gt;gc;
<a name="l02019"></a>02019 
<a name="l02020"></a>02020   serv_got_chat_left(gc, CONF_TO_ID(conf));
<a name="l02021"></a>02021 
<a name="l02022"></a>02022   <a class="code" href="notify_8h.html#ad54861c382f50702e2c6c2317aff878d">purple_notify_error</a>(gc, _(<span class="stringliteral">&quot;Conference Closed&quot;</span>), NULL, msg);
<a name="l02023"></a>02023   g_free(msg);
<a name="l02024"></a>02024 }
<a name="l02025"></a>02025 
<a name="l02026"></a>02026 
<a name="l02027"></a>02027 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_conf_peer_joined(<span class="keyword">struct</span> mwConference *conf,
<a name="l02028"></a>02028                                 <span class="keyword">struct</span> mwLoginInfo *peer) {
<a name="l02029"></a>02029 
<a name="l02030"></a>02030   <span class="keyword">struct </span>mwServiceConference *srvc;
<a name="l02031"></a>02031   <span class="keyword">struct </span>mwSession *session;
<a name="l02032"></a>02032   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l02033"></a>02033   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l02034"></a>02034   <a class="code" href="struct___purple_conv_chat.html">PurpleConvChat</a> *g_conf;
<a name="l02035"></a>02035 
<a name="l02036"></a>02036   <span class="keyword">const</span> <span class="keywordtype">char</span> *n = mwConference_getName(conf);
<a name="l02037"></a>02037 
<a name="l02038"></a>02038   DEBUG_INFO(<span class="stringliteral">&quot;%s joined conf %s\n&quot;</span>, NSTR(peer-&gt;user_id), NSTR(n));
<a name="l02039"></a>02039 
<a name="l02040"></a>02040   srvc = mwConference_getService(conf);
<a name="l02041"></a>02041   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l02042"></a>02042   pd = mwSession_getClientData(session);
<a name="l02043"></a>02043   gc = pd-&gt;gc;
<a name="l02044"></a>02044 
<a name="l02045"></a>02045   g_conf = mwConference_getClientData(conf);
<a name="l02046"></a>02046   g_return_if_fail(g_conf != NULL);
<a name="l02047"></a>02047 
<a name="l02048"></a>02048   purple_conv_chat_add_user(g_conf, peer-&gt;user_id,
<a name="l02049"></a>02049                           NULL, <a class="code" href="conversation_8h.html#a3635e89c9e02d67f03439d6524272754add974cbea163764e0caf40927d177ee0">PURPLE_CBFLAGS_NONE</a>, TRUE);
<a name="l02050"></a>02050 }
<a name="l02051"></a>02051 
<a name="l02052"></a>02052 
<a name="l02053"></a>02053 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_conf_peer_parted(<span class="keyword">struct</span> mwConference *conf,
<a name="l02054"></a>02054                                 <span class="keyword">struct</span> mwLoginInfo *peer) {
<a name="l02055"></a>02055 
<a name="l02056"></a>02056   <span class="keyword">struct </span>mwServiceConference *srvc;
<a name="l02057"></a>02057   <span class="keyword">struct </span>mwSession *session;
<a name="l02058"></a>02058   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l02059"></a>02059   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l02060"></a>02060   <a class="code" href="struct___purple_conv_chat.html">PurpleConvChat</a> *g_conf;
<a name="l02061"></a>02061 
<a name="l02062"></a>02062   <span class="keyword">const</span> <span class="keywordtype">char</span> *n = mwConference_getName(conf);
<a name="l02063"></a>02063 
<a name="l02064"></a>02064   DEBUG_INFO(<span class="stringliteral">&quot;%s left conf %s\n&quot;</span>, NSTR(peer-&gt;user_id), NSTR(n));
<a name="l02065"></a>02065 
<a name="l02066"></a>02066   srvc = mwConference_getService(conf);
<a name="l02067"></a>02067   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l02068"></a>02068   pd = mwSession_getClientData(session);
<a name="l02069"></a>02069   gc = pd-&gt;gc;
<a name="l02070"></a>02070 
<a name="l02071"></a>02071   g_conf = mwConference_getClientData(conf);
<a name="l02072"></a>02072   g_return_if_fail(g_conf != NULL);
<a name="l02073"></a>02073 
<a name="l02074"></a>02074   purple_conv_chat_remove_user(g_conf, peer-&gt;user_id, NULL);
<a name="l02075"></a>02075 }
<a name="l02076"></a>02076 
<a name="l02077"></a>02077 
<a name="l02078"></a>02078 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_conf_text(<span class="keyword">struct</span> mwConference *conf,
<a name="l02079"></a>02079                          <span class="keyword">struct</span> mwLoginInfo *who, <span class="keyword">const</span> <span class="keywordtype">char</span> *text) {
<a name="l02080"></a>02080 
<a name="l02081"></a>02081   <span class="keyword">struct </span>mwServiceConference *srvc;
<a name="l02082"></a>02082   <span class="keyword">struct </span>mwSession *session;
<a name="l02083"></a>02083   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l02084"></a>02084   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l02085"></a>02085   <span class="keywordtype">char</span> *esc;
<a name="l02086"></a>02086 
<a name="l02087"></a>02087   <span class="keywordflow">if</span>(! text) <span class="keywordflow">return</span>;
<a name="l02088"></a>02088 
<a name="l02089"></a>02089   srvc = mwConference_getService(conf);
<a name="l02090"></a>02090   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l02091"></a>02091   pd = mwSession_getClientData(session);
<a name="l02092"></a>02092   gc = pd-&gt;gc;
<a name="l02093"></a>02093 
<a name="l02094"></a>02094   esc = g_markup_escape_text(text, -1);
<a name="l02095"></a>02095   serv_got_chat_in(gc, CONF_TO_ID(conf), who-&gt;user_id, 0, esc, time(NULL));
<a name="l02096"></a>02096   g_free(esc);
<a name="l02097"></a>02097 }
<a name="l02098"></a>02098 
<a name="l02099"></a>02099 
<a name="l02100"></a>02100 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_conf_typing(<span class="keyword">struct</span> mwConference *conf,
<a name="l02101"></a>02101                            <span class="keyword">struct</span> mwLoginInfo *who, gboolean typing) {
<a name="l02102"></a>02102 
<a name="l02103"></a>02103   <span class="comment">/* purple really has no good way to expose this to the user. */</span>
<a name="l02104"></a>02104 
<a name="l02105"></a>02105   <span class="keyword">const</span> <span class="keywordtype">char</span> *n = mwConference_getName(conf);
<a name="l02106"></a>02106   <span class="keyword">const</span> <span class="keywordtype">char</span> *w = who-&gt;user_id;
<a name="l02107"></a>02107 
<a name="l02108"></a>02108   <span class="keywordflow">if</span>(typing) {
<a name="l02109"></a>02109     DEBUG_INFO(<span class="stringliteral">&quot;%s in conf %s: &lt;typing&gt;\n&quot;</span>, NSTR(w), NSTR(n));
<a name="l02110"></a>02110 
<a name="l02111"></a>02111   } <span class="keywordflow">else</span> {
<a name="l02112"></a>02112     DEBUG_INFO(<span class="stringliteral">&quot;%s in conf %s: &lt;stopped typing&gt;\n&quot;</span>, NSTR(w), NSTR(n));
<a name="l02113"></a>02113   }
<a name="l02114"></a>02114 }
<a name="l02115"></a>02115 
<a name="l02116"></a>02116 
<a name="l02117"></a>02117 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_conf_clear(<span class="keyword">struct</span> mwServiceConference *srvc) {
<a name="l02118"></a>02118   ;
<a name="l02119"></a>02119 }
<a name="l02120"></a>02120 
<a name="l02121"></a>02121 
<a name="l02122"></a>02122 <span class="keyword">static</span> <span class="keyword">struct </span>mwConferenceHandler mw_conference_handler = {
<a name="l02123"></a>02123   mw_conf_invited,
<a name="l02124"></a>02124   mw_conf_opened,
<a name="l02125"></a>02125   mw_conf_closed,
<a name="l02126"></a>02126   mw_conf_peer_joined,
<a name="l02127"></a>02127   mw_conf_peer_parted,
<a name="l02128"></a>02128   mw_conf_text,
<a name="l02129"></a>02129   mw_conf_typing,
<a name="l02130"></a>02130   mw_conf_clear,
<a name="l02131"></a>02131 };
<a name="l02132"></a>02132 
<a name="l02133"></a>02133 
<a name="l02134"></a>02134 <span class="keyword">static</span> <span class="keyword">struct </span>mwServiceConference *mw_srvc_conf_new(<span class="keyword">struct</span> mwSession *s) {
<a name="l02135"></a>02135   <span class="keyword">struct </span>mwServiceConference *srvc;
<a name="l02136"></a>02136   srvc = mwServiceConference_new(s, &amp;mw_conference_handler);
<a name="l02137"></a>02137   <span class="keywordflow">return</span> srvc;
<a name="l02138"></a>02138 }
<a name="l02139"></a>02139 
<a name="l02140"></a>02140 
<a name="l02142"></a>02142 <span class="preprocessor">#define MW_FT_LEN  (BUF_LONG * 2)</span>
<a name="l02143"></a>02143 <span class="preprocessor"></span>
<a name="l02144"></a>02144 
<a name="l02145"></a>02145 <span class="keyword">static</span> <span class="keywordtype">void</span> ft_incoming_cancel(<a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer) {
<a name="l02146"></a>02146   <span class="comment">/* incoming transfer rejected or cancelled in-progress */</span>
<a name="l02147"></a>02147   <span class="keyword">struct </span>mwFileTransfer *ft = xfer-&gt;<a class="code" href="struct___purple_xfer.html#a4ce7ab5aaa647508c1eb9ba1593afeda">data</a>;
<a name="l02148"></a>02148   <span class="keywordflow">if</span>(ft) mwFileTransfer_reject(ft);
<a name="l02149"></a>02149 }
<a name="l02150"></a>02150 
<a name="l02151"></a>02151 
<a name="l02152"></a>02152 <span class="keyword">static</span> <span class="keywordtype">void</span> ft_incoming_init(<a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer) {
<a name="l02153"></a>02153   <span class="comment">/* incoming transfer accepted */</span>
<a name="l02154"></a>02154 
<a name="l02155"></a>02155   <span class="comment">/* - accept the mwFileTransfer</span>
<a name="l02156"></a>02156 <span class="comment">     - open/create the local FILE &quot;wb&quot;</span>
<a name="l02157"></a>02157 <span class="comment">     - stick the FILE&#39;s fp in xfer-&gt;dest_fp</span>
<a name="l02158"></a>02158 <span class="comment">  */</span>
<a name="l02159"></a>02159 
<a name="l02160"></a>02160   <span class="keyword">struct </span>mwFileTransfer *ft;
<a name="l02161"></a>02161   FILE *fp;
<a name="l02162"></a>02162 
<a name="l02163"></a>02163   ft = xfer-&gt;<a class="code" href="struct___purple_xfer.html#a4ce7ab5aaa647508c1eb9ba1593afeda">data</a>;
<a name="l02164"></a>02164 
<a name="l02165"></a>02165   fp = g_fopen(xfer-&gt;<a class="code" href="struct___purple_xfer.html#a243fcaa367d1829a35b9f258691c9e72">local_filename</a>, <span class="stringliteral">&quot;wb&quot;</span>);
<a name="l02166"></a>02166   <span class="keywordflow">if</span>(! fp) {
<a name="l02167"></a>02167     mwFileTransfer_cancel(ft);
<a name="l02168"></a>02168     <span class="keywordflow">return</span>;
<a name="l02169"></a>02169   }
<a name="l02170"></a>02170 
<a name="l02171"></a>02171   xfer-&gt;<a class="code" href="struct___purple_xfer.html#aa87c46142578a59330aa7fb0b74fed87">dest_fp</a> = fp;
<a name="l02172"></a>02172   mwFileTransfer_accept(ft);
<a name="l02173"></a>02173 }
<a name="l02174"></a>02174 
<a name="l02175"></a>02175 
<a name="l02176"></a>02176 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_ft_offered(<span class="keyword">struct</span> mwFileTransfer *ft) {
<a name="l02177"></a>02177   <span class="comment">/*</span>
<a name="l02178"></a>02178 <span class="comment">    - create a purple ft object</span>
<a name="l02179"></a>02179 <span class="comment">    - offer it</span>
<a name="l02180"></a>02180 <span class="comment">  */</span>
<a name="l02181"></a>02181 
<a name="l02182"></a>02182   <span class="keyword">struct </span>mwServiceFileTransfer *srvc;
<a name="l02183"></a>02183   <span class="keyword">struct </span>mwSession *session;
<a name="l02184"></a>02184   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l02185"></a>02185   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l02186"></a>02186   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l02187"></a>02187   <span class="keyword">const</span> <span class="keywordtype">char</span> *who;
<a name="l02188"></a>02188   <a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer;
<a name="l02189"></a>02189 
<a name="l02190"></a>02190   <span class="comment">/* @todo add some safety checks */</span>
<a name="l02191"></a>02191   srvc = mwFileTransfer_getService(ft);
<a name="l02192"></a>02192   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l02193"></a>02193   pd = mwSession_getClientData(session);
<a name="l02194"></a>02194   gc = pd-&gt;gc;
<a name="l02195"></a>02195   acct = purple_connection_get_account(gc);
<a name="l02196"></a>02196 
<a name="l02197"></a>02197   who = mwFileTransfer_getUser(ft)-&gt;user;
<a name="l02198"></a>02198 
<a name="l02199"></a>02199   DEBUG_INFO(<span class="stringliteral">&quot;file transfer %p offered\n&quot;</span>, ft);
<a name="l02200"></a>02200   DEBUG_INFO(<span class="stringliteral">&quot; from: %s\n&quot;</span>, NSTR(who));
<a name="l02201"></a>02201   DEBUG_INFO(<span class="stringliteral">&quot; file: %s\n&quot;</span>, NSTR(mwFileTransfer_getFileName(ft)));
<a name="l02202"></a>02202   DEBUG_INFO(<span class="stringliteral">&quot; size: %u\n&quot;</span>, mwFileTransfer_getFileSize(ft));
<a name="l02203"></a>02203   DEBUG_INFO(<span class="stringliteral">&quot; text: %s\n&quot;</span>, NSTR(mwFileTransfer_getMessage(ft)));
<a name="l02204"></a>02204 
<a name="l02205"></a>02205   xfer = purple_xfer_new(acct, <a class="code" href="ft_8h.html#a78fc08b8e8082913b7d7c92bacc12356a6758524d6aa2050ecf0f513a29f6aa05">PURPLE_XFER_RECEIVE</a>, who);
<a name="l02206"></a>02206   <span class="keywordflow">if</span> (xfer)
<a name="l02207"></a>02207   {
<a name="l02208"></a>02208         purple_xfer_ref(xfer);
<a name="l02209"></a>02209         mwFileTransfer_setClientData(ft, xfer, (GDestroyNotify) purple_xfer_unref);
<a name="l02210"></a>02210         xfer-&gt;<a class="code" href="struct___purple_xfer.html#a4ce7ab5aaa647508c1eb9ba1593afeda">data</a> = ft;
<a name="l02211"></a>02211 
<a name="l02212"></a>02212         purple_xfer_set_init_fnc(xfer, ft_incoming_init);
<a name="l02213"></a>02213         purple_xfer_set_cancel_recv_fnc(xfer, ft_incoming_cancel);
<a name="l02214"></a>02214         purple_xfer_set_request_denied_fnc(xfer, ft_incoming_cancel);
<a name="l02215"></a>02215 
<a name="l02216"></a>02216         purple_xfer_set_filename(xfer, mwFileTransfer_getFileName(ft));
<a name="l02217"></a>02217         purple_xfer_set_size(xfer, mwFileTransfer_getFileSize(ft));
<a name="l02218"></a>02218         purple_xfer_set_message(xfer, mwFileTransfer_getMessage(ft));
<a name="l02219"></a>02219 
<a name="l02220"></a>02220         purple_xfer_request(xfer);
<a name="l02221"></a>02221   }
<a name="l02222"></a>02222 }
<a name="l02223"></a>02223 
<a name="l02224"></a>02224 
<a name="l02225"></a>02225 <span class="keyword">static</span> <span class="keywordtype">void</span> ft_send(<span class="keyword">struct</span> mwFileTransfer *ft, FILE *fp) {
<a name="l02226"></a>02226   guchar buf[MW_FT_LEN];
<a name="l02227"></a>02227   <span class="keyword">struct </span>mwOpaque o = { MW_FT_LEN, buf };
<a name="l02228"></a>02228   guint32 rem;
<a name="l02229"></a>02229   <a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer;
<a name="l02230"></a>02230 
<a name="l02231"></a>02231   xfer = mwFileTransfer_getClientData(ft);
<a name="l02232"></a>02232 
<a name="l02233"></a>02233   rem = mwFileTransfer_getRemaining(ft);
<a name="l02234"></a>02234   <span class="keywordflow">if</span>(rem &lt; MW_FT_LEN) o.len = rem;
<a name="l02235"></a>02235 
<a name="l02236"></a>02236   <span class="keywordflow">if</span>(fread(buf, (<span class="keywordtype">size_t</span>) o.len, 1, fp)) {
<a name="l02237"></a>02237 
<a name="l02238"></a>02238     <span class="comment">/* calculate progress and display it */</span>
<a name="l02239"></a>02239     xfer-&gt;<a class="code" href="struct___purple_xfer.html#a1b1b52f31becd27a5f17dbb2405aa9ea">bytes_sent</a> += o.len;
<a name="l02240"></a>02240     xfer-&gt;<a class="code" href="struct___purple_xfer.html#a61d269c0addb229157cd00b75e41f1f3">bytes_remaining</a> -= o.len;
<a name="l02241"></a>02241     purple_xfer_update_progress(xfer);
<a name="l02242"></a>02242 
<a name="l02243"></a>02243     mwFileTransfer_send(ft, &amp;o);
<a name="l02244"></a>02244 
<a name="l02245"></a>02245   } <span class="keywordflow">else</span> {
<a name="l02246"></a>02246     <span class="keywordtype">int</span> err = errno;
<a name="l02247"></a>02247     DEBUG_WARN(<span class="stringliteral">&quot;problem reading from file %s: %s\n&quot;</span>,
<a name="l02248"></a>02248                NSTR(mwFileTransfer_getFileName(ft)), g_strerror(err));
<a name="l02249"></a>02249 
<a name="l02250"></a>02250     mwFileTransfer_cancel(ft);
<a name="l02251"></a>02251   }
<a name="l02252"></a>02252 }
<a name="l02253"></a>02253 
<a name="l02254"></a>02254 
<a name="l02255"></a>02255 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_ft_opened(<span class="keyword">struct</span> mwFileTransfer *ft) {
<a name="l02256"></a>02256   <span class="comment">/*</span>
<a name="l02257"></a>02257 <span class="comment">    - get purple ft from client data in ft</span>
<a name="l02258"></a>02258 <span class="comment">    - set the state to active</span>
<a name="l02259"></a>02259 <span class="comment">  */</span>
<a name="l02260"></a>02260 
<a name="l02261"></a>02261   <a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer;
<a name="l02262"></a>02262 
<a name="l02263"></a>02263   xfer = mwFileTransfer_getClientData(ft);
<a name="l02264"></a>02264 
<a name="l02265"></a>02265   <span class="keywordflow">if</span>(! xfer) {
<a name="l02266"></a>02266     mwFileTransfer_cancel(ft);
<a name="l02267"></a>02267     mwFileTransfer_free(ft);
<a name="l02268"></a>02268     g_return_if_reached();
<a name="l02269"></a>02269   }
<a name="l02270"></a>02270 
<a name="l02271"></a>02271   <span class="keywordflow">if</span>(purple_xfer_get_type(xfer) == <a class="code" href="ft_8h.html#a78fc08b8e8082913b7d7c92bacc12356ac52c4c9694591c04ad151e913a716f9a">PURPLE_XFER_SEND</a>) {
<a name="l02272"></a>02272     xfer-&gt;<a class="code" href="struct___purple_xfer.html#aa87c46142578a59330aa7fb0b74fed87">dest_fp</a> = g_fopen(xfer-&gt;<a class="code" href="struct___purple_xfer.html#a243fcaa367d1829a35b9f258691c9e72">local_filename</a>, <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l02273"></a>02273     ft_send(ft, xfer-&gt;<a class="code" href="struct___purple_xfer.html#aa87c46142578a59330aa7fb0b74fed87">dest_fp</a>);
<a name="l02274"></a>02274   }
<a name="l02275"></a>02275 }
<a name="l02276"></a>02276 
<a name="l02277"></a>02277 
<a name="l02278"></a>02278 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_ft_closed(<span class="keyword">struct</span> mwFileTransfer *ft, guint32 code) {
<a name="l02279"></a>02279   <span class="comment">/*</span>
<a name="l02280"></a>02280 <span class="comment">    - get purple ft from client data in ft</span>
<a name="l02281"></a>02281 <span class="comment">    - indicate rejection/cancelation/completion</span>
<a name="l02282"></a>02282 <span class="comment">    - free the file transfer itself</span>
<a name="l02283"></a>02283 <span class="comment">  */</span>
<a name="l02284"></a>02284 
<a name="l02285"></a>02285   <a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer;
<a name="l02286"></a>02286 
<a name="l02287"></a>02287   xfer = mwFileTransfer_getClientData(ft);
<a name="l02288"></a>02288   <span class="keywordflow">if</span>(xfer) {
<a name="l02289"></a>02289     xfer-&gt;<a class="code" href="struct___purple_xfer.html#a4ce7ab5aaa647508c1eb9ba1593afeda">data</a> = NULL;
<a name="l02290"></a>02290 
<a name="l02291"></a>02291     <span class="keywordflow">if</span>(! mwFileTransfer_getRemaining(ft)) {
<a name="l02292"></a>02292       purple_xfer_set_completed(xfer, TRUE);
<a name="l02293"></a>02293       purple_xfer_end(xfer);
<a name="l02294"></a>02294 
<a name="l02295"></a>02295     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(mwFileTransfer_isCancelLocal(ft)) {
<a name="l02296"></a>02296       <span class="comment">/* calling purple_xfer_cancel_local is redundant, since that&#39;s</span>
<a name="l02297"></a>02297 <span class="comment">         probably what triggered this function to be called */</span>
<a name="l02298"></a>02298       ;
<a name="l02299"></a>02299 
<a name="l02300"></a>02300     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(mwFileTransfer_isCancelRemote(ft)) {
<a name="l02301"></a>02301       <span class="comment">/* steal the reference for the xfer */</span>
<a name="l02302"></a>02302       mwFileTransfer_setClientData(ft, NULL, NULL);
<a name="l02303"></a>02303       purple_xfer_cancel_remote(xfer);
<a name="l02304"></a>02304 
<a name="l02305"></a>02305       <span class="comment">/* drop the stolen reference */</span>
<a name="l02306"></a>02306       purple_xfer_unref(xfer);
<a name="l02307"></a>02307       <span class="keywordflow">return</span>;
<a name="l02308"></a>02308     }
<a name="l02309"></a>02309   }
<a name="l02310"></a>02310 
<a name="l02311"></a>02311   mwFileTransfer_free(ft);
<a name="l02312"></a>02312 }
<a name="l02313"></a>02313 
<a name="l02314"></a>02314 
<a name="l02315"></a>02315 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_ft_recv(<span class="keyword">struct</span> mwFileTransfer *ft,
<a name="l02316"></a>02316                        <span class="keyword">struct</span> mwOpaque *data) {
<a name="l02317"></a>02317   <span class="comment">/*</span>
<a name="l02318"></a>02318 <span class="comment">    - get purple ft from client data in ft</span>
<a name="l02319"></a>02319 <span class="comment">    - update transfered percentage</span>
<a name="l02320"></a>02320 <span class="comment">    - if done, destroy the ft, disassociate from purple ft</span>
<a name="l02321"></a>02321 <span class="comment">  */</span>
<a name="l02322"></a>02322 
<a name="l02323"></a>02323   <a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer;
<a name="l02324"></a>02324   FILE *fp;
<a name="l02325"></a>02325   <span class="keywordtype">size_t</span> wc;
<a name="l02326"></a>02326 
<a name="l02327"></a>02327   xfer = mwFileTransfer_getClientData(ft);
<a name="l02328"></a>02328   g_return_if_fail(xfer != NULL);
<a name="l02329"></a>02329 
<a name="l02330"></a>02330   fp = xfer-&gt;<a class="code" href="struct___purple_xfer.html#aa87c46142578a59330aa7fb0b74fed87">dest_fp</a>;
<a name="l02331"></a>02331   g_return_if_fail(fp != NULL);
<a name="l02332"></a>02332 
<a name="l02333"></a>02333   <span class="comment">/* we must collect and save our precious data */</span>
<a name="l02334"></a>02334   wc = fwrite(data-&gt;data, 1, data-&gt;len, fp);
<a name="l02335"></a>02335   <span class="keywordflow">if</span> (wc != data-&gt;len) {
<a name="l02336"></a>02336     DEBUG_ERROR(<span class="stringliteral">&quot;failed to write data\n&quot;</span>);
<a name="l02337"></a>02337     purple_xfer_cancel_local(xfer);
<a name="l02338"></a>02338     <span class="keywordflow">return</span>;
<a name="l02339"></a>02339   }
<a name="l02340"></a>02340 
<a name="l02341"></a>02341   <span class="comment">/* update the progress */</span>
<a name="l02342"></a>02342   xfer-&gt;<a class="code" href="struct___purple_xfer.html#a1b1b52f31becd27a5f17dbb2405aa9ea">bytes_sent</a> += data-&gt;len;
<a name="l02343"></a>02343   xfer-&gt;<a class="code" href="struct___purple_xfer.html#a61d269c0addb229157cd00b75e41f1f3">bytes_remaining</a> -= data-&gt;len;
<a name="l02344"></a>02344   purple_xfer_update_progress(xfer);
<a name="l02345"></a>02345 
<a name="l02346"></a>02346   <span class="comment">/* let the other side know we got it, and to send some more */</span>
<a name="l02347"></a>02347   mwFileTransfer_ack(ft);
<a name="l02348"></a>02348 }
<a name="l02349"></a>02349 
<a name="l02350"></a>02350 
<a name="l02351"></a>02351 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_ft_ack(<span class="keyword">struct</span> mwFileTransfer *ft) {
<a name="l02352"></a>02352   <a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer;
<a name="l02353"></a>02353 
<a name="l02354"></a>02354   xfer = mwFileTransfer_getClientData(ft);
<a name="l02355"></a>02355   g_return_if_fail(xfer != NULL);
<a name="l02356"></a>02356   g_return_if_fail(xfer-&gt;<a class="code" href="struct___purple_xfer.html#a8894998ed016398069c8db0f8d9028a8">watcher</a> == 0);
<a name="l02357"></a>02357 
<a name="l02358"></a>02358   <span class="keywordflow">if</span>(! mwFileTransfer_getRemaining(ft)) {
<a name="l02359"></a>02359     purple_xfer_set_completed(xfer, TRUE);
<a name="l02360"></a>02360     purple_xfer_end(xfer);
<a name="l02361"></a>02361 
<a name="l02362"></a>02362   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(mwFileTransfer_isOpen(ft)) {
<a name="l02363"></a>02363     ft_send(ft, xfer-&gt;<a class="code" href="struct___purple_xfer.html#aa87c46142578a59330aa7fb0b74fed87">dest_fp</a>);
<a name="l02364"></a>02364   }
<a name="l02365"></a>02365 }
<a name="l02366"></a>02366 
<a name="l02367"></a>02367 
<a name="l02368"></a>02368 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_ft_clear(<span class="keyword">struct</span> mwServiceFileTransfer *srvc) {
<a name="l02369"></a>02369   ;
<a name="l02370"></a>02370 }
<a name="l02371"></a>02371 
<a name="l02372"></a>02372 
<a name="l02373"></a>02373 <span class="keyword">static</span> <span class="keyword">struct </span>mwFileTransferHandler mw_ft_handler = {
<a name="l02374"></a>02374   mw_ft_offered,
<a name="l02375"></a>02375   mw_ft_opened,
<a name="l02376"></a>02376   mw_ft_closed,
<a name="l02377"></a>02377   mw_ft_recv,
<a name="l02378"></a>02378   mw_ft_ack,
<a name="l02379"></a>02379   mw_ft_clear,
<a name="l02380"></a>02380 };
<a name="l02381"></a>02381 
<a name="l02382"></a>02382 
<a name="l02383"></a>02383 <span class="keyword">static</span> <span class="keyword">struct </span>mwServiceFileTransfer *mw_srvc_ft_new(<span class="keyword">struct</span> mwSession *s) {
<a name="l02384"></a>02384   <span class="keyword">struct </span>mwServiceFileTransfer *srvc;
<a name="l02385"></a>02385   GHashTable *ft_map;
<a name="l02386"></a>02386 
<a name="l02387"></a>02387   ft_map = g_hash_table_new(g_direct_hash, g_direct_equal);
<a name="l02388"></a>02388 
<a name="l02389"></a>02389   srvc = mwServiceFileTransfer_new(s, &amp;mw_ft_handler);
<a name="l02390"></a>02390   mwService_setClientData(MW_SERVICE(srvc), ft_map,
<a name="l02391"></a>02391                           (GDestroyNotify) g_hash_table_destroy);
<a name="l02392"></a>02392 
<a name="l02393"></a>02393   <span class="keywordflow">return</span> srvc;
<a name="l02394"></a>02394 }
<a name="l02395"></a>02395 
<a name="l02396"></a>02396 
<a name="l02397"></a>02397 <span class="keyword">static</span> <span class="keywordtype">void</span> convo_data_free(<span class="keyword">struct</span> <a class="code" href="structconvo__data.html">convo_data</a> *cd) {
<a name="l02398"></a>02398   GList *l;
<a name="l02399"></a>02399 
<a name="l02400"></a>02400   <span class="comment">/* clean the queue */</span>
<a name="l02401"></a>02401   <span class="keywordflow">for</span>(l = cd-&gt;<a class="code" href="structconvo__data.html#ad03c8a7f666aca2c5385d1526e5a292f">queue</a>; l; l = g_list_delete_link(l, l)) {
<a name="l02402"></a>02402     <span class="keyword">struct </span><a class="code" href="structconvo__msg.html">convo_msg</a> *m = l-&gt;data;
<a name="l02403"></a>02403     <span class="keywordflow">if</span>(m-&gt;clear) m-&gt;clear(m-&gt;data);
<a name="l02404"></a>02404     g_free(m);
<a name="l02405"></a>02405   }
<a name="l02406"></a>02406 
<a name="l02407"></a>02407   g_free(cd);
<a name="l02408"></a>02408 }
<a name="l02409"></a>02409 
<a name="l02410"></a>02410 
<a name="l02413"></a>02413 <span class="keyword">static</span> <span class="keywordtype">void</span> convo_data_new(<span class="keyword">struct</span> mwConversation *conv) {
<a name="l02414"></a>02414   <span class="keyword">struct </span><a class="code" href="structconvo__data.html">convo_data</a> *cd;
<a name="l02415"></a>02415 
<a name="l02416"></a>02416   g_return_if_fail(conv != NULL);
<a name="l02417"></a>02417 
<a name="l02418"></a>02418   <span class="keywordflow">if</span>(mwConversation_getClientData(conv))
<a name="l02419"></a>02419     <span class="keywordflow">return</span>;
<a name="l02420"></a>02420 
<a name="l02421"></a>02421   cd = g_new0(<span class="keyword">struct</span> <a class="code" href="structconvo__data.html">convo_data</a>, 1);
<a name="l02422"></a>02422   cd-&gt;conv = conv;
<a name="l02423"></a>02423 
<a name="l02424"></a>02424   mwConversation_setClientData(conv, cd, (GDestroyNotify) convo_data_free);
<a name="l02425"></a>02425 }
<a name="l02426"></a>02426 
<a name="l02427"></a>02427 
<a name="l02428"></a>02428 <span class="keyword">static</span> <a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *convo_get_gconv(<span class="keyword">struct</span> mwConversation *conv) {
<a name="l02429"></a>02429   <span class="keyword">struct </span>mwServiceIm *srvc;
<a name="l02430"></a>02430   <span class="keyword">struct </span>mwSession *session;
<a name="l02431"></a>02431   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l02432"></a>02432   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l02433"></a>02433   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l02434"></a>02434 
<a name="l02435"></a>02435   <span class="keyword">struct </span>mwIdBlock *idb;
<a name="l02436"></a>02436 
<a name="l02437"></a>02437   srvc = mwConversation_getService(conv);
<a name="l02438"></a>02438   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l02439"></a>02439   pd = mwSession_getClientData(session);
<a name="l02440"></a>02440   gc = pd-&gt;gc;
<a name="l02441"></a>02441   acct = purple_connection_get_account(gc);
<a name="l02442"></a>02442 
<a name="l02443"></a>02443   idb = mwConversation_getTarget(conv);
<a name="l02444"></a>02444 
<a name="l02445"></a>02445   <span class="keywordflow">return</span> purple_find_conversation_with_account(<a class="code" href="conversation_8h.html#a9e9f3ae232444332eb34f16aef64f721a4e1c3df052e10fb1b3789ce5925496ab">PURPLE_CONV_TYPE_IM</a>,
<a name="l02446"></a>02446                                              idb-&gt;user, acct);
<a name="l02447"></a>02447 }
<a name="l02448"></a>02448 
<a name="l02449"></a>02449 
<a name="l02450"></a>02450 <span class="keyword">static</span> <span class="keywordtype">void</span> convo_queue(<span class="keyword">struct</span> mwConversation *conv,
<a name="l02451"></a>02451                         <span class="keyword">enum</span> mwImSendType type, gconstpointer data) {
<a name="l02452"></a>02452 
<a name="l02453"></a>02453   <span class="keyword">struct </span><a class="code" href="structconvo__data.html">convo_data</a> *cd;
<a name="l02454"></a>02454   <span class="keyword">struct </span><a class="code" href="structconvo__msg.html">convo_msg</a> *m;
<a name="l02455"></a>02455 
<a name="l02456"></a>02456   convo_data_new(conv);
<a name="l02457"></a>02457   cd = mwConversation_getClientData(conv);
<a name="l02458"></a>02458 
<a name="l02459"></a>02459   m = g_new0(<span class="keyword">struct</span> <a class="code" href="structconvo__msg.html">convo_msg</a>, 1);
<a name="l02460"></a>02460   m-&gt;type = type;
<a name="l02461"></a>02461 
<a name="l02462"></a>02462   <span class="keywordflow">switch</span>(type) {
<a name="l02463"></a>02463   <span class="keywordflow">case</span> mwImSend_PLAIN:
<a name="l02464"></a>02464     m-&gt;data = g_strdup(data);
<a name="l02465"></a>02465     m-&gt;clear = g_free;
<a name="l02466"></a>02466     <span class="keywordflow">break</span>;
<a name="l02467"></a>02467 
<a name="l02468"></a>02468   <span class="keywordflow">case</span> mwImSend_TYPING:
<a name="l02469"></a>02469   <span class="keywordflow">default</span>:
<a name="l02470"></a>02470     m-&gt;data = (gpointer) data;
<a name="l02471"></a>02471     m-&gt;clear = NULL;
<a name="l02472"></a>02472   }
<a name="l02473"></a>02473 
<a name="l02474"></a>02474   cd-&gt;<a class="code" href="structconvo__data.html#ad03c8a7f666aca2c5385d1526e5a292f">queue</a> = g_list_append(cd-&gt;<a class="code" href="structconvo__data.html#ad03c8a7f666aca2c5385d1526e5a292f">queue</a>, m);
<a name="l02475"></a>02475 }
<a name="l02476"></a>02476 
<a name="l02477"></a>02477 
<a name="l02478"></a>02478 <span class="comment">/* Does what it takes to get an error displayed for a conversation */</span>
<a name="l02479"></a>02479 <span class="keyword">static</span> <span class="keywordtype">void</span> convo_error(<span class="keyword">struct</span> mwConversation *conv, guint32 err) {
<a name="l02480"></a>02480   <a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *gconv;
<a name="l02481"></a>02481   <span class="keywordtype">char</span> *tmp, *text;
<a name="l02482"></a>02482   <span class="keyword">struct </span>mwIdBlock *idb;
<a name="l02483"></a>02483 
<a name="l02484"></a>02484   idb = mwConversation_getTarget(conv);
<a name="l02485"></a>02485 
<a name="l02486"></a>02486   tmp = mwError(err);
<a name="l02487"></a>02487   text = g_strconcat(_(<span class="stringliteral">&quot;Unable to send message: &quot;</span>), tmp, NULL);
<a name="l02488"></a>02488 
<a name="l02489"></a>02489   gconv = convo_get_gconv(conv);
<a name="l02490"></a>02490   <span class="keywordflow">if</span>(gconv &amp;&amp; !purple_conv_present_error(idb-&gt;user, gconv-&gt;<a class="code" href="struct___purple_conversation.html#a4f7f0a040c413b3829157d0d6559feaf">account</a>, text)) {
<a name="l02491"></a>02491 
<a name="l02492"></a>02492     g_free(text);
<a name="l02493"></a>02493     text = g_strdup_printf(_(<span class="stringliteral">&quot;Unable to send message to %s:&quot;</span>),
<a name="l02494"></a>02494                            (idb-&gt;user)? idb-&gt;user: <span class="stringliteral">&quot;(unknown)&quot;</span>);
<a name="l02495"></a>02495     <a class="code" href="notify_8h.html#ad54861c382f50702e2c6c2317aff878d">purple_notify_error</a>(purple_account_get_connection(gconv-&gt;<a class="code" href="struct___purple_conversation.html#a4f7f0a040c413b3829157d0d6559feaf">account</a>),
<a name="l02496"></a>02496                       NULL, text, tmp);
<a name="l02497"></a>02497   }
<a name="l02498"></a>02498 
<a name="l02499"></a>02499   g_free(tmp);
<a name="l02500"></a>02500   g_free(text);
<a name="l02501"></a>02501 }
<a name="l02502"></a>02502 
<a name="l02503"></a>02503 
<a name="l02504"></a>02504 <span class="keyword">static</span> <span class="keywordtype">void</span> convo_queue_send(<span class="keyword">struct</span> mwConversation *conv) {
<a name="l02505"></a>02505   <span class="keyword">struct </span><a class="code" href="structconvo__data.html">convo_data</a> *cd;
<a name="l02506"></a>02506   GList *l;
<a name="l02507"></a>02507 
<a name="l02508"></a>02508   cd = mwConversation_getClientData(conv);
<a name="l02509"></a>02509 
<a name="l02510"></a>02510   <span class="keywordflow">for</span>(l = cd-&gt;<a class="code" href="structconvo__data.html#ad03c8a7f666aca2c5385d1526e5a292f">queue</a>; l; l = g_list_delete_link(l, l)) {
<a name="l02511"></a>02511     <span class="keyword">struct </span><a class="code" href="structconvo__msg.html">convo_msg</a> *m = l-&gt;data;
<a name="l02512"></a>02512 
<a name="l02513"></a>02513     mwConversation_send(conv, m-&gt;type, m-&gt;data);
<a name="l02514"></a>02514 
<a name="l02515"></a>02515     <span class="keywordflow">if</span>(m-&gt;clear) m-&gt;clear(m-&gt;data);
<a name="l02516"></a>02516     g_free(m);
<a name="l02517"></a>02517   }
<a name="l02518"></a>02518 
<a name="l02519"></a>02519   cd-&gt;<a class="code" href="structconvo__data.html#ad03c8a7f666aca2c5385d1526e5a292f">queue</a> = NULL;
<a name="l02520"></a>02520 }
<a name="l02521"></a>02521 
<a name="l02522"></a>02522 
<a name="l02526"></a>02526 <span class="keyword">static</span> <span class="keywordtype">void</span> convo_nofeatures(<span class="keyword">struct</span> mwConversation *conv) {
<a name="l02527"></a>02527   <a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *gconv;
<a name="l02528"></a>02528   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l02529"></a>02529 
<a name="l02530"></a>02530   gconv = convo_get_gconv(conv);
<a name="l02531"></a>02531   <span class="keywordflow">if</span>(! gconv) <span class="keywordflow">return</span>;
<a name="l02532"></a>02532 
<a name="l02533"></a>02533   gc = purple_conversation_get_gc(gconv);
<a name="l02534"></a>02534   <span class="keywordflow">if</span>(! gc) <span class="keywordflow">return</span>;
<a name="l02535"></a>02535 
<a name="l02536"></a>02536   purple_conversation_set_features(gconv, gc-&gt;<a class="code" href="struct___purple_connection.html#a9164f327f3728939f0177bf92cc3d259">flags</a>);
<a name="l02537"></a>02537 }
<a name="l02538"></a>02538 
<a name="l02539"></a>02539 
<a name="l02543"></a>02543 <span class="keyword">static</span> <span class="keywordtype">void</span> convo_features(<span class="keyword">struct</span> mwConversation *conv) {
<a name="l02544"></a>02544   <a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *gconv;
<a name="l02545"></a>02545   <a class="code" href="connection_8h.html#a5073f95bd10eb9eed84fa58cbf1bb162">PurpleConnectionFlags</a> feat;
<a name="l02546"></a>02546 
<a name="l02547"></a>02547   gconv = convo_get_gconv(conv);
<a name="l02548"></a>02548   <span class="keywordflow">if</span>(! gconv) <span class="keywordflow">return</span>;
<a name="l02549"></a>02549 
<a name="l02550"></a>02550   feat = purple_conversation_get_features(gconv);
<a name="l02551"></a>02551 
<a name="l02552"></a>02552   <span class="keywordflow">if</span>(mwConversation_isOpen(conv)) {
<a name="l02553"></a>02553     <span class="keywordflow">if</span>(mwConversation_supports(conv, mwImSend_HTML)) {
<a name="l02554"></a>02554       feat |= <a class="code" href="connection_8h.html#a5073f95bd10eb9eed84fa58cbf1bb162a93b3e0b7e291b0516ee4e8057f874f48">PURPLE_CONNECTION_HTML</a>;
<a name="l02555"></a>02555     } <span class="keywordflow">else</span> {
<a name="l02556"></a>02556       feat &amp;= ~<a class="code" href="connection_8h.html#a5073f95bd10eb9eed84fa58cbf1bb162a93b3e0b7e291b0516ee4e8057f874f48">PURPLE_CONNECTION_HTML</a>;
<a name="l02557"></a>02557     }
<a name="l02558"></a>02558 
<a name="l02559"></a>02559     <span class="keywordflow">if</span>(mwConversation_supports(conv, mwImSend_MIME)) {
<a name="l02560"></a>02560       feat &amp;= ~<a class="code" href="connection_8h.html#a5073f95bd10eb9eed84fa58cbf1bb162a41a69a0d47739f58f9f57cfe0cd0117e">PURPLE_CONNECTION_NO_IMAGES</a>;
<a name="l02561"></a>02561     } <span class="keywordflow">else</span> {
<a name="l02562"></a>02562       feat |= <a class="code" href="connection_8h.html#a5073f95bd10eb9eed84fa58cbf1bb162a41a69a0d47739f58f9f57cfe0cd0117e">PURPLE_CONNECTION_NO_IMAGES</a>;
<a name="l02563"></a>02563     }
<a name="l02564"></a>02564 
<a name="l02565"></a>02565     DEBUG_INFO(<span class="stringliteral">&quot;conversation features set to 0x%04x\n&quot;</span>, feat);
<a name="l02566"></a>02566     purple_conversation_set_features(gconv, feat);
<a name="l02567"></a>02567 
<a name="l02568"></a>02568   } <span class="keywordflow">else</span> {
<a name="l02569"></a>02569     convo_nofeatures(conv);
<a name="l02570"></a>02570   }
<a name="l02571"></a>02571 }
<a name="l02572"></a>02572 
<a name="l02573"></a>02573 
<a name="l02574"></a>02574 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_conversation_opened(<span class="keyword">struct</span> mwConversation *conv) {
<a name="l02575"></a>02575   <span class="keyword">struct </span>mwServiceIm *srvc;
<a name="l02576"></a>02576   <span class="keyword">struct </span>mwSession *session;
<a name="l02577"></a>02577   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l02578"></a>02578   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l02579"></a>02579   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l02580"></a>02580 
<a name="l02581"></a>02581   <span class="keyword">struct </span>convo_dat *cd;
<a name="l02582"></a>02582 
<a name="l02583"></a>02583   srvc = mwConversation_getService(conv);
<a name="l02584"></a>02584   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l02585"></a>02585   pd = mwSession_getClientData(session);
<a name="l02586"></a>02586   gc = pd-&gt;gc;
<a name="l02587"></a>02587   acct = purple_connection_get_account(gc);
<a name="l02588"></a>02588 
<a name="l02589"></a>02589   <span class="comment">/* set up the queue */</span>
<a name="l02590"></a>02590   cd = mwConversation_getClientData(conv);
<a name="l02591"></a>02591   <span class="keywordflow">if</span>(cd) {
<a name="l02592"></a>02592     convo_queue_send(conv);
<a name="l02593"></a>02593 
<a name="l02594"></a>02594     <span class="keywordflow">if</span>(! convo_get_gconv(conv)) {
<a name="l02595"></a>02595       mwConversation_free(conv);
<a name="l02596"></a>02596       <span class="keywordflow">return</span>;
<a name="l02597"></a>02597     }
<a name="l02598"></a>02598 
<a name="l02599"></a>02599   } <span class="keywordflow">else</span> {
<a name="l02600"></a>02600     convo_data_new(conv);
<a name="l02601"></a>02601   }
<a name="l02602"></a>02602 
<a name="l02603"></a>02603   { <span class="comment">/* record the client key for the buddy */</span>
<a name="l02604"></a>02604     <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy;
<a name="l02605"></a>02605     <span class="keyword">struct </span>mwLoginInfo *info;
<a name="l02606"></a>02606     info = mwConversation_getTargetInfo(conv);
<a name="l02607"></a>02607 
<a name="l02608"></a>02608     buddy = purple_find_buddy(acct, info-&gt;user_id);
<a name="l02609"></a>02609     <span class="keywordflow">if</span>(buddy) {
<a name="l02610"></a>02610       purple_blist_node_set_int((<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) buddy,
<a name="l02611"></a>02611                               BUDDY_KEY_CLIENT, info-&gt;type);
<a name="l02612"></a>02612     }
<a name="l02613"></a>02613   }
<a name="l02614"></a>02614 
<a name="l02615"></a>02615   convo_features(conv);
<a name="l02616"></a>02616 }
<a name="l02617"></a>02617 
<a name="l02618"></a>02618 
<a name="l02619"></a>02619 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_conversation_closed(<span class="keyword">struct</span> mwConversation *conv,
<a name="l02620"></a>02620                                    guint32 reason) {
<a name="l02621"></a>02621 
<a name="l02622"></a>02622   <span class="keyword">struct </span><a class="code" href="structconvo__data.html">convo_data</a> *cd;
<a name="l02623"></a>02623 
<a name="l02624"></a>02624   g_return_if_fail(conv != NULL);
<a name="l02625"></a>02625 
<a name="l02626"></a>02626   <span class="comment">/* if there&#39;s an error code and a non-typing message in the queue,</span>
<a name="l02627"></a>02627 <span class="comment">     print an error message to the conversation */</span>
<a name="l02628"></a>02628   cd = mwConversation_getClientData(conv);
<a name="l02629"></a>02629   <span class="keywordflow">if</span>(reason &amp;&amp; cd &amp;&amp; cd-&gt;<a class="code" href="structconvo__data.html#ad03c8a7f666aca2c5385d1526e5a292f">queue</a>) {
<a name="l02630"></a>02630     GList *l;
<a name="l02631"></a>02631     <span class="keywordflow">for</span>(l = cd-&gt;<a class="code" href="structconvo__data.html#ad03c8a7f666aca2c5385d1526e5a292f">queue</a>; l; l = l-&gt;next) {
<a name="l02632"></a>02632       <span class="keyword">struct </span><a class="code" href="structconvo__msg.html">convo_msg</a> *m = l-&gt;data;
<a name="l02633"></a>02633       <span class="keywordflow">if</span>(m-&gt;type != mwImSend_TYPING) {
<a name="l02634"></a>02634         convo_error(conv, reason);
<a name="l02635"></a>02635         <span class="keywordflow">break</span>;
<a name="l02636"></a>02636       }
<a name="l02637"></a>02637     }
<a name="l02638"></a>02638   }
<a name="l02639"></a>02639 
<a name="l02640"></a>02640 <span class="preprocessor">#if 0</span>
<a name="l02641"></a>02641 <span class="preprocessor"></span>  <span class="comment">/* don&#39;t do this, to prevent the occasional weird sending of</span>
<a name="l02642"></a>02642 <span class="comment">     formatted messages as plaintext when the other end closes the</span>
<a name="l02643"></a>02643 <span class="comment">     conversation after we&#39;ve begun composing the message */</span>
<a name="l02644"></a>02644   convo_nofeatures(conv);
<a name="l02645"></a>02645 <span class="preprocessor">#endif</span>
<a name="l02646"></a>02646 <span class="preprocessor"></span>
<a name="l02647"></a>02647   mwConversation_removeClientData(conv);
<a name="l02648"></a>02648 }
<a name="l02649"></a>02649 
<a name="l02650"></a>02650 
<a name="l02651"></a>02651 <span class="keyword">static</span> <span class="keywordtype">void</span> im_recv_text(<span class="keyword">struct</span> mwConversation *conv,
<a name="l02652"></a>02652                          <span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd,
<a name="l02653"></a>02653                          <span class="keyword">const</span> <span class="keywordtype">char</span> *msg) {
<a name="l02654"></a>02654 
<a name="l02655"></a>02655   <span class="keyword">struct </span>mwIdBlock *idb;
<a name="l02656"></a>02656   <span class="keywordtype">char</span> *txt, *esc;
<a name="l02657"></a>02657   <span class="keyword">const</span> <span class="keywordtype">char</span> *t;
<a name="l02658"></a>02658 
<a name="l02659"></a>02659   idb = mwConversation_getTarget(conv);
<a name="l02660"></a>02660 
<a name="l02661"></a>02661   txt = purple_utf8_try_convert(msg);
<a name="l02662"></a>02662   t = txt? txt: msg;
<a name="l02663"></a>02663 
<a name="l02664"></a>02664   esc = g_markup_escape_text(t, -1);
<a name="l02665"></a>02665   serv_got_im(pd-&gt;gc, idb-&gt;user, esc, 0, time(NULL));
<a name="l02666"></a>02666   g_free(esc);
<a name="l02667"></a>02667 
<a name="l02668"></a>02668   g_free(txt);
<a name="l02669"></a>02669 }
<a name="l02670"></a>02670 
<a name="l02671"></a>02671 
<a name="l02672"></a>02672 <span class="keyword">static</span> <span class="keywordtype">void</span> im_recv_typing(<span class="keyword">struct</span> mwConversation *conv,
<a name="l02673"></a>02673                            <span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd,
<a name="l02674"></a>02674                            gboolean typing) {
<a name="l02675"></a>02675 
<a name="l02676"></a>02676   <span class="keyword">struct </span>mwIdBlock *idb;
<a name="l02677"></a>02677   idb = mwConversation_getTarget(conv);
<a name="l02678"></a>02678 
<a name="l02679"></a>02679   serv_got_typing(pd-&gt;gc, idb-&gt;user, 0,
<a name="l02680"></a>02680                   typing? <a class="code" href="conversation_8h.html#a044cde1e74c50154fefcd358c723850aa998088bd59e5db26328d0c3b901b9ed0">PURPLE_TYPING</a>: <a class="code" href="conversation_8h.html#a044cde1e74c50154fefcd358c723850aa1cbce8c39824fe2edb18c37fcce78b5f">PURPLE_NOT_TYPING</a>);
<a name="l02681"></a>02681 }
<a name="l02682"></a>02682 
<a name="l02683"></a>02683 
<a name="l02684"></a>02684 <span class="keyword">static</span> <span class="keywordtype">void</span> im_recv_html(<span class="keyword">struct</span> mwConversation *conv,
<a name="l02685"></a>02685                          <span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd,
<a name="l02686"></a>02686                          <span class="keyword">const</span> <span class="keywordtype">char</span> *msg) {
<a name="l02687"></a>02687   <span class="keyword">struct </span>mwIdBlock *idb;
<a name="l02688"></a>02688   <span class="keywordtype">char</span> *t1, *t2;
<a name="l02689"></a>02689   <span class="keyword">const</span> <span class="keywordtype">char</span> *t;
<a name="l02690"></a>02690 
<a name="l02691"></a>02691   idb = mwConversation_getTarget(conv);
<a name="l02692"></a>02692 
<a name="l02693"></a>02693   <span class="comment">/* ensure we&#39;re receiving UTF8 */</span>
<a name="l02694"></a>02694   t1 = purple_utf8_try_convert(msg);
<a name="l02695"></a>02695   t = t1? t1: msg;
<a name="l02696"></a>02696 
<a name="l02697"></a>02697   <span class="comment">/* convert entities to UTF8 so they&#39;ll log correctly */</span>
<a name="l02698"></a>02698   t2 = purple_utf8_ncr_decode(t);
<a name="l02699"></a>02699   t = t2? t2: t;
<a name="l02700"></a>02700 
<a name="l02701"></a>02701   serv_got_im(pd-&gt;gc, idb-&gt;user, t, 0, time(NULL));
<a name="l02702"></a>02702 
<a name="l02703"></a>02703   g_free(t1);
<a name="l02704"></a>02704   g_free(t2);
<a name="l02705"></a>02705 }
<a name="l02706"></a>02706 
<a name="l02707"></a>02707 
<a name="l02708"></a>02708 <span class="keyword">static</span> <span class="keywordtype">void</span> im_recv_subj(<span class="keyword">struct</span> mwConversation *conv,
<a name="l02709"></a>02709                          <span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd,
<a name="l02710"></a>02710                          <span class="keyword">const</span> <span class="keywordtype">char</span> *subj) {
<a name="l02711"></a>02711 
<a name="l02715"></a>02715   ;
<a name="l02716"></a>02716 }
<a name="l02717"></a>02717 
<a name="l02718"></a>02718 
<a name="l02720"></a>02720 <span class="keyword">static</span> <span class="keywordtype">char</span> *make_cid(<span class="keyword">const</span> <span class="keywordtype">char</span> *cid) {
<a name="l02721"></a>02721   gsize n;
<a name="l02722"></a>02722   <span class="keywordtype">char</span> *c, *d;
<a name="l02723"></a>02723 
<a name="l02724"></a>02724   g_return_val_if_fail(cid != NULL, NULL);
<a name="l02725"></a>02725 
<a name="l02726"></a>02726   n = strlen(cid);
<a name="l02727"></a>02727   g_return_val_if_fail(n &gt; 2, NULL);
<a name="l02728"></a>02728 
<a name="l02729"></a>02729   c = g_strndup(cid+1, n-2);
<a name="l02730"></a>02730   d = g_strdup_printf(<span class="stringliteral">&quot;cid:%s&quot;</span>, c);
<a name="l02731"></a>02731 
<a name="l02732"></a>02732   g_free(c);
<a name="l02733"></a>02733   <span class="keywordflow">return</span> d;
<a name="l02734"></a>02734 }
<a name="l02735"></a>02735 
<a name="l02736"></a>02736 
<a name="l02737"></a>02737 <span class="keyword">static</span> <span class="keywordtype">void</span> im_recv_mime(<span class="keyword">struct</span> mwConversation *conv,
<a name="l02738"></a>02738                          <span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd,
<a name="l02739"></a>02739                          <span class="keyword">const</span> <span class="keywordtype">char</span> *data) {
<a name="l02740"></a>02740 
<a name="l02741"></a>02741   GHashTable *img_by_cid;
<a name="l02742"></a>02742   GList *images;
<a name="l02743"></a>02743 
<a name="l02744"></a>02744   GString *str;
<a name="l02745"></a>02745 
<a name="l02746"></a>02746   <a class="code" href="struct___purple_mime_document.html">PurpleMimeDocument</a> *doc;
<a name="l02747"></a>02747   GList *parts;
<a name="l02748"></a>02748 
<a name="l02749"></a>02749   img_by_cid = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
<a name="l02750"></a>02750   images = NULL;
<a name="l02751"></a>02751 
<a name="l02752"></a>02752   <span class="comment">/* don&#39;t want the contained string to ever be NULL */</span>
<a name="l02753"></a>02753   str = g_string_new(<span class="stringliteral">&quot;&quot;</span>);
<a name="l02754"></a>02754 
<a name="l02755"></a>02755   doc = purple_mime_document_parse(data);
<a name="l02756"></a>02756 
<a name="l02757"></a>02757   <span class="comment">/* handle all the MIME parts */</span>
<a name="l02758"></a>02758   parts = purple_mime_document_get_parts(doc);
<a name="l02759"></a>02759   <span class="keywordflow">for</span>(; parts; parts = parts-&gt;next) {
<a name="l02760"></a>02760     <a class="code" href="struct___purple_mime_part.html">PurpleMimePart</a> *part = parts-&gt;data;
<a name="l02761"></a>02761     <span class="keyword">const</span> <span class="keywordtype">char</span> *type;
<a name="l02762"></a>02762 
<a name="l02763"></a>02763     type = purple_mime_part_get_field(part, <span class="stringliteral">&quot;content-type&quot;</span>);
<a name="l02764"></a>02764     DEBUG_INFO(<span class="stringliteral">&quot;MIME part Content-Type: %s\n&quot;</span>, NSTR(type));
<a name="l02765"></a>02765 
<a name="l02766"></a>02766     <span class="keywordflow">if</span>(! type) {
<a name="l02767"></a>02767       ; <span class="comment">/* feh */</span>
<a name="l02768"></a>02768 
<a name="l02769"></a>02769     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(purple_str_has_prefix(type, <span class="stringliteral">&quot;image&quot;</span>)) {
<a name="l02770"></a>02770       <span class="comment">/* put images into the image store */</span>
<a name="l02771"></a>02771 
<a name="l02772"></a>02772       guchar *d_dat;
<a name="l02773"></a>02773       gsize d_len;
<a name="l02774"></a>02774       <span class="keywordtype">char</span> *cid;
<a name="l02775"></a>02775       <span class="keywordtype">int</span> img;
<a name="l02776"></a>02776 
<a name="l02777"></a>02777       <span class="comment">/* obtain and unencode the data */</span>
<a name="l02778"></a>02778       purple_mime_part_get_data_decoded(part, &amp;d_dat, &amp;d_len);
<a name="l02779"></a>02779 
<a name="l02780"></a>02780       <span class="comment">/* look up the content id */</span>
<a name="l02781"></a>02781       cid = (<span class="keywordtype">char</span> *) purple_mime_part_get_field(part, <span class="stringliteral">&quot;Content-ID&quot;</span>);
<a name="l02782"></a>02782       cid = make_cid(cid);
<a name="l02783"></a>02783 
<a name="l02784"></a>02784       <span class="comment">/* add image to the purple image store */</span>
<a name="l02785"></a>02785       img = purple_imgstore_add_with_id(d_dat, d_len, cid);
<a name="l02786"></a>02786 
<a name="l02787"></a>02787       <span class="comment">/* map the cid to the image store identifier */</span>
<a name="l02788"></a>02788       g_hash_table_insert(img_by_cid, cid, GINT_TO_POINTER(img));
<a name="l02789"></a>02789 
<a name="l02790"></a>02790       <span class="comment">/* recall the image for dereferencing later */</span>
<a name="l02791"></a>02791       images = g_list_append(images, GINT_TO_POINTER(img));
<a name="l02792"></a>02792 
<a name="l02793"></a>02793     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(purple_str_has_prefix(type, <span class="stringliteral">&quot;text&quot;</span>)) {
<a name="l02794"></a>02794 
<a name="l02795"></a>02795       <span class="comment">/* concatenate all the text parts together */</span>
<a name="l02796"></a>02796       guchar *data;
<a name="l02797"></a>02797       gsize len;
<a name="l02798"></a>02798 
<a name="l02799"></a>02799       purple_mime_part_get_data_decoded(part, &amp;data, &amp;len);
<a name="l02800"></a>02800       g_string_append(str, (<span class="keyword">const</span> <span class="keywordtype">char</span> *)data);
<a name="l02801"></a>02801       g_free(data);
<a name="l02802"></a>02802     }
<a name="l02803"></a>02803   }
<a name="l02804"></a>02804 
<a name="l02805"></a>02805   purple_mime_document_free(doc);
<a name="l02806"></a>02806 
<a name="l02807"></a>02807   <span class="comment">/* @todo should put this in its own function */</span>
<a name="l02808"></a>02808   { <span class="comment">/* replace each IMG tag&#39;s SRC attribute with an ID attribute. This</span>
<a name="l02809"></a>02809 <span class="comment">       actually modifies the contents of str */</span>
<a name="l02810"></a>02810     GData *attribs;
<a name="l02811"></a>02811     <span class="keywordtype">char</span> *start, *end;
<a name="l02812"></a>02812     <span class="keywordtype">char</span> *tmp = str-&gt;str;
<a name="l02813"></a>02813 
<a name="l02814"></a>02814     <span class="keywordflow">while</span>(*tmp &amp;&amp; purple_markup_find_tag(<span class="stringliteral">&quot;img&quot;</span>, tmp, (<span class="keyword">const</span> <span class="keywordtype">char</span> **) &amp;start,
<a name="l02815"></a>02815                                        (<span class="keyword">const</span> <span class="keywordtype">char</span> **) &amp;end, &amp;attribs)) {
<a name="l02816"></a>02816 
<a name="l02817"></a>02817       <span class="keywordtype">char</span> *alt, *align, *border, *src;
<a name="l02818"></a>02818       <span class="keywordtype">int</span> img = 0;
<a name="l02819"></a>02819 
<a name="l02820"></a>02820       alt = g_datalist_get_data(&amp;attribs, <span class="stringliteral">&quot;alt&quot;</span>);
<a name="l02821"></a>02821       align = g_datalist_get_data(&amp;attribs, <span class="stringliteral">&quot;align&quot;</span>);
<a name="l02822"></a>02822       border = g_datalist_get_data(&amp;attribs, <span class="stringliteral">&quot;border&quot;</span>);
<a name="l02823"></a>02823       src = g_datalist_get_data(&amp;attribs, <span class="stringliteral">&quot;src&quot;</span>);
<a name="l02824"></a>02824 
<a name="l02825"></a>02825       <span class="keywordflow">if</span>(src)
<a name="l02826"></a>02826         img = GPOINTER_TO_INT(g_hash_table_lookup(img_by_cid, src));
<a name="l02827"></a>02827 
<a name="l02828"></a>02828       <span class="keywordflow">if</span>(img) {
<a name="l02829"></a>02829         GString *atstr;
<a name="l02830"></a>02830         gsize len = (end - start);
<a name="l02831"></a>02831         gsize mov;
<a name="l02832"></a>02832 
<a name="l02833"></a>02833         atstr = g_string_new(<span class="stringliteral">&quot;&quot;</span>);
<a name="l02834"></a>02834         <span class="keywordflow">if</span>(alt) g_string_append_printf(atstr, <span class="stringliteral">&quot; alt=\&quot;%s\&quot;&quot;</span>, alt);
<a name="l02835"></a>02835         <span class="keywordflow">if</span>(align) g_string_append_printf(atstr, <span class="stringliteral">&quot; align=\&quot;%s\&quot;&quot;</span>, align);
<a name="l02836"></a>02836         <span class="keywordflow">if</span>(border) g_string_append_printf(atstr, <span class="stringliteral">&quot; border=\&quot;%s\&quot;&quot;</span>, border);
<a name="l02837"></a>02837 
<a name="l02838"></a>02838         mov = g_snprintf(start, len, <span class="stringliteral">&quot;&lt;img%s id=\&quot;%i\&quot;&quot;</span>, atstr-&gt;str, img);
<a name="l02839"></a>02839         <span class="keywordflow">while</span>(mov &lt; len) start[mov++] = <span class="charliteral">&#39; &#39;</span>;
<a name="l02840"></a>02840 
<a name="l02841"></a>02841         g_string_free(atstr, TRUE);
<a name="l02842"></a>02842       }
<a name="l02843"></a>02843 
<a name="l02844"></a>02844       g_datalist_clear(&amp;attribs);
<a name="l02845"></a>02845       tmp = end + 1;
<a name="l02846"></a>02846     }
<a name="l02847"></a>02847   }
<a name="l02848"></a>02848 
<a name="l02849"></a>02849   im_recv_html(conv, pd, str-&gt;str);
<a name="l02850"></a>02850 
<a name="l02851"></a>02851   g_string_free(str, TRUE);
<a name="l02852"></a>02852 
<a name="l02853"></a>02853   <span class="comment">/* clean up the cid table */</span>
<a name="l02854"></a>02854   g_hash_table_destroy(img_by_cid);
<a name="l02855"></a>02855 
<a name="l02856"></a>02856   <span class="comment">/* dereference all the imgages */</span>
<a name="l02857"></a>02857   <span class="keywordflow">while</span>(images) {
<a name="l02858"></a>02858     purple_imgstore_unref_by_id(GPOINTER_TO_INT(images-&gt;data));
<a name="l02859"></a>02859     images = g_list_delete_link(images, images);
<a name="l02860"></a>02860   }
<a name="l02861"></a>02861 }
<a name="l02862"></a>02862 
<a name="l02863"></a>02863 
<a name="l02864"></a>02864 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_conversation_recv(<span class="keyword">struct</span> mwConversation *conv,
<a name="l02865"></a>02865                                  <span class="keyword">enum</span> mwImSendType type,
<a name="l02866"></a>02866                                  gconstpointer msg) {
<a name="l02867"></a>02867   <span class="keyword">struct </span>mwServiceIm *srvc;
<a name="l02868"></a>02868   <span class="keyword">struct </span>mwSession *session;
<a name="l02869"></a>02869   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l02870"></a>02870 
<a name="l02871"></a>02871   srvc = mwConversation_getService(conv);
<a name="l02872"></a>02872   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l02873"></a>02873   pd = mwSession_getClientData(session);
<a name="l02874"></a>02874 
<a name="l02875"></a>02875   <span class="keywordflow">switch</span>(type) {
<a name="l02876"></a>02876   <span class="keywordflow">case</span> mwImSend_PLAIN:
<a name="l02877"></a>02877     im_recv_text(conv, pd, msg);
<a name="l02878"></a>02878     <span class="keywordflow">break</span>;
<a name="l02879"></a>02879 
<a name="l02880"></a>02880   <span class="keywordflow">case</span> mwImSend_TYPING:
<a name="l02881"></a>02881     im_recv_typing(conv, pd, !! msg);
<a name="l02882"></a>02882     <span class="keywordflow">break</span>;
<a name="l02883"></a>02883 
<a name="l02884"></a>02884   <span class="keywordflow">case</span> mwImSend_HTML:
<a name="l02885"></a>02885     im_recv_html(conv, pd, msg);
<a name="l02886"></a>02886     <span class="keywordflow">break</span>;
<a name="l02887"></a>02887 
<a name="l02888"></a>02888   <span class="keywordflow">case</span> mwImSend_SUBJECT:
<a name="l02889"></a>02889     im_recv_subj(conv, pd, msg);
<a name="l02890"></a>02890     <span class="keywordflow">break</span>;
<a name="l02891"></a>02891 
<a name="l02892"></a>02892   <span class="keywordflow">case</span> mwImSend_MIME:
<a name="l02893"></a>02893     im_recv_mime(conv, pd, msg);
<a name="l02894"></a>02894     <span class="keywordflow">break</span>;
<a name="l02895"></a>02895 
<a name="l02896"></a>02896   <span class="keywordflow">default</span>:
<a name="l02897"></a>02897     DEBUG_INFO(<span class="stringliteral">&quot;conversation received strange type, 0x%04x\n&quot;</span>, type);
<a name="l02898"></a>02898     ; <span class="comment">/* erm... */</span>
<a name="l02899"></a>02899   }
<a name="l02900"></a>02900 }
<a name="l02901"></a>02901 
<a name="l02902"></a>02902 
<a name="l02903"></a>02903 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_place_invite(<span class="keyword">struct</span> mwConversation *conv,
<a name="l02904"></a>02904                             <span class="keyword">const</span> <span class="keywordtype">char</span> *message,
<a name="l02905"></a>02905                             <span class="keyword">const</span> <span class="keywordtype">char</span> *title, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l02906"></a>02906   <span class="keyword">struct </span>mwServiceIm *srvc;
<a name="l02907"></a>02907   <span class="keyword">struct </span>mwSession *session;
<a name="l02908"></a>02908   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l02909"></a>02909 
<a name="l02910"></a>02910   <span class="keyword">struct </span>mwIdBlock *idb;
<a name="l02911"></a>02911   GHashTable *ht;
<a name="l02912"></a>02912 
<a name="l02913"></a>02913   srvc = mwConversation_getService(conv);
<a name="l02914"></a>02914   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l02915"></a>02915   pd = mwSession_getClientData(session);
<a name="l02916"></a>02916 
<a name="l02917"></a>02917   idb = mwConversation_getTarget(conv);
<a name="l02918"></a>02918 
<a name="l02919"></a>02919   ht = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, g_free);
<a name="l02920"></a>02920   g_hash_table_insert(ht, CHAT_KEY_CREATOR, g_strdup(idb-&gt;user));
<a name="l02921"></a>02921   g_hash_table_insert(ht, CHAT_KEY_NAME, g_strdup(name));
<a name="l02922"></a>02922   g_hash_table_insert(ht, CHAT_KEY_TOPIC, g_strdup(title));
<a name="l02923"></a>02923   g_hash_table_insert(ht, CHAT_KEY_INVITE, g_strdup(message));
<a name="l02924"></a>02924   g_hash_table_insert(ht, CHAT_KEY_IS_PLACE, g_strdup(<span class="stringliteral">&quot;&quot;</span>)); <span class="comment">/* ugh */</span>
<a name="l02925"></a>02925 
<a name="l02926"></a>02926   <span class="keywordflow">if</span>(! title) title = <span class="stringliteral">&quot;(no title)&quot;</span>;
<a name="l02927"></a>02927   <span class="keywordflow">if</span>(! message) message = <span class="stringliteral">&quot;(no message)&quot;</span>;
<a name="l02928"></a>02928   serv_got_chat_invite(pd-&gt;gc, title, idb-&gt;user, message, ht);
<a name="l02929"></a>02929 
<a name="l02930"></a>02930   mwConversation_close(conv, ERR_SUCCESS);
<a name="l02931"></a>02931   mwConversation_free(conv);
<a name="l02932"></a>02932 }
<a name="l02933"></a>02933 
<a name="l02934"></a>02934 
<a name="l02935"></a>02935 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_im_clear(<span class="keyword">struct</span> mwServiceIm *srvc) {
<a name="l02936"></a>02936   ;
<a name="l02937"></a>02937 }
<a name="l02938"></a>02938 
<a name="l02939"></a>02939 
<a name="l02940"></a>02940 <span class="keyword">static</span> <span class="keyword">struct </span>mwImHandler mw_im_handler = {
<a name="l02941"></a>02941   mw_conversation_opened,
<a name="l02942"></a>02942   mw_conversation_closed,
<a name="l02943"></a>02943   mw_conversation_recv,
<a name="l02944"></a>02944   mw_place_invite,
<a name="l02945"></a>02945   mw_im_clear,
<a name="l02946"></a>02946 };
<a name="l02947"></a>02947 
<a name="l02948"></a>02948 
<a name="l02949"></a>02949 <span class="keyword">static</span> <span class="keyword">struct </span>mwServiceIm *mw_srvc_im_new(<span class="keyword">struct</span> mwSession *s) {
<a name="l02950"></a>02950   <span class="keyword">struct </span>mwServiceIm *srvc;
<a name="l02951"></a>02951   srvc = mwServiceIm_new(s, &amp;mw_im_handler);
<a name="l02952"></a>02952   mwServiceIm_setClientType(srvc, mwImClient_NOTESBUDDY);
<a name="l02953"></a>02953   <span class="keywordflow">return</span> srvc;
<a name="l02954"></a>02954 }
<a name="l02955"></a>02955 
<a name="l02956"></a>02956 
<a name="l02957"></a>02957 <span class="comment">/* The following helps us relate a mwPlace to a PurpleConvChat in the</span>
<a name="l02958"></a>02958 <span class="comment">   various forms by which either may be indicated. Uses some of</span>
<a name="l02959"></a>02959 <span class="comment">   the similar macros from the conference service above */</span>
<a name="l02960"></a>02960 
<a name="l02961"></a>02961 <span class="preprocessor">#define PLACE_TO_ID(place)   (GPOINTER_TO_INT(place))</span>
<a name="l02962"></a>02962 <span class="preprocessor"></span><span class="preprocessor">#define ID_TO_PLACE(pd, id)  (place_find_by_id((pd), (id)))</span>
<a name="l02963"></a>02963 <span class="preprocessor"></span>
<a name="l02964"></a>02964 <span class="preprocessor">#define CHAT_TO_PLACE(pd, chat)  (ID_TO_PLACE((pd), CHAT_TO_ID(chat)))</span>
<a name="l02965"></a>02965 <span class="preprocessor"></span><span class="preprocessor">#define PLACE_TO_CHAT(place)     (ID_TO_CHAT(PLACE_TO_ID(place)))</span>
<a name="l02966"></a>02966 <span class="preprocessor"></span>
<a name="l02967"></a>02967 
<a name="l02968"></a>02968 <span class="keyword">static</span> <span class="keyword">struct </span>mwPlace *
<a name="l02969"></a>02969 place_find_by_id(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd, <span class="keywordtype">int</span> <span class="keywordtype">id</span>) {
<a name="l02970"></a>02970   <span class="keyword">struct </span>mwServicePlace *srvc = pd-&gt;srvc_place;
<a name="l02971"></a>02971   <span class="keyword">struct </span>mwPlace *place = NULL;
<a name="l02972"></a>02972   GList *l;
<a name="l02973"></a>02973 
<a name="l02974"></a>02974   l = (GList *) mwServicePlace_getPlaces(srvc);
<a name="l02975"></a>02975   <span class="keywordflow">for</span>(; l; l = l-&gt;next) {
<a name="l02976"></a>02976     <span class="keyword">struct </span>mwPlace *p = l-&gt;data;
<a name="l02977"></a>02977     <a class="code" href="struct___purple_conv_chat.html">PurpleConvChat</a> *h = PURPLE_CONV_CHAT(mwPlace_getClientData(p));
<a name="l02978"></a>02978 
<a name="l02979"></a>02979     <span class="keywordflow">if</span>(CHAT_TO_ID(h) == <span class="keywordtype">id</span>) {
<a name="l02980"></a>02980       place = p;
<a name="l02981"></a>02981       <span class="keywordflow">break</span>;
<a name="l02982"></a>02982     }
<a name="l02983"></a>02983   }
<a name="l02984"></a>02984 
<a name="l02985"></a>02985   <span class="keywordflow">return</span> place;
<a name="l02986"></a>02986 }
<a name="l02987"></a>02987 
<a name="l02988"></a>02988 
<a name="l02989"></a>02989 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_place_opened(<span class="keyword">struct</span> mwPlace *place) {
<a name="l02990"></a>02990   <span class="keyword">struct </span>mwServicePlace *srvc;
<a name="l02991"></a>02991   <span class="keyword">struct </span>mwSession *session;
<a name="l02992"></a>02992   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l02993"></a>02993   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l02994"></a>02994   <a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *gconf;
<a name="l02995"></a>02995 
<a name="l02996"></a>02996   GList *members, *l;
<a name="l02997"></a>02997 
<a name="l02998"></a>02998   <span class="keyword">const</span> <span class="keywordtype">char</span> *n = mwPlace_getName(place);
<a name="l02999"></a>02999   <span class="keyword">const</span> <span class="keywordtype">char</span> *t = mwPlace_getTitle(place);
<a name="l03000"></a>03000 
<a name="l03001"></a>03001   srvc = mwPlace_getService(place);
<a name="l03002"></a>03002   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l03003"></a>03003   pd = mwSession_getClientData(session);
<a name="l03004"></a>03004   gc = pd-&gt;gc;
<a name="l03005"></a>03005 
<a name="l03006"></a>03006   members = mwPlace_getMembers(place);
<a name="l03007"></a>03007 
<a name="l03008"></a>03008   DEBUG_INFO(<span class="stringliteral">&quot;place %s opened, %u initial members\n&quot;</span>,
<a name="l03009"></a>03009              NSTR(n), g_list_length(members));
<a name="l03010"></a>03010 
<a name="l03011"></a>03011   <span class="keywordflow">if</span>(! t) t = <span class="stringliteral">&quot;(no title)&quot;</span>;
<a name="l03012"></a>03012   gconf = serv_got_joined_chat(gc, PLACE_TO_ID(place), t);
<a name="l03013"></a>03013 
<a name="l03014"></a>03014   mwPlace_setClientData(place, gconf, NULL);
<a name="l03015"></a>03015 
<a name="l03016"></a>03016   <span class="keywordflow">for</span>(l = members; l; l = l-&gt;next) {
<a name="l03017"></a>03017     <span class="keyword">struct </span>mwIdBlock *idb = l-&gt;data;
<a name="l03018"></a>03018     purple_conv_chat_add_user(PURPLE_CONV_CHAT(gconf), idb-&gt;user,
<a name="l03019"></a>03019                             NULL, <a class="code" href="conversation_8h.html#a3635e89c9e02d67f03439d6524272754add974cbea163764e0caf40927d177ee0">PURPLE_CBFLAGS_NONE</a>, FALSE);
<a name="l03020"></a>03020   }
<a name="l03021"></a>03021   g_list_free(members);
<a name="l03022"></a>03022 }
<a name="l03023"></a>03023 
<a name="l03024"></a>03024 
<a name="l03025"></a>03025 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_place_closed(<span class="keyword">struct</span> mwPlace *place, guint32 code) {
<a name="l03026"></a>03026   <span class="keyword">struct </span>mwServicePlace *srvc;
<a name="l03027"></a>03027   <span class="keyword">struct </span>mwSession *session;
<a name="l03028"></a>03028   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03029"></a>03029   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03030"></a>03030 
<a name="l03031"></a>03031   <span class="keyword">const</span> <span class="keywordtype">char</span> *n = mwPlace_getName(place);
<a name="l03032"></a>03032   <span class="keywordtype">char</span> *msg = mwError(code);
<a name="l03033"></a>03033 
<a name="l03034"></a>03034   DEBUG_INFO(<span class="stringliteral">&quot;place %s closed, 0x%08x\n&quot;</span>, NSTR(n), code);
<a name="l03035"></a>03035 
<a name="l03036"></a>03036   srvc = mwPlace_getService(place);
<a name="l03037"></a>03037   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l03038"></a>03038   pd = mwSession_getClientData(session);
<a name="l03039"></a>03039   gc = pd-&gt;gc;
<a name="l03040"></a>03040 
<a name="l03041"></a>03041   serv_got_chat_left(gc, PLACE_TO_ID(place));
<a name="l03042"></a>03042 
<a name="l03043"></a>03043   <a class="code" href="notify_8h.html#ad54861c382f50702e2c6c2317aff878d">purple_notify_error</a>(gc, _(<span class="stringliteral">&quot;Place Closed&quot;</span>), NULL, msg);
<a name="l03044"></a>03044   g_free(msg);
<a name="l03045"></a>03045 }
<a name="l03046"></a>03046 
<a name="l03047"></a>03047 
<a name="l03048"></a>03048 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_place_peerJoined(<span class="keyword">struct</span> mwPlace *place,
<a name="l03049"></a>03049                                 <span class="keyword">const</span> <span class="keyword">struct</span> mwIdBlock *peer) {
<a name="l03050"></a>03050   <span class="keyword">struct </span>mwServicePlace *srvc;
<a name="l03051"></a>03051   <span class="keyword">struct </span>mwSession *session;
<a name="l03052"></a>03052   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03053"></a>03053   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03054"></a>03054   <a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *gconf;
<a name="l03055"></a>03055 
<a name="l03056"></a>03056   <span class="keyword">const</span> <span class="keywordtype">char</span> *n = mwPlace_getName(place);
<a name="l03057"></a>03057 
<a name="l03058"></a>03058   DEBUG_INFO(<span class="stringliteral">&quot;%s joined place %s\n&quot;</span>, NSTR(peer-&gt;user), NSTR(n));
<a name="l03059"></a>03059 
<a name="l03060"></a>03060   srvc = mwPlace_getService(place);
<a name="l03061"></a>03061   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l03062"></a>03062   pd = mwSession_getClientData(session);
<a name="l03063"></a>03063   gc = pd-&gt;gc;
<a name="l03064"></a>03064 
<a name="l03065"></a>03065   gconf = mwPlace_getClientData(place);
<a name="l03066"></a>03066   g_return_if_fail(gconf != NULL);
<a name="l03067"></a>03067 
<a name="l03068"></a>03068   purple_conv_chat_add_user(PURPLE_CONV_CHAT(gconf), peer-&gt;user,
<a name="l03069"></a>03069                           NULL, <a class="code" href="conversation_8h.html#a3635e89c9e02d67f03439d6524272754add974cbea163764e0caf40927d177ee0">PURPLE_CBFLAGS_NONE</a>, TRUE);
<a name="l03070"></a>03070 }
<a name="l03071"></a>03071 
<a name="l03072"></a>03072 
<a name="l03073"></a>03073 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_place_peerParted(<span class="keyword">struct</span> mwPlace *place,
<a name="l03074"></a>03074                                 <span class="keyword">const</span> <span class="keyword">struct</span> mwIdBlock *peer) {
<a name="l03075"></a>03075   <span class="keyword">struct </span>mwServicePlace *srvc;
<a name="l03076"></a>03076   <span class="keyword">struct </span>mwSession *session;
<a name="l03077"></a>03077   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03078"></a>03078   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03079"></a>03079   <a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *gconf;
<a name="l03080"></a>03080 
<a name="l03081"></a>03081   <span class="keyword">const</span> <span class="keywordtype">char</span> *n = mwPlace_getName(place);
<a name="l03082"></a>03082 
<a name="l03083"></a>03083   DEBUG_INFO(<span class="stringliteral">&quot;%s left place %s\n&quot;</span>, NSTR(peer-&gt;user), NSTR(n));
<a name="l03084"></a>03084 
<a name="l03085"></a>03085   srvc = mwPlace_getService(place);
<a name="l03086"></a>03086   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l03087"></a>03087   pd = mwSession_getClientData(session);
<a name="l03088"></a>03088   gc = pd-&gt;gc;
<a name="l03089"></a>03089 
<a name="l03090"></a>03090   gconf = mwPlace_getClientData(place);
<a name="l03091"></a>03091   g_return_if_fail(gconf != NULL);
<a name="l03092"></a>03092 
<a name="l03093"></a>03093   purple_conv_chat_remove_user(PURPLE_CONV_CHAT(gconf), peer-&gt;user, NULL);
<a name="l03094"></a>03094 }
<a name="l03095"></a>03095 
<a name="l03096"></a>03096 
<a name="l03097"></a>03097 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_place_peerSetAttribute(<span class="keyword">struct</span> mwPlace *place,
<a name="l03098"></a>03098                                       <span class="keyword">const</span> <span class="keyword">struct</span> mwIdBlock *peer,
<a name="l03099"></a>03099                                       guint32 attr, <span class="keyword">struct</span> mwOpaque *o) {
<a name="l03100"></a>03100   ;
<a name="l03101"></a>03101 }
<a name="l03102"></a>03102 
<a name="l03103"></a>03103 
<a name="l03104"></a>03104 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_place_peerUnsetAttribute(<span class="keyword">struct</span> mwPlace *place,
<a name="l03105"></a>03105                                         <span class="keyword">const</span> <span class="keyword">struct</span> mwIdBlock *peer,
<a name="l03106"></a>03106                                         guint32 attr) {
<a name="l03107"></a>03107   ;
<a name="l03108"></a>03108 }
<a name="l03109"></a>03109 
<a name="l03110"></a>03110 
<a name="l03111"></a>03111 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_place_message(<span class="keyword">struct</span> mwPlace *place,
<a name="l03112"></a>03112                              <span class="keyword">const</span> <span class="keyword">struct</span> mwIdBlock *who,
<a name="l03113"></a>03113                              <span class="keyword">const</span> <span class="keywordtype">char</span> *msg) {
<a name="l03114"></a>03114   <span class="keyword">struct </span>mwServicePlace *srvc;
<a name="l03115"></a>03115   <span class="keyword">struct </span>mwSession *session;
<a name="l03116"></a>03116   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03117"></a>03117   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03118"></a>03118   <span class="keywordtype">char</span> *esc;
<a name="l03119"></a>03119 
<a name="l03120"></a>03120   <span class="keywordflow">if</span>(! msg) <span class="keywordflow">return</span>;
<a name="l03121"></a>03121 
<a name="l03122"></a>03122   srvc = mwPlace_getService(place);
<a name="l03123"></a>03123   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l03124"></a>03124   pd = mwSession_getClientData(session);
<a name="l03125"></a>03125   gc = pd-&gt;gc;
<a name="l03126"></a>03126 
<a name="l03127"></a>03127   esc = g_markup_escape_text(msg, -1);
<a name="l03128"></a>03128   serv_got_chat_in(gc, PLACE_TO_ID(place), who-&gt;user, 0, esc, time(NULL));
<a name="l03129"></a>03129   g_free(esc);
<a name="l03130"></a>03130 }
<a name="l03131"></a>03131 
<a name="l03132"></a>03132 
<a name="l03133"></a>03133 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_place_clear(<span class="keyword">struct</span> mwServicePlace *srvc) {
<a name="l03134"></a>03134   ;
<a name="l03135"></a>03135 }
<a name="l03136"></a>03136 
<a name="l03137"></a>03137 
<a name="l03138"></a>03138 <span class="keyword">static</span> <span class="keyword">struct </span>mwPlaceHandler mw_place_handler = {
<a name="l03139"></a>03139   mw_place_opened,
<a name="l03140"></a>03140   mw_place_closed,
<a name="l03141"></a>03141   mw_place_peerJoined,
<a name="l03142"></a>03142   mw_place_peerParted,
<a name="l03143"></a>03143   mw_place_peerSetAttribute,
<a name="l03144"></a>03144   mw_place_peerUnsetAttribute,
<a name="l03145"></a>03145   mw_place_message,
<a name="l03146"></a>03146   mw_place_clear,
<a name="l03147"></a>03147 };
<a name="l03148"></a>03148 
<a name="l03149"></a>03149 
<a name="l03150"></a>03150 <span class="keyword">static</span> <span class="keyword">struct </span>mwServicePlace *mw_srvc_place_new(<span class="keyword">struct</span> mwSession *s) {
<a name="l03151"></a>03151   <span class="keyword">struct </span>mwServicePlace *srvc;
<a name="l03152"></a>03152   srvc = mwServicePlace_new(s, &amp;mw_place_handler);
<a name="l03153"></a>03153   <span class="keywordflow">return</span> srvc;
<a name="l03154"></a>03154 }
<a name="l03155"></a>03155 
<a name="l03156"></a>03156 
<a name="l03157"></a>03157 <span class="keyword">static</span> <span class="keyword">struct </span>mwServiceResolve *mw_srvc_resolve_new(<span class="keyword">struct</span> mwSession *s) {
<a name="l03158"></a>03158   <span class="keyword">struct </span>mwServiceResolve *srvc;
<a name="l03159"></a>03159   srvc = mwServiceResolve_new(s);
<a name="l03160"></a>03160   <span class="keywordflow">return</span> srvc;
<a name="l03161"></a>03161 }
<a name="l03162"></a>03162 
<a name="l03163"></a>03163 
<a name="l03164"></a>03164 <span class="keyword">static</span> <span class="keyword">struct </span>mwServiceStorage *mw_srvc_store_new(<span class="keyword">struct</span> mwSession *s) {
<a name="l03165"></a>03165   <span class="keyword">struct </span>mwServiceStorage *srvc;
<a name="l03166"></a>03166   srvc = mwServiceStorage_new(s);
<a name="l03167"></a>03167   <span class="keywordflow">return</span> srvc;
<a name="l03168"></a>03168 }
<a name="l03169"></a>03169 
<a name="l03170"></a>03170 
<a name="l03172"></a>03172 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *mwPurplePluginData_new(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc) {
<a name="l03173"></a>03173   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03174"></a>03174 
<a name="l03175"></a>03175   g_return_val_if_fail(gc != NULL, NULL);
<a name="l03176"></a>03176 
<a name="l03177"></a>03177   pd = g_new0(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a>, 1);
<a name="l03178"></a>03178   pd-&gt;gc = gc;
<a name="l03179"></a>03179   pd-&gt;session = mwSession_new(&amp;mw_session_handler);
<a name="l03180"></a>03180   pd-&gt;srvc_aware = mw_srvc_aware_new(pd-&gt;session);
<a name="l03181"></a>03181   pd-&gt;srvc_conf = mw_srvc_conf_new(pd-&gt;session);
<a name="l03182"></a>03182   pd-&gt;srvc_ft = mw_srvc_ft_new(pd-&gt;session);
<a name="l03183"></a>03183   pd-&gt;srvc_im = mw_srvc_im_new(pd-&gt;session);
<a name="l03184"></a>03184   pd-&gt;srvc_place = mw_srvc_place_new(pd-&gt;session);
<a name="l03185"></a>03185   pd-&gt;srvc_resolve = mw_srvc_resolve_new(pd-&gt;session);
<a name="l03186"></a>03186   pd-&gt;srvc_store = mw_srvc_store_new(pd-&gt;session);
<a name="l03187"></a>03187   pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">group_list_map</a> = g_hash_table_new(g_direct_hash, g_direct_equal);
<a name="l03188"></a>03188   pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a4271075ebe80e8e123d1d22a2673ce6a">sock_buf</a> = purple_circ_buffer_new(0);
<a name="l03189"></a>03189 
<a name="l03190"></a>03190   mwSession_addService(pd-&gt;session, MW_SERVICE(pd-&gt;srvc_aware));
<a name="l03191"></a>03191   mwSession_addService(pd-&gt;session, MW_SERVICE(pd-&gt;srvc_conf));
<a name="l03192"></a>03192   mwSession_addService(pd-&gt;session, MW_SERVICE(pd-&gt;srvc_ft));
<a name="l03193"></a>03193   mwSession_addService(pd-&gt;session, MW_SERVICE(pd-&gt;srvc_im));
<a name="l03194"></a>03194   mwSession_addService(pd-&gt;session, MW_SERVICE(pd-&gt;srvc_place));
<a name="l03195"></a>03195   mwSession_addService(pd-&gt;session, MW_SERVICE(pd-&gt;srvc_resolve));
<a name="l03196"></a>03196   mwSession_addService(pd-&gt;session, MW_SERVICE(pd-&gt;srvc_store));
<a name="l03197"></a>03197 
<a name="l03198"></a>03198   mwSession_addCipher(pd-&gt;session, mwCipher_new_RC2_40(pd-&gt;session));
<a name="l03199"></a>03199   mwSession_addCipher(pd-&gt;session, mwCipher_new_RC2_128(pd-&gt;session));
<a name="l03200"></a>03200 
<a name="l03201"></a>03201   mwSession_setClientData(pd-&gt;session, pd, NULL);
<a name="l03202"></a>03202   gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a> = pd;
<a name="l03203"></a>03203 
<a name="l03204"></a>03204   <span class="keywordflow">return</span> pd;
<a name="l03205"></a>03205 }
<a name="l03206"></a>03206 
<a name="l03207"></a>03207 
<a name="l03208"></a>03208 <span class="keyword">static</span> <span class="keywordtype">void</span> mwPurplePluginData_free(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd) {
<a name="l03209"></a>03209   g_return_if_fail(pd != NULL);
<a name="l03210"></a>03210 
<a name="l03211"></a>03211   pd-&gt;gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a> = NULL;
<a name="l03212"></a>03212 
<a name="l03213"></a>03213   mwSession_removeService(pd-&gt;session, mwService_AWARE);
<a name="l03214"></a>03214   mwSession_removeService(pd-&gt;session, mwService_CONFERENCE);
<a name="l03215"></a>03215   mwSession_removeService(pd-&gt;session, mwService_FILE_TRANSFER);
<a name="l03216"></a>03216   mwSession_removeService(pd-&gt;session, mwService_IM);
<a name="l03217"></a>03217   mwSession_removeService(pd-&gt;session, mwService_PLACE);
<a name="l03218"></a>03218   mwSession_removeService(pd-&gt;session, mwService_RESOLVE);
<a name="l03219"></a>03219   mwSession_removeService(pd-&gt;session, mwService_STORAGE);
<a name="l03220"></a>03220 
<a name="l03221"></a>03221   mwService_free(MW_SERVICE(pd-&gt;srvc_aware));
<a name="l03222"></a>03222   mwService_free(MW_SERVICE(pd-&gt;srvc_conf));
<a name="l03223"></a>03223   mwService_free(MW_SERVICE(pd-&gt;srvc_ft));
<a name="l03224"></a>03224   mwService_free(MW_SERVICE(pd-&gt;srvc_im));
<a name="l03225"></a>03225   mwService_free(MW_SERVICE(pd-&gt;srvc_place));
<a name="l03226"></a>03226   mwService_free(MW_SERVICE(pd-&gt;srvc_resolve));
<a name="l03227"></a>03227   mwService_free(MW_SERVICE(pd-&gt;srvc_store));
<a name="l03228"></a>03228 
<a name="l03229"></a>03229   mwCipher_free(mwSession_getCipher(pd-&gt;session, mwCipher_RC2_40));
<a name="l03230"></a>03230   mwCipher_free(mwSession_getCipher(pd-&gt;session, mwCipher_RC2_128));
<a name="l03231"></a>03231 
<a name="l03232"></a>03232   mwSession_free(pd-&gt;session);
<a name="l03233"></a>03233 
<a name="l03234"></a>03234   g_hash_table_destroy(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">group_list_map</a>);
<a name="l03235"></a>03235   purple_circ_buffer_destroy(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a4271075ebe80e8e123d1d22a2673ce6a">sock_buf</a>);
<a name="l03236"></a>03236 
<a name="l03237"></a>03237   g_free(pd);
<a name="l03238"></a>03238 }
<a name="l03239"></a>03239 
<a name="l03240"></a>03240 
<a name="l03241"></a>03241 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *mw_prpl_list_icon(<a class="code" href="struct___purple_account.html">PurpleAccount</a> *a, <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *b) {
<a name="l03242"></a>03242   <span class="comment">/* my little green dude is a chopped up version of the aim running</span>
<a name="l03243"></a>03243 <span class="comment">     guy.  First, cut off the head and store someplace safe. Then,</span>
<a name="l03244"></a>03244 <span class="comment">     take the left-half side of the body and throw it away. Make a</span>
<a name="l03245"></a>03245 <span class="comment">     copy of the remaining body, and flip it horizontally. Now attach</span>
<a name="l03246"></a>03246 <span class="comment">     the two pieces into an X shape, and drop the head back on the</span>
<a name="l03247"></a>03247 <span class="comment">     top, being careful to center it. Then, just change the color</span>
<a name="l03248"></a>03248 <span class="comment">     saturation to bring the red down a bit, and voila! */</span>
<a name="l03249"></a>03249 
<a name="l03250"></a>03250   <span class="comment">/* then, throw all of that away and use sodipodi to make a new</span>
<a name="l03251"></a>03251 <span class="comment">     icon. You know, LIKE A REAL MAN. */</span>
<a name="l03252"></a>03252 
<a name="l03253"></a>03253   <span class="keywordflow">return</span> <span class="stringliteral">&quot;meanwhile&quot;</span>;
<a name="l03254"></a>03254 }
<a name="l03255"></a>03255 
<a name="l03256"></a>03256 
<a name="l03257"></a>03257 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* mw_prpl_list_emblem(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *b)
<a name="l03258"></a>03258 {
<a name="l03259"></a>03259   <span class="keywordflow">if</span>(buddy_is_external(b))
<a name="l03260"></a>03260     <span class="keywordflow">return</span> <span class="stringliteral">&quot;external&quot;</span>;
<a name="l03261"></a>03261 
<a name="l03262"></a>03262   <span class="keywordflow">return</span> NULL;
<a name="l03263"></a>03263 }
<a name="l03264"></a>03264 
<a name="l03265"></a>03265 
<a name="l03266"></a>03266 <span class="keyword">static</span> <span class="keywordtype">char</span> *mw_prpl_status_text(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *b) {
<a name="l03267"></a>03267   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03268"></a>03268   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03269"></a>03269   <span class="keyword">struct </span>mwAwareIdBlock t = { mwAware_USER, (<span class="keywordtype">char</span> *)purple_buddy_get_name(b), NULL };
<a name="l03270"></a>03270   <span class="keyword">const</span> <span class="keywordtype">char</span> *ret = NULL;
<a name="l03271"></a>03271 
<a name="l03272"></a>03272   <span class="keywordflow">if</span> ((gc = purple_account_get_connection(purple_buddy_get_account(b)))
<a name="l03273"></a>03273       &amp;&amp; (pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>))
<a name="l03274"></a>03274     ret = mwServiceAware_getText(pd-&gt;srvc_aware, &amp;t);
<a name="l03275"></a>03275 
<a name="l03276"></a>03276   <span class="keywordflow">return</span> (ret &amp;&amp; g_utf8_validate(ret, -1, NULL)) ? g_markup_escape_text(ret, -1): NULL;
<a name="l03277"></a>03277 }
<a name="l03278"></a>03278 
<a name="l03279"></a>03279 
<a name="l03280"></a>03280 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *status_text(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *b) {
<a name="l03281"></a>03281   <a class="code" href="struct___purple_presence.html">PurplePresence</a> *presence;
<a name="l03282"></a>03282   <a class="code" href="struct___purple_status.html">PurpleStatus</a> *status;
<a name="l03283"></a>03283 
<a name="l03284"></a>03284   presence = purple_buddy_get_presence(b);
<a name="l03285"></a>03285   status = purple_presence_get_active_status(presence);
<a name="l03286"></a>03286 
<a name="l03287"></a>03287   <span class="keywordflow">return</span> purple_status_get_name(status);
<a name="l03288"></a>03288 }
<a name="l03289"></a>03289 
<a name="l03290"></a>03290 
<a name="l03291"></a>03291 <span class="keyword">static</span> gboolean user_supports(<span class="keyword">struct</span> mwServiceAware *srvc,
<a name="l03292"></a>03292                               <span class="keyword">const</span> <span class="keywordtype">char</span> *who, guint32 feature) {
<a name="l03293"></a>03293 
<a name="l03294"></a>03294   <span class="keyword">const</span> <span class="keyword">struct </span>mwAwareAttribute *attr;
<a name="l03295"></a>03295   <span class="keyword">struct </span>mwAwareIdBlock idb = { mwAware_USER, (<span class="keywordtype">char</span> *) who, NULL };
<a name="l03296"></a>03296 
<a name="l03297"></a>03297   attr = mwServiceAware_getAttribute(srvc, &amp;idb, feature);
<a name="l03298"></a>03298   <span class="keywordflow">return</span> (attr != NULL) &amp;&amp; mwAwareAttribute_asBoolean(attr);
<a name="l03299"></a>03299 }
<a name="l03300"></a>03300 
<a name="l03301"></a>03301 
<a name="l03302"></a>03302 <span class="keyword">static</span> <span class="keywordtype">char</span> *user_supports_text(<span class="keyword">struct</span> mwServiceAware *srvc, <span class="keyword">const</span> <span class="keywordtype">char</span> *who) {
<a name="l03303"></a>03303   <span class="keyword">const</span> <span class="keywordtype">char</span> *feat[] = {NULL, NULL, NULL, NULL, NULL};
<a name="l03304"></a>03304   <span class="keyword">const</span> <span class="keywordtype">char</span> **f = feat;
<a name="l03305"></a>03305 
<a name="l03306"></a>03306   <span class="keywordflow">if</span>(user_supports(srvc, who, mwAttribute_AV_PREFS_SET)) {
<a name="l03307"></a>03307     gboolean mic, speak, video;
<a name="l03308"></a>03308 
<a name="l03309"></a>03309     mic = user_supports(srvc, who, mwAttribute_MICROPHONE);
<a name="l03310"></a>03310     speak = user_supports(srvc, who, mwAttribute_SPEAKERS);
<a name="l03311"></a>03311     video = user_supports(srvc, who, mwAttribute_VIDEO_CAMERA);
<a name="l03312"></a>03312 
<a name="l03313"></a>03313     <span class="keywordflow">if</span>(mic) *f++ = _(<span class="stringliteral">&quot;Microphone&quot;</span>);
<a name="l03314"></a>03314     <span class="keywordflow">if</span>(speak) *f++ = _(<span class="stringliteral">&quot;Speakers&quot;</span>);
<a name="l03315"></a>03315     <span class="keywordflow">if</span>(video) *f++ = _(<span class="stringliteral">&quot;Video Camera&quot;</span>);
<a name="l03316"></a>03316   }
<a name="l03317"></a>03317 
<a name="l03318"></a>03318   <span class="keywordflow">if</span>(user_supports(srvc, who, mwAttribute_FILE_TRANSFER))
<a name="l03319"></a>03319     *f++ = _(<span class="stringliteral">&quot;File Transfer&quot;</span>);
<a name="l03320"></a>03320 
<a name="l03321"></a>03321   <span class="keywordflow">return</span> (*feat)? g_strjoinv(<span class="stringliteral">&quot;, &quot;</span>, (<span class="keywordtype">char</span> **)feat): NULL;
<a name="l03322"></a>03322   <span class="comment">/* jenni loves siege */</span>
<a name="l03323"></a>03323 }
<a name="l03324"></a>03324 
<a name="l03325"></a>03325 
<a name="l03326"></a>03326 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_tooltip_text(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *b, <a class="code" href="struct___purple_notify_user_info.html">PurpleNotifyUserInfo</a> *user_info, gboolean full) {
<a name="l03327"></a>03327   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03328"></a>03328   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = NULL;
<a name="l03329"></a>03329   <span class="keyword">struct </span>mwAwareIdBlock idb = { mwAware_USER, (<span class="keywordtype">char</span> *)purple_buddy_get_name(b), NULL };
<a name="l03330"></a>03330 
<a name="l03331"></a>03331   <span class="keyword">const</span> <span class="keywordtype">char</span> *message = NULL;
<a name="l03332"></a>03332   <span class="keyword">const</span> <span class="keywordtype">char</span> *status;
<a name="l03333"></a>03333   <span class="keywordtype">char</span> *tmp;
<a name="l03334"></a>03334 
<a name="l03335"></a>03335   <span class="keywordflow">if</span> ((gc = purple_account_get_connection(purple_buddy_get_account(b)))
<a name="l03336"></a>03336       &amp;&amp; (pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>))
<a name="l03337"></a>03337      message = mwServiceAware_getText(pd-&gt;srvc_aware, &amp;idb);
<a name="l03338"></a>03338 
<a name="l03339"></a>03339   status = status_text(b);
<a name="l03340"></a>03340 
<a name="l03341"></a>03341   <span class="keywordflow">if</span>(message != NULL &amp;&amp; g_utf8_validate(message, -1, NULL) &amp;&amp; purple_utf8_strcasecmp(status, message)) {
<a name="l03342"></a>03342     tmp = g_markup_escape_text(message, -1);
<a name="l03343"></a>03343         purple_notify_user_info_add_pair(user_info, status, tmp);
<a name="l03344"></a>03344     g_free(tmp);
<a name="l03345"></a>03345 
<a name="l03346"></a>03346   } <span class="keywordflow">else</span> {
<a name="l03347"></a>03347         purple_notify_user_info_add_pair(user_info, _(<span class="stringliteral">&quot;Status&quot;</span>), status);
<a name="l03348"></a>03348   }
<a name="l03349"></a>03349 
<a name="l03350"></a>03350   <span class="keywordflow">if</span>(full &amp;&amp; pd != NULL) {
<a name="l03351"></a>03351     tmp = user_supports_text(pd-&gt;srvc_aware, purple_buddy_get_name(b));
<a name="l03352"></a>03352     <span class="keywordflow">if</span>(tmp) {
<a name="l03353"></a>03353           purple_notify_user_info_add_pair(user_info, _(<span class="stringliteral">&quot;Supports&quot;</span>), tmp);
<a name="l03354"></a>03354       g_free(tmp);
<a name="l03355"></a>03355     }
<a name="l03356"></a>03356 
<a name="l03357"></a>03357     <span class="keywordflow">if</span>(buddy_is_external(b)) {
<a name="l03358"></a>03358           purple_notify_user_info_add_pair(user_info, NULL, _(<span class="stringliteral">&quot;External User&quot;</span>));
<a name="l03359"></a>03359     }
<a name="l03360"></a>03360   }
<a name="l03361"></a>03361 }
<a name="l03362"></a>03362 
<a name="l03363"></a>03363 <span class="keyword">static</span> GList *mw_prpl_status_types(<a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct)
<a name="l03364"></a>03364 {
<a name="l03365"></a>03365         GList *types = NULL;
<a name="l03366"></a>03366         <a class="code" href="struct___purple_status_type.html">PurpleStatusType</a> *type;
<a name="l03367"></a>03367 
<a name="l03368"></a>03368         type = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE,
<a name="l03369"></a>03369                         MW_STATE_ACTIVE, NULL, TRUE, TRUE, FALSE,
<a name="l03370"></a>03370                         MW_STATE_MESSAGE, _(<span class="stringliteral">&quot;Message&quot;</span>), <a class="code" href="value_8c.html#ab40d80035ac1a3e1728302d6bb007646">purple_value_new</a>(<a class="code" href="value_8h.html#a87d0e48c3af4f74259fe96a3c9f32694aa05738cd3332f9b63773e4c4bc17f83f">PURPLE_TYPE_STRING</a>),
<a name="l03371"></a>03371                         NULL);
<a name="l03372"></a>03372         types = g_list_append(types, type);
<a name="l03373"></a>03373 
<a name="l03374"></a>03374         type = purple_status_type_new_with_attrs(PURPLE_STATUS_AWAY,
<a name="l03375"></a>03375                         MW_STATE_AWAY, NULL, TRUE, TRUE, FALSE,
<a name="l03376"></a>03376                         MW_STATE_MESSAGE, _(<span class="stringliteral">&quot;Message&quot;</span>), <a class="code" href="value_8c.html#ab40d80035ac1a3e1728302d6bb007646">purple_value_new</a>(<a class="code" href="value_8h.html#a87d0e48c3af4f74259fe96a3c9f32694aa05738cd3332f9b63773e4c4bc17f83f">PURPLE_TYPE_STRING</a>),
<a name="l03377"></a>03377                         NULL);
<a name="l03378"></a>03378         types = g_list_append(types, type);
<a name="l03379"></a>03379 
<a name="l03380"></a>03380         type = purple_status_type_new_with_attrs(PURPLE_STATUS_UNAVAILABLE,
<a name="l03381"></a>03381                         MW_STATE_BUSY, _(<span class="stringliteral">&quot;Do Not Disturb&quot;</span>), TRUE, TRUE, FALSE,
<a name="l03382"></a>03382                         MW_STATE_MESSAGE, _(<span class="stringliteral">&quot;Message&quot;</span>), <a class="code" href="value_8c.html#ab40d80035ac1a3e1728302d6bb007646">purple_value_new</a>(<a class="code" href="value_8h.html#a87d0e48c3af4f74259fe96a3c9f32694aa05738cd3332f9b63773e4c4bc17f83f">PURPLE_TYPE_STRING</a>),
<a name="l03383"></a>03383                         NULL);
<a name="l03384"></a>03384         types = g_list_append(types, type);
<a name="l03385"></a>03385 
<a name="l03386"></a>03386         type = purple_status_type_new_full(PURPLE_STATUS_OFFLINE,
<a name="l03387"></a>03387                         MW_STATE_OFFLINE, NULL, TRUE, TRUE, FALSE);
<a name="l03388"></a>03388         types = g_list_append(types, type);
<a name="l03389"></a>03389 
<a name="l03390"></a>03390         <span class="keywordflow">return</span> types;
<a name="l03391"></a>03391 }
<a name="l03392"></a>03392 
<a name="l03393"></a>03393 
<a name="l03394"></a>03394 <span class="keyword">static</span> <span class="keywordtype">void</span> conf_create_prompt_cancel(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy,
<a name="l03395"></a>03395                                       <a class="code" href="struct_purple_request_fields.html">PurpleRequestFields</a> *fields) {
<a name="l03396"></a>03396   ; <span class="comment">/* nothing to do */</span>
<a name="l03397"></a>03397 }
<a name="l03398"></a>03398 
<a name="l03399"></a>03399 
<a name="l03400"></a>03400 <span class="keyword">static</span> <span class="keywordtype">void</span> conf_create_prompt_join(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy,
<a name="l03401"></a>03401                                     <a class="code" href="struct_purple_request_fields.html">PurpleRequestFields</a> *fields) {
<a name="l03402"></a>03402   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l03403"></a>03403   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03404"></a>03404   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03405"></a>03405   <span class="keyword">struct </span>mwServiceConference *srvc;
<a name="l03406"></a>03406 
<a name="l03407"></a>03407   <a class="code" href="struct___purple_request_field.html">PurpleRequestField</a> *f;
<a name="l03408"></a>03408 
<a name="l03409"></a>03409   <span class="keyword">const</span> <span class="keywordtype">char</span> *topic, *invite;
<a name="l03410"></a>03410   <span class="keyword">struct </span>mwConference *conf;
<a name="l03411"></a>03411   <span class="keyword">struct </span>mwIdBlock idb = { NULL, NULL };
<a name="l03412"></a>03412 
<a name="l03413"></a>03413   acct = purple_buddy_get_account(buddy);
<a name="l03414"></a>03414   gc = purple_account_get_connection(acct);
<a name="l03415"></a>03415   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l03416"></a>03416   srvc = pd-&gt;srvc_conf;
<a name="l03417"></a>03417 
<a name="l03418"></a>03418   f = purple_request_fields_get_field(fields, CHAT_KEY_TOPIC);
<a name="l03419"></a>03419   topic = purple_request_field_string_get_value(f);
<a name="l03420"></a>03420 
<a name="l03421"></a>03421   f = purple_request_fields_get_field(fields, CHAT_KEY_INVITE);
<a name="l03422"></a>03422   invite = purple_request_field_string_get_value(f);
<a name="l03423"></a>03423 
<a name="l03424"></a>03424   conf = mwConference_new(srvc, topic);
<a name="l03425"></a>03425   mwConference_open(conf);
<a name="l03426"></a>03426 
<a name="l03427"></a>03427   idb.user = (<span class="keywordtype">char</span> *)purple_buddy_get_name(buddy);
<a name="l03428"></a>03428   mwConference_invite(conf, &amp;idb, invite);
<a name="l03429"></a>03429 }
<a name="l03430"></a>03430 
<a name="l03431"></a>03431 
<a name="l03432"></a>03432 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_menu_conf_create(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg) {
<a name="l03433"></a>03433 
<a name="l03434"></a>03434   <a class="code" href="struct_purple_request_fields.html">PurpleRequestFields</a> *fields;
<a name="l03435"></a>03435   <a class="code" href="struct_purple_request_field_group.html">PurpleRequestFieldGroup</a> *g;
<a name="l03436"></a>03436   <a class="code" href="struct___purple_request_field.html">PurpleRequestField</a> *f;
<a name="l03437"></a>03437 
<a name="l03438"></a>03438   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l03439"></a>03439   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03440"></a>03440 
<a name="l03441"></a>03441   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgA;
<a name="l03442"></a>03442   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgB;
<a name="l03443"></a>03443   <span class="keywordtype">char</span> *msg1;
<a name="l03444"></a>03444 
<a name="l03445"></a>03445   g_return_if_fail(buddy != NULL);
<a name="l03446"></a>03446 
<a name="l03447"></a>03447   acct = purple_buddy_get_account(buddy);
<a name="l03448"></a>03448   g_return_if_fail(acct != NULL);
<a name="l03449"></a>03449 
<a name="l03450"></a>03450   gc = purple_account_get_connection(acct);
<a name="l03451"></a>03451   g_return_if_fail(gc != NULL);
<a name="l03452"></a>03452 
<a name="l03453"></a>03453   fields = purple_request_fields_new();
<a name="l03454"></a>03454 
<a name="l03455"></a>03455   g = purple_request_field_group_new(NULL);
<a name="l03456"></a>03456   purple_request_fields_add_group(fields, g);
<a name="l03457"></a>03457 
<a name="l03458"></a>03458   f = purple_request_field_string_new(CHAT_KEY_TOPIC, _(<span class="stringliteral">&quot;Topic&quot;</span>), NULL, FALSE);
<a name="l03459"></a>03459   purple_request_field_group_add_field(g, f);
<a name="l03460"></a>03460 
<a name="l03461"></a>03461   f = purple_request_field_string_new(CHAT_KEY_INVITE, _(<span class="stringliteral">&quot;Message&quot;</span>), msg, FALSE);
<a name="l03462"></a>03462   purple_request_field_group_add_field(g, f);
<a name="l03463"></a>03463 
<a name="l03464"></a>03464   msgA = _(<span class="stringliteral">&quot;Create conference with user&quot;</span>);
<a name="l03465"></a>03465   msgB = _(<span class="stringliteral">&quot;Please enter a topic for the new conference, and an invitation&quot;</span>
<a name="l03466"></a>03466            <span class="stringliteral">&quot; message to be sent to %s&quot;</span>);
<a name="l03467"></a>03467   msg1 = g_strdup_printf(msgB, purple_buddy_get_name(buddy));
<a name="l03468"></a>03468 
<a name="l03469"></a>03469   purple_request_fields(gc, _(<span class="stringliteral">&quot;New Conference&quot;</span>),
<a name="l03470"></a>03470                       msgA, msg1, fields,
<a name="l03471"></a>03471                       _(<span class="stringliteral">&quot;Create&quot;</span>), G_CALLBACK(conf_create_prompt_join),
<a name="l03472"></a>03472                       _(<span class="stringliteral">&quot;Cancel&quot;</span>), G_CALLBACK(conf_create_prompt_cancel),
<a name="l03473"></a>03473                           acct, purple_buddy_get_name(buddy), NULL,
<a name="l03474"></a>03474                       buddy);
<a name="l03475"></a>03475   g_free(msg1);
<a name="l03476"></a>03476 }
<a name="l03477"></a>03477 
<a name="l03478"></a>03478 
<a name="l03479"></a>03479 <span class="keyword">static</span> <span class="keywordtype">void</span> conf_select_prompt_cancel(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy,
<a name="l03480"></a>03480                                       <a class="code" href="struct_purple_request_fields.html">PurpleRequestFields</a> *fields) {
<a name="l03481"></a>03481   ;
<a name="l03482"></a>03482 }
<a name="l03483"></a>03483 
<a name="l03484"></a>03484 
<a name="l03485"></a>03485 <span class="keyword">static</span> <span class="keywordtype">void</span> conf_select_prompt_invite(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy,
<a name="l03486"></a>03486                                       <a class="code" href="struct_purple_request_fields.html">PurpleRequestFields</a> *fields) {
<a name="l03487"></a>03487   <a class="code" href="struct___purple_request_field.html">PurpleRequestField</a> *f;
<a name="l03488"></a>03488   GList *l;
<a name="l03489"></a>03489   <span class="keyword">const</span> <span class="keywordtype">char</span> *msg;
<a name="l03490"></a>03490 
<a name="l03491"></a>03491   f = purple_request_fields_get_field(fields, CHAT_KEY_INVITE);
<a name="l03492"></a>03492   msg = purple_request_field_string_get_value(f);
<a name="l03493"></a>03493 
<a name="l03494"></a>03494   f = purple_request_fields_get_field(fields, <span class="stringliteral">&quot;conf&quot;</span>);
<a name="l03495"></a>03495   l = purple_request_field_list_get_selected(f);
<a name="l03496"></a>03496 
<a name="l03497"></a>03497   <span class="keywordflow">if</span>(l) {
<a name="l03498"></a>03498     gpointer d = purple_request_field_list_get_data(f, l-&gt;data);
<a name="l03499"></a>03499 
<a name="l03500"></a>03500     <span class="keywordflow">if</span>(GPOINTER_TO_INT(d) == 0x01) {
<a name="l03501"></a>03501       blist_menu_conf_create(buddy, msg);
<a name="l03502"></a>03502 
<a name="l03503"></a>03503     } <span class="keywordflow">else</span> {
<a name="l03504"></a>03504       <span class="keyword">struct </span>mwIdBlock idb = { (<span class="keywordtype">char</span> *)purple_buddy_get_name(buddy), NULL };
<a name="l03505"></a>03505       mwConference_invite(d, &amp;idb, msg);
<a name="l03506"></a>03506     }
<a name="l03507"></a>03507   }
<a name="l03508"></a>03508 }
<a name="l03509"></a>03509 
<a name="l03510"></a>03510 
<a name="l03511"></a>03511 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_menu_conf_list(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy,
<a name="l03512"></a>03512                                  GList *confs) {
<a name="l03513"></a>03513 
<a name="l03514"></a>03514   <a class="code" href="struct_purple_request_fields.html">PurpleRequestFields</a> *fields;
<a name="l03515"></a>03515   <a class="code" href="struct_purple_request_field_group.html">PurpleRequestFieldGroup</a> *g;
<a name="l03516"></a>03516   <a class="code" href="struct___purple_request_field.html">PurpleRequestField</a> *f;
<a name="l03517"></a>03517 
<a name="l03518"></a>03518   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l03519"></a>03519   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03520"></a>03520 
<a name="l03521"></a>03521   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgA;
<a name="l03522"></a>03522   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgB;
<a name="l03523"></a>03523   <span class="keywordtype">char</span> *msg;
<a name="l03524"></a>03524 
<a name="l03525"></a>03525   acct = purple_buddy_get_account(buddy);
<a name="l03526"></a>03526   g_return_if_fail(acct != NULL);
<a name="l03527"></a>03527 
<a name="l03528"></a>03528   gc = purple_account_get_connection(acct);
<a name="l03529"></a>03529   g_return_if_fail(gc != NULL);
<a name="l03530"></a>03530 
<a name="l03531"></a>03531   fields = purple_request_fields_new();
<a name="l03532"></a>03532 
<a name="l03533"></a>03533   g = purple_request_field_group_new(NULL);
<a name="l03534"></a>03534   purple_request_fields_add_group(fields, g);
<a name="l03535"></a>03535 
<a name="l03536"></a>03536   f = purple_request_field_list_new(<span class="stringliteral">&quot;conf&quot;</span>, _(<span class="stringliteral">&quot;Available Conferences&quot;</span>));
<a name="l03537"></a>03537   purple_request_field_list_set_multi_select(f, FALSE);
<a name="l03538"></a>03538   <span class="keywordflow">for</span>(; confs; confs = confs-&gt;next) {
<a name="l03539"></a>03539     <span class="keyword">struct </span>mwConference *c = confs-&gt;data;
<a name="l03540"></a>03540     purple_request_field_list_add_icon(f, mwConference_getTitle(c), NULL, c);
<a name="l03541"></a>03541   }
<a name="l03542"></a>03542   purple_request_field_list_add_icon(f, _(<span class="stringliteral">&quot;Create New Conference...&quot;</span>),
<a name="l03543"></a>03543                               NULL, GINT_TO_POINTER(0x01));
<a name="l03544"></a>03544   purple_request_field_group_add_field(g, f);
<a name="l03545"></a>03545 
<a name="l03546"></a>03546   f = purple_request_field_string_new(CHAT_KEY_INVITE, <span class="stringliteral">&quot;Message&quot;</span>, NULL, FALSE);
<a name="l03547"></a>03547   purple_request_field_group_add_field(g, f);
<a name="l03548"></a>03548 
<a name="l03549"></a>03549   msgA = _(<span class="stringliteral">&quot;Invite user to a conference&quot;</span>);
<a name="l03550"></a>03550   msgB = _(<span class="stringliteral">&quot;Select a conference from the list below to send an invite to&quot;</span>
<a name="l03551"></a>03551            <span class="stringliteral">&quot; user %s. Select \&quot;Create New Conference\&quot; if you&#39;d like to&quot;</span>
<a name="l03552"></a>03552            <span class="stringliteral">&quot; create a new conference to invite this user to.&quot;</span>);
<a name="l03553"></a>03553   msg = g_strdup_printf(msgB, purple_buddy_get_name(buddy));
<a name="l03554"></a>03554 
<a name="l03555"></a>03555   purple_request_fields(gc, _(<span class="stringliteral">&quot;Invite to Conference&quot;</span>),
<a name="l03556"></a>03556                       msgA, msg, fields,
<a name="l03557"></a>03557                       _(<span class="stringliteral">&quot;Invite&quot;</span>), G_CALLBACK(conf_select_prompt_invite),
<a name="l03558"></a>03558                       _(<span class="stringliteral">&quot;Cancel&quot;</span>), G_CALLBACK(conf_select_prompt_cancel),
<a name="l03559"></a>03559                           acct, purple_buddy_get_name(buddy), NULL,
<a name="l03560"></a>03560                       buddy);
<a name="l03561"></a>03561   g_free(msg);
<a name="l03562"></a>03562 }
<a name="l03563"></a>03563 
<a name="l03564"></a>03564 
<a name="l03565"></a>03565 <span class="keyword">static</span> <span class="keywordtype">void</span> blist_menu_conf(<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *node, gpointer data) {
<a name="l03566"></a>03566   <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy = (<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *) node;
<a name="l03567"></a>03567   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l03568"></a>03568   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03569"></a>03569   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03570"></a>03570   GList *l;
<a name="l03571"></a>03571 
<a name="l03572"></a>03572   g_return_if_fail(node != NULL);
<a name="l03573"></a>03573   g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
<a name="l03574"></a>03574 
<a name="l03575"></a>03575   acct = purple_buddy_get_account(buddy);
<a name="l03576"></a>03576   g_return_if_fail(acct != NULL);
<a name="l03577"></a>03577 
<a name="l03578"></a>03578   gc = purple_account_get_connection(acct);
<a name="l03579"></a>03579   g_return_if_fail(gc != NULL);
<a name="l03580"></a>03580 
<a name="l03581"></a>03581   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l03582"></a>03582   g_return_if_fail(pd != NULL);
<a name="l03583"></a>03583 
<a name="l03584"></a>03584   <span class="comment">/*</span>
<a name="l03585"></a>03585 <span class="comment">    - get a list of all conferences on this session</span>
<a name="l03586"></a>03586 <span class="comment">    - if none, prompt to create one, and invite buddy to it</span>
<a name="l03587"></a>03587 <span class="comment">    - else, prompt to select a conference or create one</span>
<a name="l03588"></a>03588 <span class="comment">  */</span>
<a name="l03589"></a>03589 
<a name="l03590"></a>03590   l = mwServiceConference_getConferences(pd-&gt;srvc_conf);
<a name="l03591"></a>03591   <span class="keywordflow">if</span>(l) {
<a name="l03592"></a>03592     blist_menu_conf_list(buddy, l);
<a name="l03593"></a>03593     g_list_free(l);
<a name="l03594"></a>03594 
<a name="l03595"></a>03595   } <span class="keywordflow">else</span> {
<a name="l03596"></a>03596     blist_menu_conf_create(buddy, NULL);
<a name="l03597"></a>03597   }
<a name="l03598"></a>03598 }
<a name="l03599"></a>03599 
<a name="l03600"></a>03600 
<a name="l03601"></a>03601 <span class="preprocessor">#if 0</span>
<a name="l03602"></a>03602 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> blist_menu_announce(<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *node, gpointer data) {
<a name="l03603"></a>03603   <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy = (<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *) node;
<a name="l03604"></a>03604   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l03605"></a>03605   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03606"></a>03606   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03607"></a>03607   <span class="keyword">struct </span>mwSession *session;
<a name="l03608"></a>03608   <span class="keywordtype">char</span> *rcpt_name;
<a name="l03609"></a>03609   GList *rcpt;
<a name="l03610"></a>03610 
<a name="l03611"></a>03611   g_return_if_fail(node != NULL);
<a name="l03612"></a>03612   g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
<a name="l03613"></a>03613 
<a name="l03614"></a>03614   acct = buddy-&gt;<a class="code" href="struct___purple_buddy.html#a828b4d165f0f0ddf10b200a3ae861238">account</a>;
<a name="l03615"></a>03615   g_return_if_fail(acct != NULL);
<a name="l03616"></a>03616 
<a name="l03617"></a>03617   gc = purple_account_get_connection(acct);
<a name="l03618"></a>03618   g_return_if_fail(gc != NULL);
<a name="l03619"></a>03619 
<a name="l03620"></a>03620   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l03621"></a>03621   g_return_if_fail(pd != NULL);
<a name="l03622"></a>03622 
<a name="l03623"></a>03623   rcpt_name = g_strdup_printf(<span class="stringliteral">&quot;@U %s&quot;</span>, buddy-&gt;<a class="code" href="struct___purple_buddy.html#ac273720de44ae757ce76b27e2e9dc1cb">name</a>);
<a name="l03624"></a>03624   rcpt = g_list_prepend(NULL, rcpt_name);
<a name="l03625"></a>03625 
<a name="l03626"></a>03626   session = pd-&gt;session;
<a name="l03627"></a>03627   mwSession_sendAnnounce(session, FALSE,
<a name="l03628"></a>03628                          <span class="stringliteral">&quot;This is a TEST announcement. Please ignore.&quot;</span>,
<a name="l03629"></a>03629                          rcpt);
<a name="l03630"></a>03630 
<a name="l03631"></a>03631   g_list_free(rcpt);
<a name="l03632"></a>03632   g_free(rcpt_name);
<a name="l03633"></a>03633 }
<a name="l03634"></a>03634 <span class="preprocessor">#endif</span>
<a name="l03635"></a>03635 <span class="preprocessor"></span>
<a name="l03636"></a>03636 
<a name="l03637"></a>03637 <span class="keyword">static</span> GList *mw_prpl_blist_node_menu(<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *node) {
<a name="l03638"></a>03638   GList *l = NULL;
<a name="l03639"></a>03639   <a class="code" href="struct___purple_menu_action.html">PurpleMenuAction</a> *act;
<a name="l03640"></a>03640 
<a name="l03641"></a>03641   <span class="keywordflow">if</span>(! PURPLE_BLIST_NODE_IS_BUDDY(node))
<a name="l03642"></a>03642     <span class="keywordflow">return</span> l;
<a name="l03643"></a>03643 
<a name="l03644"></a>03644   l = g_list_append(l, NULL);
<a name="l03645"></a>03645 
<a name="l03646"></a>03646   act = purple_menu_action_new(_(<span class="stringliteral">&quot;Invite to Conference...&quot;</span>),
<a name="l03647"></a>03647                              PURPLE_CALLBACK(blist_menu_conf), NULL, NULL);
<a name="l03648"></a>03648   l = g_list_append(l, act);
<a name="l03649"></a>03649 
<a name="l03650"></a>03650 <span class="preprocessor">#if 0</span>
<a name="l03651"></a>03651 <span class="preprocessor"></span>  act = purple_menu_action_new(_(<span class="stringliteral">&quot;Send TEST Announcement&quot;</span>),
<a name="l03652"></a>03652                              PURPLE_CALLBACK(blist_menu_announce), NULL, NULL);
<a name="l03653"></a>03653   l = g_list_append(l, act);
<a name="l03654"></a>03654 <span class="preprocessor">#endif</span>
<a name="l03655"></a>03655 <span class="preprocessor"></span>
<a name="l03661"></a>03661   <span class="keywordflow">return</span> l;
<a name="l03662"></a>03662 }
<a name="l03663"></a>03663 
<a name="l03664"></a>03664 
<a name="l03665"></a>03665 <span class="keyword">static</span> GList *mw_prpl_chat_info(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc) {
<a name="l03666"></a>03666   GList *l = NULL;
<a name="l03667"></a>03667   <span class="keyword">struct </span><a class="code" href="structproto__chat__entry.html">proto_chat_entry</a> *pce;
<a name="l03668"></a>03668 
<a name="l03669"></a>03669   pce = g_new0(<span class="keyword">struct</span> <a class="code" href="structproto__chat__entry.html">proto_chat_entry</a>, 1);
<a name="l03670"></a>03670   pce-&gt;<a class="code" href="structproto__chat__entry.html#ab768d3856f2e654a6186ab2412a57184">label</a> = _(<span class="stringliteral">&quot;Topic:&quot;</span>);
<a name="l03671"></a>03671   pce-&gt;<a class="code" href="structproto__chat__entry.html#a55bf097671c4b1f97aba81fa506f6233">identifier</a> = CHAT_KEY_TOPIC;
<a name="l03672"></a>03672   l = g_list_append(l, pce);
<a name="l03673"></a>03673 
<a name="l03674"></a>03674   <span class="keywordflow">return</span> l;
<a name="l03675"></a>03675 }
<a name="l03676"></a>03676 
<a name="l03677"></a>03677 
<a name="l03678"></a>03678 <span class="keyword">static</span> GHashTable *mw_prpl_chat_info_defaults(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l03679"></a>03679                                               <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l03680"></a>03680   GHashTable *table;
<a name="l03681"></a>03681 
<a name="l03682"></a>03682   g_return_val_if_fail(gc != NULL, NULL);
<a name="l03683"></a>03683 
<a name="l03684"></a>03684   table = g_hash_table_new_full(g_str_hash, g_str_equal,
<a name="l03685"></a>03685                                 NULL, g_free);
<a name="l03686"></a>03686 
<a name="l03687"></a>03687   g_hash_table_insert(table, CHAT_KEY_NAME, g_strdup(name));
<a name="l03688"></a>03688   g_hash_table_insert(table, CHAT_KEY_INVITE, NULL);
<a name="l03689"></a>03689 
<a name="l03690"></a>03690   <span class="keywordflow">return</span> table;
<a name="l03691"></a>03691 }
<a name="l03692"></a>03692 
<a name="l03693"></a>03693 
<a name="l03694"></a>03694 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_login(<a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct);
<a name="l03695"></a>03695 
<a name="l03696"></a>03696 
<a name="l03697"></a>03697 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_login(<a class="code" href="struct___purple_account.html">PurpleAccount</a> *account) {
<a name="l03698"></a>03698   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l03699"></a>03699   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03700"></a>03700 
<a name="l03701"></a>03701   <span class="keywordtype">char</span> *user, *pass, *host;
<a name="l03702"></a>03702   guint port;
<a name="l03703"></a>03703 
<a name="l03704"></a>03704   gc = purple_account_get_connection(account);
<a name="l03705"></a>03705   pd = mwPurplePluginData_new(gc);
<a name="l03706"></a>03706 
<a name="l03707"></a>03707   <span class="comment">/* while we do support images, the default is to not offer it */</span>
<a name="l03708"></a>03708   gc-&gt;<a class="code" href="struct___purple_connection.html#a9164f327f3728939f0177bf92cc3d259">flags</a> |= <a class="code" href="connection_8h.html#a5073f95bd10eb9eed84fa58cbf1bb162a41a69a0d47739f58f9f57cfe0cd0117e">PURPLE_CONNECTION_NO_IMAGES</a>;
<a name="l03709"></a>03709 
<a name="l03710"></a>03710   user = g_strdup(purple_account_get_username(account));
<a name="l03711"></a>03711 
<a name="l03712"></a>03712   host = strrchr(user, <span class="charliteral">&#39;:&#39;</span>);
<a name="l03713"></a>03713   <span class="keywordflow">if</span>(host) {
<a name="l03714"></a>03714     <span class="comment">/* annoying user split from 1.2.0, need to undo it */</span>
<a name="l03715"></a>03715     *host++ = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03716"></a>03716     purple_account_set_string(account, MW_KEY_HOST, host);
<a name="l03717"></a>03717     purple_account_set_username(account, user);
<a name="l03718"></a>03718 
<a name="l03719"></a>03719   } <span class="keywordflow">else</span> {
<a name="l03720"></a>03720     host = (<span class="keywordtype">char</span> *) purple_account_get_string(account, MW_KEY_HOST,
<a name="l03721"></a>03721                                             MW_PLUGIN_DEFAULT_HOST);
<a name="l03722"></a>03722   }
<a name="l03723"></a>03723 
<a name="l03724"></a>03724   <span class="keywordflow">if</span>(! host || ! *host) {
<a name="l03725"></a>03725     <span class="comment">/* somehow, we don&#39;t have a host to connect to. Well, we need one</span>
<a name="l03726"></a>03726 <span class="comment">       to actually continue, so let&#39;s ask the user directly. */</span>
<a name="l03727"></a>03727     g_free(user);
<a name="l03728"></a>03728     purple_connection_error_reason(gc,
<a name="l03729"></a>03729             <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4daa0d912f61e368c8d21ff8ab689a9f191">PURPLE_CONNECTION_ERROR_INVALID_SETTINGS</a>,
<a name="l03730"></a>03730             _(<span class="stringliteral">&quot;A server is required to connect this account&quot;</span>));
<a name="l03731"></a>03731     <span class="keywordflow">return</span>;
<a name="l03732"></a>03732   }
<a name="l03733"></a>03733 
<a name="l03734"></a>03734   pass = g_strdup(purple_account_get_password(account));
<a name="l03735"></a>03735   port = purple_account_get_int(account, MW_KEY_PORT, MW_PLUGIN_DEFAULT_PORT);
<a name="l03736"></a>03736 
<a name="l03737"></a>03737   DEBUG_INFO(<span class="stringliteral">&quot;user: &#39;%s&#39;\n&quot;</span>, user);
<a name="l03738"></a>03738   DEBUG_INFO(<span class="stringliteral">&quot;host: &#39;%s&#39;\n&quot;</span>, host);
<a name="l03739"></a>03739   DEBUG_INFO(<span class="stringliteral">&quot;port: %u\n&quot;</span>, port);
<a name="l03740"></a>03740 
<a name="l03741"></a>03741   mwSession_setProperty(pd-&gt;session, mwSession_NO_SECRET,
<a name="l03742"></a>03742                         (<span class="keywordtype">char</span> *) no_secret, NULL);
<a name="l03743"></a>03743   mwSession_setProperty(pd-&gt;session, mwSession_AUTH_USER_ID, user, g_free);
<a name="l03744"></a>03744   mwSession_setProperty(pd-&gt;session, mwSession_AUTH_PASSWORD, pass, g_free);
<a name="l03745"></a>03745 
<a name="l03746"></a>03746   <span class="keywordflow">if</span>(purple_account_get_bool(account, MW_KEY_FAKE_IT, FALSE)) {
<a name="l03747"></a>03747     guint client, major, minor;
<a name="l03748"></a>03748 
<a name="l03749"></a>03749     <span class="comment">/* if we&#39;re faking the login, let&#39;s also fake the version we&#39;re</span>
<a name="l03750"></a>03750 <span class="comment">       reporting. Let&#39;s also allow the actual values to be specified */</span>
<a name="l03751"></a>03751 
<a name="l03752"></a>03752     client = purple_account_get_int(account, MW_KEY_CLIENT, mwLogin_BINARY);
<a name="l03753"></a>03753     major = purple_account_get_int(account, MW_KEY_MAJOR, 0x001e);
<a name="l03754"></a>03754     minor = purple_account_get_int(account, MW_KEY_MINOR, 0x196f);
<a name="l03755"></a>03755 
<a name="l03756"></a>03756     DEBUG_INFO(<span class="stringliteral">&quot;client id: 0x%04x\n&quot;</span>, client);
<a name="l03757"></a>03757     DEBUG_INFO(<span class="stringliteral">&quot;client major: 0x%04x\n&quot;</span>, major);
<a name="l03758"></a>03758     DEBUG_INFO(<span class="stringliteral">&quot;client minor: 0x%04x\n&quot;</span>, minor);
<a name="l03759"></a>03759 
<a name="l03760"></a>03760     mwSession_setProperty(pd-&gt;session, mwSession_CLIENT_TYPE_ID,
<a name="l03761"></a>03761                           GUINT_TO_POINTER(client), NULL);
<a name="l03762"></a>03762 
<a name="l03763"></a>03763     mwSession_setProperty(pd-&gt;session, mwSession_CLIENT_VER_MAJOR,
<a name="l03764"></a>03764                           GUINT_TO_POINTER(major), NULL);
<a name="l03765"></a>03765 
<a name="l03766"></a>03766     mwSession_setProperty(pd-&gt;session, mwSession_CLIENT_VER_MINOR,
<a name="l03767"></a>03767                           GUINT_TO_POINTER(minor), NULL);
<a name="l03768"></a>03768   }
<a name="l03769"></a>03769 
<a name="l03770"></a>03770   purple_connection_update_progress(gc, _(<span class="stringliteral">&quot;Connecting&quot;</span>), 1, MW_CONNECT_STEPS);
<a name="l03771"></a>03771 
<a name="l03772"></a>03772   <span class="keywordflow">if</span> (purple_proxy_connect(gc, account, host, port, connect_cb, pd) == NULL) {
<a name="l03773"></a>03773     purple_connection_error_reason(gc, <a class="code" href="connection_8h.html#ad073b7b1d65488a3b3e39fc382324c4dae83601cb8c581624c7af7dd81b5eaac9">PURPLE_CONNECTION_ERROR_NETWORK_ERROR</a>,
<a name="l03774"></a>03774                                    _(<span class="stringliteral">&quot;Unable to connect&quot;</span>));
<a name="l03775"></a>03775   }
<a name="l03776"></a>03776 }
<a name="l03777"></a>03777 
<a name="l03778"></a>03778 
<a name="l03779"></a>03779 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_close(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc) {
<a name="l03780"></a>03780   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03781"></a>03781 
<a name="l03782"></a>03782   g_return_if_fail(gc != NULL);
<a name="l03783"></a>03783 
<a name="l03784"></a>03784   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l03785"></a>03785   g_return_if_fail(pd != NULL);
<a name="l03786"></a>03786 
<a name="l03787"></a>03787   <span class="comment">/* get rid of the blist save timeout */</span>
<a name="l03788"></a>03788   <span class="keywordflow">if</span>(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#acac54485b7d345e826b6942f5f0186d6">save_event</a>) {
<a name="l03789"></a>03789     <a class="code" href="eventloop_8c.html#aa63215615dfb1d5e8e61612520e5ec27">purple_timeout_remove</a>(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#acac54485b7d345e826b6942f5f0186d6">save_event</a>);
<a name="l03790"></a>03790     pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#acac54485b7d345e826b6942f5f0186d6">save_event</a> = 0;
<a name="l03791"></a>03791     blist_store(pd);
<a name="l03792"></a>03792   }
<a name="l03793"></a>03793 
<a name="l03794"></a>03794   <span class="comment">/* stop the session */</span>
<a name="l03795"></a>03795   mwSession_stop(pd-&gt;session, 0x00);
<a name="l03796"></a>03796 
<a name="l03797"></a>03797   <span class="comment">/* no longer necessary */</span>
<a name="l03798"></a>03798   gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a> = NULL;
<a name="l03799"></a>03799 
<a name="l03800"></a>03800   <span class="comment">/* stop watching the socket */</span>
<a name="l03801"></a>03801   <span class="keywordflow">if</span>(gc-&gt;<a class="code" href="struct___purple_connection.html#a58491547528ab1611acab75d3eccbbbe">inpa</a>) {
<a name="l03802"></a>03802     <a class="code" href="eventloop_8c.html#ae309cb053b0e7984f10d9886367ed84e">purple_input_remove</a>(gc-&gt;<a class="code" href="struct___purple_connection.html#a58491547528ab1611acab75d3eccbbbe">inpa</a>);
<a name="l03803"></a>03803     gc-&gt;<a class="code" href="struct___purple_connection.html#a58491547528ab1611acab75d3eccbbbe">inpa</a> = 0;
<a name="l03804"></a>03804   }
<a name="l03805"></a>03805 
<a name="l03806"></a>03806   <span class="comment">/* clean up the rest */</span>
<a name="l03807"></a>03807   mwPurplePluginData_free(pd);
<a name="l03808"></a>03808 }
<a name="l03809"></a>03809 
<a name="l03810"></a>03810 
<a name="l03811"></a>03811 <span class="keyword">static</span> <span class="keywordtype">int</span> mw_rand(<span class="keywordtype">void</span>) {
<a name="l03812"></a>03812   <span class="keyword">static</span> <span class="keywordtype">int</span> seed = 0;
<a name="l03813"></a>03813 
<a name="l03814"></a>03814   <span class="comment">/* for diversity, not security. don&#39;t touch */</span>
<a name="l03815"></a>03815   srand(time(NULL) ^ seed);
<a name="l03816"></a>03816   seed = rand();
<a name="l03817"></a>03817 
<a name="l03818"></a>03818   <span class="keywordflow">return</span> seed;
<a name="l03819"></a>03819 }
<a name="l03820"></a>03820 
<a name="l03821"></a>03821 
<a name="l03823"></a>03823 <span class="keyword">static</span> <span class="keywordtype">char</span> *im_mime_content_id(<span class="keywordtype">void</span>) {
<a name="l03824"></a>03824   <span class="keywordflow">return</span> g_strdup_printf(<span class="stringliteral">&quot;%03x@%05xmeanwhile&quot;</span>,
<a name="l03825"></a>03825                          mw_rand() &amp; 0xfff, mw_rand() &amp; 0xfffff);
<a name="l03826"></a>03826 }
<a name="l03827"></a>03827 
<a name="l03828"></a>03828 
<a name="l03831"></a>03831 <span class="keyword">static</span> <span class="keywordtype">char</span> *im_mime_content_type(<span class="keywordtype">void</span>) {
<a name="l03832"></a>03832   <span class="keywordflow">return</span> g_strdup_printf(<span class="stringliteral">&quot;multipart/related; boundary=related_MW%03x_%04x&quot;</span>,
<a name="l03833"></a>03833                          mw_rand() &amp; 0xfff, mw_rand() &amp; 0xffff);
<a name="l03834"></a>03834 }
<a name="l03835"></a>03835 
<a name="l03836"></a>03836 
<a name="l03839"></a>03839 <span class="keyword">static</span> <span class="keywordtype">char</span> *im_mime_img_content_type(<a class="code" href="struct___purple_stored_image.html">PurpleStoredImage</a> *img) {
<a name="l03840"></a>03840   <span class="keyword">const</span> <span class="keywordtype">char</span> *fn = purple_imgstore_get_filename(img);
<a name="l03841"></a>03841   <span class="keyword">const</span> <span class="keywordtype">char</span> *ct = NULL;
<a name="l03842"></a>03842 
<a name="l03843"></a>03843   ct = strrchr(fn, <span class="charliteral">&#39;.&#39;</span>);
<a name="l03844"></a>03844   <span class="keywordflow">if</span>(! ct) {
<a name="l03845"></a>03845     ct = <span class="stringliteral">&quot;image&quot;</span>;
<a name="l03846"></a>03846 
<a name="l03847"></a>03847   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(! strcmp(<span class="stringliteral">&quot;.png&quot;</span>, ct)) {
<a name="l03848"></a>03848     ct = <span class="stringliteral">&quot;image/png&quot;</span>;
<a name="l03849"></a>03849 
<a name="l03850"></a>03850   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(! strcmp(<span class="stringliteral">&quot;.jpg&quot;</span>, ct)) {
<a name="l03851"></a>03851     ct = <span class="stringliteral">&quot;image/jpeg&quot;</span>;
<a name="l03852"></a>03852 
<a name="l03853"></a>03853   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(! strcmp(<span class="stringliteral">&quot;.jpeg&quot;</span>, ct)) {
<a name="l03854"></a>03854     ct = <span class="stringliteral">&quot;image/jpeg&quot;</span>;
<a name="l03855"></a>03855 
<a name="l03856"></a>03856   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(! strcmp(<span class="stringliteral">&quot;.gif&quot;</span>, ct)) {
<a name="l03857"></a>03857     ct = <span class="stringliteral">&quot;image/gif&quot;</span>;
<a name="l03858"></a>03858 
<a name="l03859"></a>03859   } <span class="keywordflow">else</span> {
<a name="l03860"></a>03860     ct = <span class="stringliteral">&quot;image&quot;</span>;
<a name="l03861"></a>03861   }
<a name="l03862"></a>03862 
<a name="l03863"></a>03863   <span class="keywordflow">return</span> g_strdup_printf(<span class="stringliteral">&quot;%s; name=\&quot;%s\&quot;&quot;</span>, ct, fn);
<a name="l03864"></a>03864 }
<a name="l03865"></a>03865 
<a name="l03866"></a>03866 
<a name="l03867"></a>03867 <span class="keyword">static</span> <span class="keywordtype">char</span> *im_mime_img_content_disp(<a class="code" href="struct___purple_stored_image.html">PurpleStoredImage</a> *img) {
<a name="l03868"></a>03868   <span class="keyword">const</span> <span class="keywordtype">char</span> *fn = purple_imgstore_get_filename(img);
<a name="l03869"></a>03869   <span class="keywordflow">return</span> g_strdup_printf(<span class="stringliteral">&quot;attachment; filename=\&quot;%s\&quot;&quot;</span>, fn);
<a name="l03870"></a>03870 }
<a name="l03871"></a>03871 
<a name="l03872"></a>03872 
<a name="l03874"></a>03874 <span class="keyword">static</span> <span class="keywordtype">char</span> *im_mime_convert(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l03875"></a>03875                              <span class="keyword">struct</span> mwConversation *conv,
<a name="l03876"></a>03876                              <span class="keyword">const</span> <span class="keywordtype">char</span> *message) {
<a name="l03877"></a>03877   GString *str;
<a name="l03878"></a>03878   <a class="code" href="struct___purple_mime_document.html">PurpleMimeDocument</a> *doc;
<a name="l03879"></a>03879   <a class="code" href="struct___purple_mime_part.html">PurpleMimePart</a> *part;
<a name="l03880"></a>03880 
<a name="l03881"></a>03881   GData *attr;
<a name="l03882"></a>03882   <span class="keywordtype">char</span> *tmp, *start, *end;
<a name="l03883"></a>03883 
<a name="l03884"></a>03884   str = g_string_new(NULL);
<a name="l03885"></a>03885 
<a name="l03886"></a>03886   doc = purple_mime_document_new();
<a name="l03887"></a>03887 
<a name="l03888"></a>03888   purple_mime_document_set_field(doc, <span class="stringliteral">&quot;Mime-Version&quot;</span>, <span class="stringliteral">&quot;1.0&quot;</span>);
<a name="l03889"></a>03889   purple_mime_document_set_field(doc, <span class="stringliteral">&quot;Content-Disposition&quot;</span>, <span class="stringliteral">&quot;inline&quot;</span>);
<a name="l03890"></a>03890 
<a name="l03891"></a>03891   tmp = im_mime_content_type();
<a name="l03892"></a>03892   purple_mime_document_set_field(doc, <span class="stringliteral">&quot;Content-Type&quot;</span>, tmp);
<a name="l03893"></a>03893   g_free(tmp);
<a name="l03894"></a>03894 
<a name="l03895"></a>03895   tmp = (<span class="keywordtype">char</span> *) message;
<a name="l03896"></a>03896   <span class="keywordflow">while</span>(*tmp &amp;&amp; purple_markup_find_tag(<span class="stringliteral">&quot;img&quot;</span>, tmp, (<span class="keyword">const</span> <span class="keywordtype">char</span> **) &amp;start,
<a name="l03897"></a>03897                                      (<span class="keyword">const</span> <span class="keywordtype">char</span> **) &amp;end, &amp;attr)) {
<a name="l03898"></a>03898     <span class="keywordtype">char</span> *id;
<a name="l03899"></a>03899     <a class="code" href="struct___purple_stored_image.html">PurpleStoredImage</a> *img = NULL;
<a name="l03900"></a>03900 
<a name="l03901"></a>03901     gsize len = (start - tmp);
<a name="l03902"></a>03902 
<a name="l03903"></a>03903     <span class="comment">/* append the in-between-tags text */</span>
<a name="l03904"></a>03904     <span class="keywordflow">if</span>(len) g_string_append_len(str, tmp, len);
<a name="l03905"></a>03905 
<a name="l03906"></a>03906     <span class="comment">/* find the imgstore data by the id tag */</span>
<a name="l03907"></a>03907     <span class="keywordtype">id</span> = g_datalist_get_data(&amp;attr, <span class="stringliteral">&quot;id&quot;</span>);
<a name="l03908"></a>03908     <span class="keywordflow">if</span>(<span class="keywordtype">id</span> &amp;&amp; *<span class="keywordtype">id</span>)
<a name="l03909"></a>03909       img = purple_imgstore_find_by_id(atoi(<span class="keywordtype">id</span>));
<a name="l03910"></a>03910 
<a name="l03911"></a>03911     <span class="keywordflow">if</span>(img) {
<a name="l03912"></a>03912       <span class="keywordtype">char</span> *cid;
<a name="l03913"></a>03913       gpointer data;
<a name="l03914"></a>03914       <span class="keywordtype">size_t</span> size;
<a name="l03915"></a>03915 
<a name="l03916"></a>03916       part = purple_mime_part_new(doc);
<a name="l03917"></a>03917 
<a name="l03918"></a>03918       data = im_mime_img_content_disp(img);
<a name="l03919"></a>03919       purple_mime_part_set_field(part, <span class="stringliteral">&quot;Content-Disposition&quot;</span>, data);
<a name="l03920"></a>03920       g_free(data);
<a name="l03921"></a>03921 
<a name="l03922"></a>03922       data = im_mime_img_content_type(img);
<a name="l03923"></a>03923       purple_mime_part_set_field(part, <span class="stringliteral">&quot;Content-Type&quot;</span>, data);
<a name="l03924"></a>03924       g_free(data);
<a name="l03925"></a>03925 
<a name="l03926"></a>03926       cid = im_mime_content_id();
<a name="l03927"></a>03927       data = g_strdup_printf(<span class="stringliteral">&quot;&lt;%s&gt;&quot;</span>, cid);
<a name="l03928"></a>03928       purple_mime_part_set_field(part, <span class="stringliteral">&quot;Content-ID&quot;</span>, data);
<a name="l03929"></a>03929       g_free(data);
<a name="l03930"></a>03930 
<a name="l03931"></a>03931       purple_mime_part_set_field(part, <span class="stringliteral">&quot;Content-transfer-encoding&quot;</span>, <span class="stringliteral">&quot;base64&quot;</span>);
<a name="l03932"></a>03932 
<a name="l03933"></a>03933       <span class="comment">/* obtain and base64 encode the image data, and put it in the</span>
<a name="l03934"></a>03934 <span class="comment">         mime part */</span>
<a name="l03935"></a>03935       size = purple_imgstore_get_size(img);
<a name="l03936"></a>03936       data = purple_base64_encode(purple_imgstore_get_data(img), (gsize) size);
<a name="l03937"></a>03937       purple_mime_part_set_data(part, data);
<a name="l03938"></a>03938       g_free(data);
<a name="l03939"></a>03939 
<a name="l03940"></a>03940       <span class="comment">/* append the modified tag */</span>
<a name="l03941"></a>03941       g_string_append_printf(str, <span class="stringliteral">&quot;&lt;img src=\&quot;cid:%s\&quot;&gt;&quot;</span>, cid);
<a name="l03942"></a>03942       g_free(cid);
<a name="l03943"></a>03943 
<a name="l03944"></a>03944     } <span class="keywordflow">else</span> {
<a name="l03945"></a>03945       <span class="comment">/* append the literal image tag, since we couldn&#39;t find a</span>
<a name="l03946"></a>03946 <span class="comment">         relative imgstore object */</span>
<a name="l03947"></a>03947       gsize len = (end - start) + 1;
<a name="l03948"></a>03948       g_string_append_len(str, start, len);
<a name="l03949"></a>03949     }
<a name="l03950"></a>03950 
<a name="l03951"></a>03951     g_datalist_clear(&amp;attr);
<a name="l03952"></a>03952     tmp = end + 1;
<a name="l03953"></a>03953   }
<a name="l03954"></a>03954 
<a name="l03955"></a>03955   <span class="comment">/* append left-overs */</span>
<a name="l03956"></a>03956   g_string_append(str, tmp);
<a name="l03957"></a>03957 
<a name="l03958"></a>03958   <span class="comment">/* add the text/html part */</span>
<a name="l03959"></a>03959   part = purple_mime_part_new(doc);
<a name="l03960"></a>03960   purple_mime_part_set_field(part, <span class="stringliteral">&quot;Content-Disposition&quot;</span>, <span class="stringliteral">&quot;inline&quot;</span>);
<a name="l03961"></a>03961 
<a name="l03962"></a>03962   tmp = purple_utf8_ncr_encode(str-&gt;str);
<a name="l03963"></a>03963   purple_mime_part_set_field(part, <span class="stringliteral">&quot;Content-Type&quot;</span>, <span class="stringliteral">&quot;text/html&quot;</span>);
<a name="l03964"></a>03964   purple_mime_part_set_field(part, <span class="stringliteral">&quot;Content-Transfer-Encoding&quot;</span>, <span class="stringliteral">&quot;7bit&quot;</span>);
<a name="l03965"></a>03965   purple_mime_part_set_data(part, tmp);
<a name="l03966"></a>03966   g_free(tmp);
<a name="l03967"></a>03967 
<a name="l03968"></a>03968   g_string_free(str, TRUE);
<a name="l03969"></a>03969 
<a name="l03970"></a>03970   str = g_string_new(NULL);
<a name="l03971"></a>03971   purple_mime_document_write(doc, str);
<a name="l03972"></a>03972   tmp = str-&gt;str;
<a name="l03973"></a>03973   g_string_free(str, FALSE);
<a name="l03974"></a>03974 
<a name="l03975"></a>03975   <span class="keywordflow">return</span> tmp;
<a name="l03976"></a>03976 }
<a name="l03977"></a>03977 
<a name="l03978"></a>03978 
<a name="l03979"></a>03979 <span class="keyword">static</span> <span class="keywordtype">int</span> mw_prpl_send_im(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l03980"></a>03980                            <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l03981"></a>03981                            <span class="keyword">const</span> <span class="keywordtype">char</span> *message,
<a name="l03982"></a>03982                            <a class="code" href="conversation_8h.html#a66e44dfdc0de2953d73f03fb806bf6f5">PurpleMessageFlags</a> flags) {
<a name="l03983"></a>03983 
<a name="l03984"></a>03984   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l03985"></a>03985   <span class="keyword">struct </span>mwIdBlock who = { (<span class="keywordtype">char</span> *) name, NULL };
<a name="l03986"></a>03986   <span class="keyword">struct </span>mwConversation *conv;
<a name="l03987"></a>03987 
<a name="l03988"></a>03988   g_return_val_if_fail(gc != NULL, 0);
<a name="l03989"></a>03989   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l03990"></a>03990 
<a name="l03991"></a>03991   g_return_val_if_fail(pd != NULL, 0);
<a name="l03992"></a>03992 
<a name="l03993"></a>03993   conv = mwServiceIm_getConversation(pd-&gt;srvc_im, &amp;who);
<a name="l03994"></a>03994 
<a name="l03995"></a>03995   <span class="comment">/* this detection of features to determine how to send the message</span>
<a name="l03996"></a>03996 <span class="comment">     (plain, html, or mime) is flawed because the other end of the</span>
<a name="l03997"></a>03997 <span class="comment">     conversation could close their channel at any time, rendering any</span>
<a name="l03998"></a>03998 <span class="comment">     existing formatting in an outgoing message innapropriate. The end</span>
<a name="l03999"></a>03999 <span class="comment">     result is that it may be possible that the other side of the</span>
<a name="l04000"></a>04000 <span class="comment">     conversation will receive a plaintext message with html contents,</span>
<a name="l04001"></a>04001 <span class="comment">     which is bad. I&#39;m not sure how to fix this correctly. */</span>
<a name="l04002"></a>04002 
<a name="l04003"></a>04003   <span class="keywordflow">if</span>(strstr(message, <span class="stringliteral">&quot;&lt;img &quot;</span>) || strstr(message, <span class="stringliteral">&quot;&lt;IMG &quot;</span>))
<a name="l04004"></a>04004     flags |= <a class="code" href="conversation_8h.html#a66e44dfdc0de2953d73f03fb806bf6f5a0604e4caeac523e83fdbc3ca749ecff9">PURPLE_MESSAGE_IMAGES</a>;
<a name="l04005"></a>04005 
<a name="l04006"></a>04006   <span class="keywordflow">if</span>(mwConversation_isOpen(conv)) {
<a name="l04007"></a>04007     <span class="keywordtype">char</span> *tmp;
<a name="l04008"></a>04008     <span class="keywordtype">int</span> ret;
<a name="l04009"></a>04009 
<a name="l04010"></a>04010     <span class="keywordflow">if</span>((flags &amp; <a class="code" href="conversation_8h.html#a66e44dfdc0de2953d73f03fb806bf6f5a0604e4caeac523e83fdbc3ca749ecff9">PURPLE_MESSAGE_IMAGES</a>) &amp;&amp;
<a name="l04011"></a>04011        mwConversation_supports(conv, mwImSend_MIME)) {
<a name="l04012"></a>04012       <span class="comment">/* send a MIME message */</span>
<a name="l04013"></a>04013 
<a name="l04014"></a>04014       tmp = im_mime_convert(gc, conv, message);
<a name="l04015"></a>04015       ret = mwConversation_send(conv, mwImSend_MIME, tmp);
<a name="l04016"></a>04016       g_free(tmp);
<a name="l04017"></a>04017 
<a name="l04018"></a>04018     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(mwConversation_supports(conv, mwImSend_HTML)) {
<a name="l04019"></a>04019       <span class="comment">/* send an HTML message */</span>
<a name="l04020"></a>04020 
<a name="l04021"></a>04021       <span class="keywordtype">char</span> *ncr;
<a name="l04022"></a>04022       ncr = purple_utf8_ncr_encode(message);
<a name="l04023"></a>04023       tmp = purple_strdup_withhtml(ncr);
<a name="l04024"></a>04024       g_free(ncr);
<a name="l04025"></a>04025 
<a name="l04026"></a>04026       ret = mwConversation_send(conv, mwImSend_HTML, tmp);
<a name="l04027"></a>04027       g_free(tmp);
<a name="l04028"></a>04028 
<a name="l04029"></a>04029     } <span class="keywordflow">else</span> {
<a name="l04030"></a>04030       <span class="comment">/* default to text */</span>
<a name="l04031"></a>04031       tmp = purple_markup_strip_html(message);
<a name="l04032"></a>04032       ret = mwConversation_send(conv, mwImSend_PLAIN, tmp);
<a name="l04033"></a>04033       g_free(tmp);
<a name="l04034"></a>04034     }
<a name="l04035"></a>04035 
<a name="l04036"></a>04036     <span class="keywordflow">return</span> !ret;
<a name="l04037"></a>04037 
<a name="l04038"></a>04038   } <span class="keywordflow">else</span> {
<a name="l04039"></a>04039 
<a name="l04040"></a>04040     <span class="comment">/* queue up the message safely as plain text */</span>
<a name="l04041"></a>04041     <span class="keywordtype">char</span> *tmp = purple_markup_strip_html(message);
<a name="l04042"></a>04042     convo_queue(conv, mwImSend_PLAIN, tmp);
<a name="l04043"></a>04043     g_free(tmp);
<a name="l04044"></a>04044 
<a name="l04045"></a>04045     <span class="keywordflow">if</span>(! mwConversation_isPending(conv))
<a name="l04046"></a>04046       mwConversation_open(conv);
<a name="l04047"></a>04047 
<a name="l04048"></a>04048     <span class="keywordflow">return</span> 1;
<a name="l04049"></a>04049   }
<a name="l04050"></a>04050 }
<a name="l04051"></a>04051 
<a name="l04052"></a>04052 
<a name="l04053"></a>04053 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mw_prpl_send_typing(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04054"></a>04054                                         <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l04055"></a>04055                                         <a class="code" href="conversation_8h.html#a044cde1e74c50154fefcd358c723850a">PurpleTypingState</a> state) {
<a name="l04056"></a>04056 
<a name="l04057"></a>04057   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04058"></a>04058   <span class="keyword">struct </span>mwIdBlock who = { (<span class="keywordtype">char</span> *) name, NULL };
<a name="l04059"></a>04059   <span class="keyword">struct </span>mwConversation *conv;
<a name="l04060"></a>04060 
<a name="l04061"></a>04061   gpointer t = GINT_TO_POINTER(!! state);
<a name="l04062"></a>04062 
<a name="l04063"></a>04063   g_return_val_if_fail(gc != NULL, 0);
<a name="l04064"></a>04064   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04065"></a>04065 
<a name="l04066"></a>04066   g_return_val_if_fail(pd != NULL, 0);
<a name="l04067"></a>04067 
<a name="l04068"></a>04068   conv = mwServiceIm_getConversation(pd-&gt;srvc_im, &amp;who);
<a name="l04069"></a>04069 
<a name="l04070"></a>04070   <span class="keywordflow">if</span>(mwConversation_isOpen(conv)) {
<a name="l04071"></a>04071     mwConversation_send(conv, mwImSend_TYPING, t);
<a name="l04072"></a>04072 
<a name="l04073"></a>04073   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>((state == <a class="code" href="conversation_8h.html#a044cde1e74c50154fefcd358c723850aa998088bd59e5db26328d0c3b901b9ed0">PURPLE_TYPING</a>) || (state == <a class="code" href="conversation_8h.html#a044cde1e74c50154fefcd358c723850aabd61ce7e36171fb25170356a633af7d5">PURPLE_TYPED</a>)) {
<a name="l04074"></a>04074     <span class="comment">/* only open a channel for sending typing notification, not for</span>
<a name="l04075"></a>04075 <span class="comment">       when typing has stopped. There&#39;s no point in re-opening a</span>
<a name="l04076"></a>04076 <span class="comment">       channel just to tell someone that this side isn&#39;t typing. */</span>
<a name="l04077"></a>04077 
<a name="l04078"></a>04078     convo_queue(conv, mwImSend_TYPING, t);
<a name="l04079"></a>04079 
<a name="l04080"></a>04080     <span class="keywordflow">if</span>(! mwConversation_isPending(conv)) {
<a name="l04081"></a>04081       mwConversation_open(conv);
<a name="l04082"></a>04082     }
<a name="l04083"></a>04083   }
<a name="l04084"></a>04084 
<a name="l04085"></a>04085   <span class="keywordflow">return</span> 0;
<a name="l04086"></a>04086 }
<a name="l04087"></a>04087 
<a name="l04088"></a>04088 
<a name="l04089"></a>04089 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *mw_client_name(guint16 type) {
<a name="l04090"></a>04090   <span class="keywordflow">switch</span>(type) {
<a name="l04091"></a>04091   <span class="keywordflow">case</span> mwLogin_LIB:
<a name="l04092"></a>04092     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Lotus Binary Library&quot;</span>;
<a name="l04093"></a>04093 
<a name="l04094"></a>04094   <span class="keywordflow">case</span> mwLogin_JAVA_WEB:
<a name="l04095"></a>04095     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Lotus Java Client Applet&quot;</span>;
<a name="l04096"></a>04096 
<a name="l04097"></a>04097   <span class="keywordflow">case</span> mwLogin_BINARY:
<a name="l04098"></a>04098     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Lotus Sametime Connect&quot;</span>;
<a name="l04099"></a>04099 
<a name="l04100"></a>04100   <span class="keywordflow">case</span> mwLogin_JAVA_APP:
<a name="l04101"></a>04101     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Lotus Java Client Application&quot;</span>;
<a name="l04102"></a>04102 
<a name="l04103"></a>04103   <span class="keywordflow">case</span> mwLogin_LINKS:
<a name="l04104"></a>04104     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Lotus Sametime Links&quot;</span>;
<a name="l04105"></a>04105 
<a name="l04106"></a>04106   <span class="keywordflow">case</span> mwLogin_NOTES_6_5:
<a name="l04107"></a>04107   <span class="keywordflow">case</span> mwLogin_NOTES_6_5_3:
<a name="l04108"></a>04108   <span class="keywordflow">case</span> mwLogin_NOTES_7_0_beta:
<a name="l04109"></a>04109   <span class="keywordflow">case</span> mwLogin_NOTES_7_0:
<a name="l04110"></a>04110     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Lotus Notes Client&quot;</span>;
<a name="l04111"></a>04111 
<a name="l04112"></a>04112   <span class="keywordflow">case</span> mwLogin_ICT:
<a name="l04113"></a>04113   <span class="keywordflow">case</span> mwLogin_ICT_1_7_8_2:
<a name="l04114"></a>04114   <span class="keywordflow">case</span> mwLogin_ICT_SIP:
<a name="l04115"></a>04115     <span class="keywordflow">return</span> <span class="stringliteral">&quot;IBM Community Tools&quot;</span>;
<a name="l04116"></a>04116 
<a name="l04117"></a>04117   <span class="keywordflow">case</span> mwLogin_NOTESBUDDY_4_14:
<a name="l04118"></a>04118   <span class="keywordflow">case</span> mwLogin_NOTESBUDDY_4_15:
<a name="l04119"></a>04119   <span class="keywordflow">case</span> mwLogin_NOTESBUDDY_4_16:
<a name="l04120"></a>04120     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Alphaworks NotesBuddy&quot;</span>;
<a name="l04121"></a>04121 
<a name="l04122"></a>04122   <span class="keywordflow">case</span> 0x1305:
<a name="l04123"></a>04123   <span class="keywordflow">case</span> 0x1306:
<a name="l04124"></a>04124   <span class="keywordflow">case</span> 0x1307:
<a name="l04125"></a>04125     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Lotus Sametime Connect 7.5&quot;</span>;
<a name="l04126"></a>04126 
<a name="l04127"></a>04127   <span class="keywordflow">case</span> mwLogin_SANITY:
<a name="l04128"></a>04128     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Sanity&quot;</span>;
<a name="l04129"></a>04129 
<a name="l04130"></a>04130   <span class="keywordflow">case</span> mwLogin_ST_PERL:
<a name="l04131"></a>04131     <span class="keywordflow">return</span> <span class="stringliteral">&quot;ST-Send-Message&quot;</span>;
<a name="l04132"></a>04132 
<a name="l04133"></a>04133   <span class="keywordflow">case</span> mwLogin_TRILLIAN:
<a name="l04134"></a>04134   <span class="keywordflow">case</span> mwLogin_TRILLIAN_IBM:
<a name="l04135"></a>04135     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Trillian&quot;</span>;
<a name="l04136"></a>04136 
<a name="l04137"></a>04137   <span class="keywordflow">case</span> mwLogin_MEANWHILE:
<a name="l04138"></a>04138     <span class="keywordflow">return</span> <span class="stringliteral">&quot;Meanwhile&quot;</span>;
<a name="l04139"></a>04139 
<a name="l04140"></a>04140   <span class="keywordflow">default</span>:
<a name="l04141"></a>04141     <span class="keywordflow">return</span> NULL;
<a name="l04142"></a>04142   }
<a name="l04143"></a>04143 }
<a name="l04144"></a>04144 
<a name="l04145"></a>04145 
<a name="l04146"></a>04146 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_get_info(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">const</span> <span class="keywordtype">char</span> *who) {
<a name="l04147"></a>04147 
<a name="l04148"></a>04148   <span class="keyword">struct </span>mwAwareIdBlock idb = { mwAware_USER, (<span class="keywordtype">char</span> *) who, NULL };
<a name="l04149"></a>04149 
<a name="l04150"></a>04150   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04151"></a>04151   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l04152"></a>04152   <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *b;
<a name="l04153"></a>04153   <a class="code" href="struct___purple_notify_user_info.html">PurpleNotifyUserInfo</a> *user_info;
<a name="l04154"></a>04154   <span class="keywordtype">char</span> *tmp;
<a name="l04155"></a>04155   <span class="keyword">const</span> <span class="keywordtype">char</span> *tmp2;
<a name="l04156"></a>04156 
<a name="l04157"></a>04157   g_return_if_fail(who != NULL);
<a name="l04158"></a>04158   g_return_if_fail(*who != <span class="charliteral">&#39;\0&#39;</span>);
<a name="l04159"></a>04159 
<a name="l04160"></a>04160   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04161"></a>04161 
<a name="l04162"></a>04162   acct = purple_connection_get_account(gc);
<a name="l04163"></a>04163   b = purple_find_buddy(acct, who);
<a name="l04164"></a>04164   user_info = purple_notify_user_info_new();
<a name="l04165"></a>04165 
<a name="l04166"></a>04166   <span class="keywordflow">if</span>(purple_str_has_prefix(who, <span class="stringliteral">&quot;@E &quot;</span>)) {
<a name="l04167"></a>04167         purple_notify_user_info_add_pair(user_info, _(<span class="stringliteral">&quot;External User&quot;</span>), NULL);
<a name="l04168"></a>04168   }
<a name="l04169"></a>04169 
<a name="l04170"></a>04170   purple_notify_user_info_add_pair(user_info, _(<span class="stringliteral">&quot;User ID&quot;</span>), who);
<a name="l04171"></a>04171 
<a name="l04172"></a>04172   <span class="keywordflow">if</span>(b) {
<a name="l04173"></a>04173     guint32 type;
<a name="l04174"></a>04174 
<a name="l04175"></a>04175     <span class="keywordflow">if</span>(purple_buddy_get_server_alias(b)) {
<a name="l04176"></a>04176                 purple_notify_user_info_add_pair(user_info, _(<span class="stringliteral">&quot;Full Name&quot;</span>), purple_buddy_get_server_alias(b));
<a name="l04177"></a>04177     }
<a name="l04178"></a>04178 
<a name="l04179"></a>04179     type = purple_blist_node_get_int((<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) b, BUDDY_KEY_CLIENT);
<a name="l04180"></a>04180     <span class="keywordflow">if</span>(type) {
<a name="l04181"></a>04181           tmp = g_strdup(mw_client_name(type));
<a name="l04182"></a>04182           <span class="keywordflow">if</span> (!tmp)
<a name="l04183"></a>04183                 tmp = g_strdup_printf(_(<span class="stringliteral">&quot;Unknown (0x%04x)&lt;br&gt;&quot;</span>), type);
<a name="l04184"></a>04184 
<a name="l04185"></a>04185           purple_notify_user_info_add_pair(user_info, _(<span class="stringliteral">&quot;Last Known Client&quot;</span>), tmp);
<a name="l04186"></a>04186 
<a name="l04187"></a>04187           g_free(tmp);
<a name="l04188"></a>04188     }
<a name="l04189"></a>04189   }
<a name="l04190"></a>04190 
<a name="l04191"></a>04191   tmp = user_supports_text(pd-&gt;srvc_aware, who);
<a name="l04192"></a>04192   <span class="keywordflow">if</span>(tmp) {
<a name="l04193"></a>04193         purple_notify_user_info_add_pair(user_info, _(<span class="stringliteral">&quot;Supports&quot;</span>), tmp);
<a name="l04194"></a>04194         g_free(tmp);
<a name="l04195"></a>04195   }
<a name="l04196"></a>04196 
<a name="l04197"></a>04197   <span class="keywordflow">if</span>(b) {
<a name="l04198"></a>04198         purple_notify_user_info_add_pair(user_info, _(<span class="stringliteral">&quot;Status&quot;</span>), status_text(b));
<a name="l04199"></a>04199 
<a name="l04200"></a>04200         <span class="comment">/* XXX Is this adding a status message in its own section rather than with the &quot;Status&quot; label? */</span>
<a name="l04201"></a>04201     tmp2 = mwServiceAware_getText(pd-&gt;srvc_aware, &amp;idb);
<a name="l04202"></a>04202     <span class="keywordflow">if</span>(tmp2 &amp;&amp; g_utf8_validate(tmp2, -1, NULL)) {
<a name="l04203"></a>04203       tmp = g_markup_escape_text(tmp2, -1);
<a name="l04204"></a>04204           purple_notify_user_info_add_section_break(user_info);
<a name="l04205"></a>04205           purple_notify_user_info_add_pair(user_info, NULL, tmp);
<a name="l04206"></a>04206       g_free(tmp);
<a name="l04207"></a>04207     }
<a name="l04208"></a>04208   }
<a name="l04209"></a>04209 
<a name="l04210"></a>04210   <span class="comment">/* @todo emit a signal to allow a plugin to override the display of</span>
<a name="l04211"></a>04211 <span class="comment">     this notification, so that it can create its own */</span>
<a name="l04212"></a>04212 
<a name="l04213"></a>04213   purple_notify_userinfo(gc, who, user_info, NULL, NULL);
<a name="l04214"></a>04214   purple_notify_user_info_destroy(user_info);
<a name="l04215"></a>04215 }
<a name="l04216"></a>04216 
<a name="l04217"></a>04217 
<a name="l04218"></a>04218 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_set_status(<a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct, <a class="code" href="struct___purple_status.html">PurpleStatus</a> *status) {
<a name="l04219"></a>04219   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l04220"></a>04220   <span class="keyword">const</span> <span class="keywordtype">char</span> *state;
<a name="l04221"></a>04221   <span class="keywordtype">char</span> *message = NULL;
<a name="l04222"></a>04222   <span class="keyword">struct </span>mwSession *session;
<a name="l04223"></a>04223   <span class="keyword">struct </span>mwUserStatus stat;
<a name="l04224"></a>04224 
<a name="l04225"></a>04225   g_return_if_fail(acct != NULL);
<a name="l04226"></a>04226   gc = purple_account_get_connection(acct);
<a name="l04227"></a>04227 
<a name="l04228"></a>04228   state = purple_status_get_id(status);
<a name="l04229"></a>04229 
<a name="l04230"></a>04230   DEBUG_INFO(<span class="stringliteral">&quot;Set status to %s\n&quot;</span>, purple_status_get_name(status));
<a name="l04231"></a>04231 
<a name="l04232"></a>04232   g_return_if_fail(gc != NULL);
<a name="l04233"></a>04233 
<a name="l04234"></a>04234   session = gc_to_session(gc);
<a name="l04235"></a>04235   g_return_if_fail(session != NULL);
<a name="l04236"></a>04236 
<a name="l04237"></a>04237   <span class="comment">/* get a working copy of the current status */</span>
<a name="l04238"></a>04238   mwUserStatus_clone(&amp;stat, mwSession_getUserStatus(session));
<a name="l04239"></a>04239 
<a name="l04240"></a>04240   <span class="comment">/* determine the state */</span>
<a name="l04241"></a>04241   <span class="keywordflow">if</span>(! strcmp(state, MW_STATE_ACTIVE)) {
<a name="l04242"></a>04242     stat.status = mwStatus_ACTIVE;
<a name="l04243"></a>04243 
<a name="l04244"></a>04244   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(! strcmp(state, MW_STATE_AWAY)) {
<a name="l04245"></a>04245     stat.status = mwStatus_AWAY;
<a name="l04246"></a>04246 
<a name="l04247"></a>04247   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(! strcmp(state, MW_STATE_BUSY)) {
<a name="l04248"></a>04248     stat.status = mwStatus_BUSY;
<a name="l04249"></a>04249   }
<a name="l04250"></a>04250 
<a name="l04251"></a>04251   <span class="comment">/* determine the message */</span>
<a name="l04252"></a>04252   message = (<span class="keywordtype">char</span> *) purple_status_get_attr_string(status, MW_STATE_MESSAGE);
<a name="l04253"></a>04253 
<a name="l04254"></a>04254   <span class="keywordflow">if</span>(message) {
<a name="l04255"></a>04255     <span class="comment">/* all the possible non-NULL values of message up to this point</span>
<a name="l04256"></a>04256 <span class="comment">       are const, so we don&#39;t need to free them */</span>
<a name="l04257"></a>04257     message = purple_markup_strip_html(message);
<a name="l04258"></a>04258   }
<a name="l04259"></a>04259 
<a name="l04260"></a>04260   <span class="comment">/* out with the old */</span>
<a name="l04261"></a>04261   g_free(stat.desc);
<a name="l04262"></a>04262 
<a name="l04263"></a>04263   <span class="comment">/* in with the new */</span>
<a name="l04264"></a>04264   stat.desc = (<span class="keywordtype">char</span> *) message;
<a name="l04265"></a>04265 
<a name="l04266"></a>04266   mwSession_setUserStatus(session, &amp;stat);
<a name="l04267"></a>04267   mwUserStatus_clear(&amp;stat);
<a name="l04268"></a>04268 }
<a name="l04269"></a>04269 
<a name="l04270"></a>04270 
<a name="l04271"></a>04271 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_set_idle(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keywordtype">int</span> t) {
<a name="l04272"></a>04272   <span class="keyword">struct </span>mwSession *session;
<a name="l04273"></a>04273   <span class="keyword">struct </span>mwUserStatus stat;
<a name="l04274"></a>04274 
<a name="l04275"></a>04275 
<a name="l04276"></a>04276   session = gc_to_session(gc);
<a name="l04277"></a>04277   g_return_if_fail(session != NULL);
<a name="l04278"></a>04278 
<a name="l04279"></a>04279   mwUserStatus_clone(&amp;stat, mwSession_getUserStatus(session));
<a name="l04280"></a>04280 
<a name="l04281"></a>04281   <span class="keywordflow">if</span>(t) {
<a name="l04282"></a>04282     time_t now = time(NULL);
<a name="l04283"></a>04283     stat.time = now - t;
<a name="l04284"></a>04284 
<a name="l04285"></a>04285   } <span class="keywordflow">else</span> {
<a name="l04286"></a>04286     stat.time = 0;
<a name="l04287"></a>04287   }
<a name="l04288"></a>04288 
<a name="l04289"></a>04289   <span class="keywordflow">if</span>(t &gt; 0 &amp;&amp; stat.status == mwStatus_ACTIVE) {
<a name="l04290"></a>04290     <span class="comment">/* we were active and went idle, so change the status to IDLE. */</span>
<a name="l04291"></a>04291     stat.status = mwStatus_IDLE;
<a name="l04292"></a>04292 
<a name="l04293"></a>04293   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t == 0 &amp;&amp; stat.status == mwStatus_IDLE) {
<a name="l04294"></a>04294     <span class="comment">/* we only become idle automatically, so change back to ACTIVE */</span>
<a name="l04295"></a>04295     stat.status = mwStatus_ACTIVE;
<a name="l04296"></a>04296   }
<a name="l04297"></a>04297 
<a name="l04298"></a>04298   mwSession_setUserStatus(session, &amp;stat);
<a name="l04299"></a>04299   mwUserStatus_clear(&amp;stat);
<a name="l04300"></a>04300 }
<a name="l04301"></a>04301 
<a name="l04302"></a>04302 
<a name="l04303"></a>04303 <span class="keyword">static</span> <span class="keywordtype">void</span> notify_im(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, GList *row, <span class="keywordtype">void</span> *user_data) {
<a name="l04304"></a>04304   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l04305"></a>04305   <a class="code" href="struct___purple_conversation.html">PurpleConversation</a> *conv;
<a name="l04306"></a>04306   <span class="keywordtype">char</span> *id;
<a name="l04307"></a>04307 
<a name="l04308"></a>04308   acct = purple_connection_get_account(gc);
<a name="l04309"></a>04309   <span class="keywordtype">id</span> = g_list_nth_data(row, 1);
<a name="l04310"></a>04310   conv = purple_find_conversation_with_account(<a class="code" href="conversation_8h.html#a9e9f3ae232444332eb34f16aef64f721a4e1c3df052e10fb1b3789ce5925496ab">PURPLE_CONV_TYPE_IM</a>, <span class="keywordtype">id</span>, acct);
<a name="l04311"></a>04311   <span class="keywordflow">if</span>(! conv) conv = purple_conversation_new(<a class="code" href="conversation_8h.html#a9e9f3ae232444332eb34f16aef64f721a4e1c3df052e10fb1b3789ce5925496ab">PURPLE_CONV_TYPE_IM</a>, acct, <span class="keywordtype">id</span>);
<a name="l04312"></a>04312   purple_conversation_present(conv);
<a name="l04313"></a>04313 }
<a name="l04314"></a>04314 
<a name="l04315"></a>04315 
<a name="l04316"></a>04316 <span class="keyword">static</span> <span class="keywordtype">void</span> notify_add(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, GList *row, <span class="keywordtype">void</span> *user_data) {
<a name="l04317"></a>04317   <a class="code" href="struct_buddy_add_data.html">BuddyAddData</a> *data = user_data;
<a name="l04318"></a>04318   <span class="keyword">const</span> <span class="keywordtype">char</span> *group_name = NULL;
<a name="l04319"></a>04319 
<a name="l04320"></a>04320   <span class="keywordflow">if</span> (data &amp;&amp; data-&gt;group) {
<a name="l04321"></a>04321     group_name = purple_group_get_name(data-&gt;group);
<a name="l04322"></a>04322   }
<a name="l04323"></a>04323 
<a name="l04324"></a>04324   purple_blist_request_add_buddy(purple_connection_get_account(gc),
<a name="l04325"></a>04325                                g_list_nth_data(row, 1), group_name,
<a name="l04326"></a>04326                                g_list_nth_data(row, 0));
<a name="l04327"></a>04327 }
<a name="l04328"></a>04328 
<a name="l04329"></a>04329 
<a name="l04330"></a>04330 <span class="keyword">static</span> <span class="keywordtype">void</span> notify_close(gpointer data) {
<a name="l04331"></a>04331   <span class="keywordflow">if</span> (data) {
<a name="l04332"></a>04332     g_free(data);
<a name="l04333"></a>04333   }
<a name="l04334"></a>04334 }
<a name="l04335"></a>04335 
<a name="l04336"></a>04336 
<a name="l04337"></a>04337 <span class="keyword">static</span> <span class="keywordtype">void</span> multi_resolved_query(<span class="keyword">struct</span> mwResolveResult *result,
<a name="l04338"></a>04338                                  <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, gpointer data) {
<a name="l04339"></a>04339   GList *l;
<a name="l04340"></a>04340   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgA;
<a name="l04341"></a>04341   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgB;
<a name="l04342"></a>04342   <span class="keywordtype">char</span> *msg;
<a name="l04343"></a>04343 
<a name="l04344"></a>04344   <a class="code" href="struct_purple_notify_search_results.html">PurpleNotifySearchResults</a> *sres;
<a name="l04345"></a>04345   <a class="code" href="struct_purple_notify_search_column.html">PurpleNotifySearchColumn</a> *scol;
<a name="l04346"></a>04346 
<a name="l04347"></a>04347   sres = purple_notify_searchresults_new();
<a name="l04348"></a>04348 
<a name="l04349"></a>04349   scol = purple_notify_searchresults_column_new(_(<span class="stringliteral">&quot;User Name&quot;</span>));
<a name="l04350"></a>04350   purple_notify_searchresults_column_add(sres, scol);
<a name="l04351"></a>04351 
<a name="l04352"></a>04352   scol = purple_notify_searchresults_column_new(_(<span class="stringliteral">&quot;Sametime ID&quot;</span>));
<a name="l04353"></a>04353   purple_notify_searchresults_column_add(sres, scol);
<a name="l04354"></a>04354 
<a name="l04355"></a>04355   purple_notify_searchresults_button_add(sres, PURPLE_NOTIFY_BUTTON_IM,
<a name="l04356"></a>04356                                        notify_im);
<a name="l04357"></a>04357 
<a name="l04358"></a>04358   purple_notify_searchresults_button_add(sres, PURPLE_NOTIFY_BUTTON_ADD,
<a name="l04359"></a>04359                                        notify_add);
<a name="l04360"></a>04360 
<a name="l04361"></a>04361   <span class="keywordflow">for</span>(l = result-&gt;matches; l; l = l-&gt;next) {
<a name="l04362"></a>04362     <span class="keyword">struct </span>mwResolveMatch *match = l-&gt;data;
<a name="l04363"></a>04363     GList *row = NULL;
<a name="l04364"></a>04364 
<a name="l04365"></a>04365     DEBUG_INFO(<span class="stringliteral">&quot;multi resolve: %s, %s\n&quot;</span>,
<a name="l04366"></a>04366                NSTR(match-&gt;id), NSTR(match-&gt;name));
<a name="l04367"></a>04367 
<a name="l04368"></a>04368     <span class="keywordflow">if</span>(!match-&gt;id || !match-&gt;name)
<a name="l04369"></a>04369       <span class="keywordflow">continue</span>;
<a name="l04370"></a>04370 
<a name="l04371"></a>04371     row = g_list_append(row, g_strdup(match-&gt;name));
<a name="l04372"></a>04372     row = g_list_append(row, g_strdup(match-&gt;id));
<a name="l04373"></a>04373     purple_notify_searchresults_row_add(sres, row);
<a name="l04374"></a>04374   }
<a name="l04375"></a>04375 
<a name="l04376"></a>04376   msgA = _(<span class="stringliteral">&quot;An ambiguous user ID was entered&quot;</span>);
<a name="l04377"></a>04377   msgB = _(<span class="stringliteral">&quot;The identifier &#39;%s&#39; may possibly refer to any of the following&quot;</span>
<a name="l04378"></a>04378            <span class="stringliteral">&quot; users. Please select the correct user from the list below to&quot;</span>
<a name="l04379"></a>04379            <span class="stringliteral">&quot; add them to your buddy list.&quot;</span>);
<a name="l04380"></a>04380   msg = g_strdup_printf(msgB, result-&gt;name);
<a name="l04381"></a>04381 
<a name="l04382"></a>04382   purple_notify_searchresults(gc, _(<span class="stringliteral">&quot;Select User&quot;</span>),
<a name="l04383"></a>04383                             msgA, msg, sres, notify_close, data);
<a name="l04384"></a>04384 
<a name="l04385"></a>04385   g_free(msg);
<a name="l04386"></a>04386 }
<a name="l04387"></a>04387 
<a name="l04388"></a>04388 
<a name="l04389"></a>04389 <span class="keyword">static</span> <span class="keywordtype">void</span> add_buddy_resolved(<span class="keyword">struct</span> mwServiceResolve *srvc,
<a name="l04390"></a>04390                                guint32 <span class="keywordtype">id</span>, guint32 code, GList *results,
<a name="l04391"></a>04391                                gpointer b) {
<a name="l04392"></a>04392 
<a name="l04393"></a>04393   <span class="keyword">struct </span>mwResolveResult *res = NULL;
<a name="l04394"></a>04394   <a class="code" href="struct_buddy_add_data.html">BuddyAddData</a> *data = b;
<a name="l04395"></a>04395   <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy = NULL;
<a name="l04396"></a>04396   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l04397"></a>04397   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04398"></a>04398 
<a name="l04399"></a>04399   g_return_if_fail(data != NULL);
<a name="l04400"></a>04400 
<a name="l04401"></a>04401   buddy = data-&gt;buddy;
<a name="l04402"></a>04402 
<a name="l04403"></a>04403   gc = purple_account_get_connection(purple_buddy_get_account(buddy));
<a name="l04404"></a>04404   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04405"></a>04405 
<a name="l04406"></a>04406   <span class="keywordflow">if</span>(results)
<a name="l04407"></a>04407     res = results-&gt;data;
<a name="l04408"></a>04408 
<a name="l04409"></a>04409   <span class="keywordflow">if</span>(!code &amp;&amp; res &amp;&amp; res-&gt;matches) {
<a name="l04410"></a>04410     <span class="keywordflow">if</span>(!res-&gt;matches-&gt;next) {
<a name="l04411"></a>04411       <span class="keyword">struct </span>mwResolveMatch *match = res-&gt;matches-&gt;data;
<a name="l04412"></a>04412 
<a name="l04413"></a>04413       <span class="comment">/* only one? that might be the right one! */</span>
<a name="l04414"></a>04414       <span class="keywordflow">if</span>(strcmp(res-&gt;name, match-&gt;id)) {
<a name="l04415"></a>04415         <span class="comment">/* uh oh, the single result isn&#39;t identical to the search</span>
<a name="l04416"></a>04416 <span class="comment">           term, better safe then sorry, so let&#39;s make sure it&#39;s who</span>
<a name="l04417"></a>04417 <span class="comment">           the user meant to add */</span>
<a name="l04418"></a>04418         purple_blist_remove_buddy(buddy);
<a name="l04419"></a>04419         multi_resolved_query(res, gc, data);
<a name="l04420"></a>04420 
<a name="l04421"></a>04421       } <span class="keywordflow">else</span> {
<a name="l04422"></a>04422 
<a name="l04423"></a>04423         <span class="comment">/* same person, set the server alias */</span>
<a name="l04424"></a>04424         purple_blist_server_alias_buddy(buddy, match-&gt;<a class="code" href="struct___purple_buddy.html#ac273720de44ae757ce76b27e2e9dc1cb">name</a>);
<a name="l04425"></a>04425         purple_blist_node_set_string((<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) buddy,
<a name="l04426"></a>04426                                    BUDDY_KEY_NAME, match-&gt;<a class="code" href="struct___purple_buddy.html#ac273720de44ae757ce76b27e2e9dc1cb">name</a>);
<a name="l04427"></a>04427 
<a name="l04428"></a>04428         <span class="comment">/* subscribe to awareness */</span>
<a name="l04429"></a>04429         buddy_add(pd, buddy);
<a name="l04430"></a>04430 
<a name="l04431"></a>04431         blist_schedule(pd);
<a name="l04432"></a>04432 
<a name="l04433"></a>04433         g_free(data);
<a name="l04434"></a>04434       }
<a name="l04435"></a>04435 
<a name="l04436"></a>04436     } <span class="keywordflow">else</span> {
<a name="l04437"></a>04437       <span class="comment">/* prompt user if more than one match was returned */</span>
<a name="l04438"></a>04438       purple_blist_remove_buddy(buddy);
<a name="l04439"></a>04439       multi_resolved_query(res, gc, data);
<a name="l04440"></a>04440     }
<a name="l04441"></a>04441 
<a name="l04442"></a>04442     <span class="keywordflow">return</span>;
<a name="l04443"></a>04443   }
<a name="l04444"></a>04444 
<a name="l04445"></a>04445 <span class="preprocessor">#if 0</span>
<a name="l04446"></a>04446 <span class="preprocessor"></span>  <span class="comment">/* fall-through indicates that we couldn&#39;t find a matching user in</span>
<a name="l04447"></a>04447 <span class="comment">     the resolve service (ether error or zero results), so we remove</span>
<a name="l04448"></a>04448 <span class="comment">     this buddy */</span>
<a name="l04449"></a>04449 
<a name="l04450"></a>04450   <span class="comment">/* note: I can&#39;t really think of a good reason to alter the buddy</span>
<a name="l04451"></a>04451 <span class="comment">     list in any way. There has been at least one report where the</span>
<a name="l04452"></a>04452 <span class="comment">     resolve service isn&#39;t returning correct results anyway, so let&#39;s</span>
<a name="l04453"></a>04453 <span class="comment">     just leave them in the list. I&#39;m just going to if0 this section</span>
<a name="l04454"></a>04454 <span class="comment">     out unless I can think of a very good reason to do this. -siege */</span>
<a name="l04455"></a>04455 
<a name="l04456"></a>04456   DEBUG_INFO(<span class="stringliteral">&quot;no such buddy in community\n&quot;</span>);
<a name="l04457"></a>04457   purple_blist_remove_buddy(buddy);
<a name="l04458"></a>04458   blist_schedule(pd);
<a name="l04459"></a>04459 
<a name="l04460"></a>04460   <span class="keywordflow">if</span>(res &amp;&amp; res-&gt;name) {
<a name="l04461"></a>04461     <span class="comment">/* compose and display an error message */</span>
<a name="l04462"></a>04462     <span class="keyword">const</span> <span class="keywordtype">char</span> *msgA;
<a name="l04463"></a>04463     <span class="keyword">const</span> <span class="keywordtype">char</span> *msgB;
<a name="l04464"></a>04464     <span class="keywordtype">char</span> *msg;
<a name="l04465"></a>04465 
<a name="l04466"></a>04466     msgA = _(<span class="stringliteral">&quot;Unable to add user: user not found&quot;</span>);
<a name="l04467"></a>04467 
<a name="l04468"></a>04468     msgB = _(<span class="stringliteral">&quot;The identifier &#39;%s&#39; did not match any users in your&quot;</span>
<a name="l04469"></a>04469              <span class="stringliteral">&quot; Sametime community. This entry has been removed from&quot;</span>
<a name="l04470"></a>04470              <span class="stringliteral">&quot; your buddy list.&quot;</span>);
<a name="l04471"></a>04471     msg = g_strdup_printf(msgB, NSTR(res-&gt;name));
<a name="l04472"></a>04472 
<a name="l04473"></a>04473     <a class="code" href="notify_8h.html#ad54861c382f50702e2c6c2317aff878d">purple_notify_error</a>(gc, _(<span class="stringliteral">&quot;Unable to add user&quot;</span>), msgA, msg);
<a name="l04474"></a>04474 
<a name="l04475"></a>04475     g_free(msg);
<a name="l04476"></a>04476   }
<a name="l04477"></a>04477 <span class="preprocessor">#endif</span>
<a name="l04478"></a>04478 <span class="preprocessor"></span>}
<a name="l04479"></a>04479 
<a name="l04480"></a>04480 
<a name="l04481"></a>04481 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_add_buddy(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04482"></a>04482                               <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy,
<a name="l04483"></a>04483                               <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group) {
<a name="l04484"></a>04484 
<a name="l04485"></a>04485   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04486"></a>04486   <span class="keyword">struct </span>mwServiceResolve *srvc;
<a name="l04487"></a>04487   GList *query;
<a name="l04488"></a>04488   <span class="keyword">enum</span> mwResolveFlag flags;
<a name="l04489"></a>04489   guint32 req;
<a name="l04490"></a>04490   <a class="code" href="struct_buddy_add_data.html">BuddyAddData</a> *data;
<a name="l04491"></a>04491 
<a name="l04492"></a>04492   <span class="comment">/* catch external buddies. They won&#39;t be in the resolve service */</span>
<a name="l04493"></a>04493   <span class="keywordflow">if</span>(buddy_is_external(buddy)) {
<a name="l04494"></a>04494     buddy_add(pd, buddy);
<a name="l04495"></a>04495     <span class="keywordflow">return</span>;
<a name="l04496"></a>04496   }
<a name="l04497"></a>04497 
<a name="l04498"></a>04498   data = g_new0(<a class="code" href="struct_buddy_add_data.html">BuddyAddData</a>, 1);
<a name="l04499"></a>04499   data-&gt;buddy = buddy;
<a name="l04500"></a>04500   data-&gt;group = group;
<a name="l04501"></a>04501 
<a name="l04502"></a>04502   srvc = pd-&gt;srvc_resolve;
<a name="l04503"></a>04503 
<a name="l04504"></a>04504   query = g_list_prepend(NULL, (<span class="keywordtype">char</span> *)purple_buddy_get_name(buddy));
<a name="l04505"></a>04505   flags = mwResolveFlag_FIRST | mwResolveFlag_USERS;
<a name="l04506"></a>04506 
<a name="l04507"></a>04507   req = mwServiceResolve_resolve(srvc, query, flags, add_buddy_resolved,
<a name="l04508"></a>04508                                  data, NULL);
<a name="l04509"></a>04509   g_list_free(query);
<a name="l04510"></a>04510 
<a name="l04511"></a>04511   <span class="keywordflow">if</span>(req == SEARCH_ERROR) {
<a name="l04512"></a>04512     purple_blist_remove_buddy(buddy);
<a name="l04513"></a>04513     blist_schedule(pd);
<a name="l04514"></a>04514   }
<a name="l04515"></a>04515 }
<a name="l04516"></a>04516 
<a name="l04517"></a>04517 
<a name="l04518"></a>04518 <span class="keyword">static</span> <span class="keywordtype">void</span> foreach_add_buddies(<a class="code" href="struct___purple_group.html">PurpleGroup</a> *group, GList *buddies,
<a name="l04519"></a>04519                                 <span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd) {
<a name="l04520"></a>04520   <span class="keyword">struct </span>mwAwareList *list;
<a name="l04521"></a>04521 
<a name="l04522"></a>04522   list = list_ensure(pd, group);
<a name="l04523"></a>04523   mwAwareList_addAware(list, buddies);
<a name="l04524"></a>04524   g_list_free(buddies);
<a name="l04525"></a>04525 }
<a name="l04526"></a>04526 
<a name="l04527"></a>04527 
<a name="l04528"></a>04528 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_add_buddies(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04529"></a>04529                                 GList *buddies,
<a name="l04530"></a>04530                                 GList *groups) {
<a name="l04531"></a>04531 
<a name="l04532"></a>04532   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04533"></a>04533   GHashTable *group_sets;
<a name="l04534"></a>04534   <span class="keyword">struct </span>mwAwareIdBlock *idbs, *idb;
<a name="l04535"></a>04535 
<a name="l04536"></a>04536   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04537"></a>04537 
<a name="l04538"></a>04538   <span class="comment">/* map PurpleGroup:GList of mwAwareIdBlock */</span>
<a name="l04539"></a>04539   group_sets = g_hash_table_new(g_direct_hash, g_direct_equal);
<a name="l04540"></a>04540 
<a name="l04541"></a>04541   <span class="comment">/* bunch of mwAwareIdBlock allocated at once, free&#39;d at once */</span>
<a name="l04542"></a>04542   idb = idbs = g_new(<span class="keyword">struct</span> mwAwareIdBlock, g_list_length(buddies));
<a name="l04543"></a>04543 
<a name="l04544"></a>04544   <span class="comment">/* first pass collects mwAwareIdBlock lists for each group */</span>
<a name="l04545"></a>04545   <span class="keywordflow">for</span>(; buddies; buddies = buddies-&gt;next) {
<a name="l04546"></a>04546     <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *b = buddies-&gt;data;
<a name="l04547"></a>04547     <a class="code" href="struct___purple_group.html">PurpleGroup</a> *g;
<a name="l04548"></a>04548     <span class="keyword">const</span> <span class="keywordtype">char</span> *fn;
<a name="l04549"></a>04549     GList *l;
<a name="l04550"></a>04550 
<a name="l04551"></a>04551     <span class="comment">/* nab the saved server alias and stick it on the buddy */</span>
<a name="l04552"></a>04552     fn = purple_blist_node_get_string((<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) b, BUDDY_KEY_NAME);
<a name="l04553"></a>04553     purple_blist_server_alias_buddy(b, fn);
<a name="l04554"></a>04554 
<a name="l04555"></a>04555     <span class="comment">/* convert PurpleBuddy into a mwAwareIdBlock */</span>
<a name="l04556"></a>04556     idb-&gt;type = mwAware_USER;
<a name="l04557"></a>04557     idb-&gt;user = (<span class="keywordtype">char</span> *) purple_buddy_get_name(b);
<a name="l04558"></a>04558     idb-&gt;community = NULL;
<a name="l04559"></a>04559 
<a name="l04560"></a>04560     <span class="comment">/* put idb into the list associated with the buddy&#39;s group */</span>
<a name="l04561"></a>04561     g = purple_buddy_get_group(b);
<a name="l04562"></a>04562     l = g_hash_table_lookup(group_sets, g);
<a name="l04563"></a>04563     l = g_list_prepend(l, idb++);
<a name="l04564"></a>04564     g_hash_table_insert(group_sets, g, l);
<a name="l04565"></a>04565   }
<a name="l04566"></a>04566 
<a name="l04567"></a>04567   <span class="comment">/* each group&#39;s buddies get added in one shot, and schedule the blist</span>
<a name="l04568"></a>04568 <span class="comment">     for saving */</span>
<a name="l04569"></a>04569   g_hash_table_foreach(group_sets, (GHFunc) foreach_add_buddies, pd);
<a name="l04570"></a>04570   blist_schedule(pd);
<a name="l04571"></a>04571 
<a name="l04572"></a>04572   <span class="comment">/* cleanup */</span>
<a name="l04573"></a>04573   g_hash_table_destroy(group_sets);
<a name="l04574"></a>04574   g_free(idbs);
<a name="l04575"></a>04575 }
<a name="l04576"></a>04576 
<a name="l04577"></a>04577 
<a name="l04578"></a>04578 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_remove_buddy(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04579"></a>04579                                  <a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy, <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group) {
<a name="l04580"></a>04580 
<a name="l04581"></a>04581   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04582"></a>04582   <span class="keyword">struct </span>mwAwareIdBlock idb = { mwAware_USER, (<span class="keywordtype">char</span> *)purple_buddy_get_name(buddy), NULL };
<a name="l04583"></a>04583   <span class="keyword">struct </span>mwAwareList *list;
<a name="l04584"></a>04584 
<a name="l04585"></a>04585   GList *rem = g_list_prepend(NULL, &amp;idb);
<a name="l04586"></a>04586 
<a name="l04587"></a>04587   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04588"></a>04588   group = purple_buddy_get_group(buddy);
<a name="l04589"></a>04589   list = list_ensure(pd, group);
<a name="l04590"></a>04590 
<a name="l04591"></a>04591   mwAwareList_removeAware(list, rem);
<a name="l04592"></a>04592   blist_schedule(pd);
<a name="l04593"></a>04593 
<a name="l04594"></a>04594   g_list_free(rem);
<a name="l04595"></a>04595 }
<a name="l04596"></a>04596 
<a name="l04597"></a>04597 
<a name="l04598"></a>04598 <span class="keyword">static</span> <span class="keywordtype">void</span> privacy_fill(<span class="keyword">struct</span> mwPrivacyInfo *priv,
<a name="l04599"></a>04599                          GSList *members) {
<a name="l04600"></a>04600 
<a name="l04601"></a>04601   <span class="keyword">struct </span>mwUserItem *u;
<a name="l04602"></a>04602   guint count;
<a name="l04603"></a>04603 
<a name="l04604"></a>04604   count = g_slist_length(members);
<a name="l04605"></a>04605   DEBUG_INFO(<span class="stringliteral">&quot;privacy_fill: %u members\n&quot;</span>, count);
<a name="l04606"></a>04606 
<a name="l04607"></a>04607   priv-&gt;count = count;
<a name="l04608"></a>04608   priv-&gt;users = g_new0(<span class="keyword">struct</span> mwUserItem, count);
<a name="l04609"></a>04609 
<a name="l04610"></a>04610   <span class="keywordflow">while</span>(count--) {
<a name="l04611"></a>04611     u = priv-&gt;users + count;
<a name="l04612"></a>04612     u-&gt;id = members-&gt;data;
<a name="l04613"></a>04613     members = members-&gt;next;
<a name="l04614"></a>04614   }
<a name="l04615"></a>04615 }
<a name="l04616"></a>04616 
<a name="l04617"></a>04617 
<a name="l04618"></a>04618 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_set_permit_deny(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc) {
<a name="l04619"></a>04619   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l04620"></a>04620   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04621"></a>04621   <span class="keyword">struct </span>mwSession *session;
<a name="l04622"></a>04622 
<a name="l04623"></a>04623   <span class="keyword">struct </span>mwPrivacyInfo privacy = {
<a name="l04624"></a>04624     FALSE, <span class="comment">/* deny  */</span>
<a name="l04625"></a>04625     0,     <span class="comment">/* count */</span>
<a name="l04626"></a>04626     NULL,  <span class="comment">/* users */</span>
<a name="l04627"></a>04627   };
<a name="l04628"></a>04628 
<a name="l04629"></a>04629   g_return_if_fail(gc != NULL);
<a name="l04630"></a>04630 
<a name="l04631"></a>04631   acct = purple_connection_get_account(gc);
<a name="l04632"></a>04632   g_return_if_fail(acct != NULL);
<a name="l04633"></a>04633 
<a name="l04634"></a>04634   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04635"></a>04635   g_return_if_fail(pd != NULL);
<a name="l04636"></a>04636 
<a name="l04637"></a>04637   session = pd-&gt;session;
<a name="l04638"></a>04638   g_return_if_fail(session != NULL);
<a name="l04639"></a>04639 
<a name="l04640"></a>04640   <span class="keywordflow">switch</span>(acct-&gt;<a class="code" href="struct___purple_account.html#ae8b7e3ecd27a485313e182cb5fdb8c72">perm_deny</a>) {
<a name="l04641"></a>04641   <span class="keywordflow">case</span> PURPLE_PRIVACY_DENY_USERS:
<a name="l04642"></a>04642     DEBUG_INFO(<span class="stringliteral">&quot;PURPLE_PRIVACY_DENY_USERS\n&quot;</span>);
<a name="l04643"></a>04643     privacy_fill(&amp;privacy, acct-&gt;<a class="code" href="struct___purple_account.html#a2ae4cc7ca75d07b1f21fad9ed7f5f265">deny</a>);
<a name="l04644"></a>04644     privacy.deny = TRUE;
<a name="l04645"></a>04645     <span class="keywordflow">break</span>;
<a name="l04646"></a>04646 
<a name="l04647"></a>04647   <span class="keywordflow">case</span> PURPLE_PRIVACY_ALLOW_ALL:
<a name="l04648"></a>04648     DEBUG_INFO(<span class="stringliteral">&quot;PURPLE_PRIVACY_ALLOW_ALL\n&quot;</span>);
<a name="l04649"></a>04649     privacy.deny = TRUE;
<a name="l04650"></a>04650     <span class="keywordflow">break</span>;
<a name="l04651"></a>04651 
<a name="l04652"></a>04652   <span class="keywordflow">case</span> PURPLE_PRIVACY_ALLOW_USERS:
<a name="l04653"></a>04653     DEBUG_INFO(<span class="stringliteral">&quot;PURPLE_PRIVACY_ALLOW_USERS\n&quot;</span>);
<a name="l04654"></a>04654     privacy_fill(&amp;privacy, acct-&gt;<a class="code" href="struct___purple_account.html#abdcff8170459c1ff09ec87d984bf4e7f">permit</a>);
<a name="l04655"></a>04655     privacy.deny = FALSE;
<a name="l04656"></a>04656     <span class="keywordflow">break</span>;
<a name="l04657"></a>04657 
<a name="l04658"></a>04658   <span class="keywordflow">case</span> PURPLE_PRIVACY_DENY_ALL:
<a name="l04659"></a>04659     DEBUG_INFO(<span class="stringliteral">&quot;PURPLE_PRIVACY_DENY_ALL\n&quot;</span>);
<a name="l04660"></a>04660     privacy.deny = FALSE;
<a name="l04661"></a>04661     <span class="keywordflow">break</span>;
<a name="l04662"></a>04662 
<a name="l04663"></a>04663   <span class="keywordflow">default</span>:
<a name="l04664"></a>04664     DEBUG_INFO(<span class="stringliteral">&quot;acct-&gt;perm_deny is 0x%x\n&quot;</span>, acct-&gt;<a class="code" href="struct___purple_account.html#ae8b7e3ecd27a485313e182cb5fdb8c72">perm_deny</a>);
<a name="l04665"></a>04665     <span class="keywordflow">return</span>;
<a name="l04666"></a>04666   }
<a name="l04667"></a>04667 
<a name="l04668"></a>04668   mwSession_setPrivacyInfo(session, &amp;privacy);
<a name="l04669"></a>04669   g_free(privacy.users);
<a name="l04670"></a>04670 }
<a name="l04671"></a>04671 
<a name="l04672"></a>04672 
<a name="l04673"></a>04673 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_add_permit(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l04674"></a>04674   mw_prpl_set_permit_deny(gc);
<a name="l04675"></a>04675 }
<a name="l04676"></a>04676 
<a name="l04677"></a>04677 
<a name="l04678"></a>04678 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_add_deny(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l04679"></a>04679   mw_prpl_set_permit_deny(gc);
<a name="l04680"></a>04680 }
<a name="l04681"></a>04681 
<a name="l04682"></a>04682 
<a name="l04683"></a>04683 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_rem_permit(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l04684"></a>04684   mw_prpl_set_permit_deny(gc);
<a name="l04685"></a>04685 }
<a name="l04686"></a>04686 
<a name="l04687"></a>04687 
<a name="l04688"></a>04688 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_rem_deny(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l04689"></a>04689   mw_prpl_set_permit_deny(gc);
<a name="l04690"></a>04690 }
<a name="l04691"></a>04691 
<a name="l04692"></a>04692 
<a name="l04693"></a>04693 <span class="keyword">static</span> <span class="keyword">struct </span>mwConference *conf_find(<span class="keyword">struct</span> mwServiceConference *srvc,
<a name="l04694"></a>04694                                       <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l04695"></a>04695   GList *l, *ll;
<a name="l04696"></a>04696   <span class="keyword">struct </span>mwConference *conf = NULL;
<a name="l04697"></a>04697 
<a name="l04698"></a>04698   ll = mwServiceConference_getConferences(srvc);
<a name="l04699"></a>04699   <span class="keywordflow">for</span>(l = ll; l; l = l-&gt;next) {
<a name="l04700"></a>04700     <span class="keyword">struct </span>mwConference *c = l-&gt;data;
<a name="l04701"></a>04701     <span class="keywordflow">if</span>(! strcmp(name, mwConference_getName(c))) {
<a name="l04702"></a>04702       conf = c;
<a name="l04703"></a>04703       <span class="keywordflow">break</span>;
<a name="l04704"></a>04704     }
<a name="l04705"></a>04705   }
<a name="l04706"></a>04706   g_list_free(ll);
<a name="l04707"></a>04707 
<a name="l04708"></a>04708   <span class="keywordflow">return</span> conf;
<a name="l04709"></a>04709 }
<a name="l04710"></a>04710 
<a name="l04711"></a>04711 
<a name="l04712"></a>04712 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_join_chat(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04713"></a>04713                               GHashTable *components) {
<a name="l04714"></a>04714 
<a name="l04715"></a>04715   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04716"></a>04716   <span class="keywordtype">char</span> *c, *t;
<a name="l04717"></a>04717 
<a name="l04718"></a>04718   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04719"></a>04719 
<a name="l04720"></a>04720   c = g_hash_table_lookup(components, CHAT_KEY_NAME);
<a name="l04721"></a>04721   t = g_hash_table_lookup(components, CHAT_KEY_TOPIC);
<a name="l04722"></a>04722 
<a name="l04723"></a>04723   <span class="keywordflow">if</span>(g_hash_table_lookup(components, CHAT_KEY_IS_PLACE)) {
<a name="l04724"></a>04724     <span class="comment">/* use place service */</span>
<a name="l04725"></a>04725     <span class="keyword">struct </span>mwServicePlace *srvc;
<a name="l04726"></a>04726     <span class="keyword">struct </span>mwPlace *place = NULL;
<a name="l04727"></a>04727 
<a name="l04728"></a>04728     srvc = pd-&gt;srvc_place;
<a name="l04729"></a>04729     place = mwPlace_new(srvc, c, t);
<a name="l04730"></a>04730     mwPlace_open(place);
<a name="l04731"></a>04731 
<a name="l04732"></a>04732   } <span class="keywordflow">else</span> {
<a name="l04733"></a>04733     <span class="comment">/* use conference service */</span>
<a name="l04734"></a>04734     <span class="keyword">struct </span>mwServiceConference *srvc;
<a name="l04735"></a>04735     <span class="keyword">struct </span>mwConference *conf = NULL;
<a name="l04736"></a>04736 
<a name="l04737"></a>04737     srvc = pd-&gt;srvc_conf;
<a name="l04738"></a>04738     <span class="keywordflow">if</span>(c) conf = conf_find(srvc, c);
<a name="l04739"></a>04739 
<a name="l04740"></a>04740     <span class="keywordflow">if</span>(conf) {
<a name="l04741"></a>04741       DEBUG_INFO(<span class="stringliteral">&quot;accepting conference invitation\n&quot;</span>);
<a name="l04742"></a>04742       mwConference_accept(conf);
<a name="l04743"></a>04743 
<a name="l04744"></a>04744     } <span class="keywordflow">else</span> {
<a name="l04745"></a>04745       DEBUG_INFO(<span class="stringliteral">&quot;creating new conference\n&quot;</span>);
<a name="l04746"></a>04746       conf = mwConference_new(srvc, t);
<a name="l04747"></a>04747       mwConference_open(conf);
<a name="l04748"></a>04748     }
<a name="l04749"></a>04749   }
<a name="l04750"></a>04750 }
<a name="l04751"></a>04751 
<a name="l04752"></a>04752 
<a name="l04753"></a>04753 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_reject_chat(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04754"></a>04754                                 GHashTable *components) {
<a name="l04755"></a>04755 
<a name="l04756"></a>04756   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04757"></a>04757   <span class="keyword">struct </span>mwServiceConference *srvc;
<a name="l04758"></a>04758   <span class="keywordtype">char</span> *c;
<a name="l04759"></a>04759 
<a name="l04760"></a>04760   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04761"></a>04761   srvc = pd-&gt;srvc_conf;
<a name="l04762"></a>04762 
<a name="l04763"></a>04763   <span class="keywordflow">if</span>(g_hash_table_lookup(components, CHAT_KEY_IS_PLACE)) {
<a name="l04764"></a>04764     ; <span class="comment">/* nothing needs doing */</span>
<a name="l04765"></a>04765 
<a name="l04766"></a>04766   } <span class="keywordflow">else</span> {
<a name="l04767"></a>04767     <span class="comment">/* reject conference */</span>
<a name="l04768"></a>04768     c = g_hash_table_lookup(components, CHAT_KEY_NAME);
<a name="l04769"></a>04769     <span class="keywordflow">if</span>(c) {
<a name="l04770"></a>04770       <span class="keyword">struct </span>mwConference *conf = conf_find(srvc, c);
<a name="l04771"></a>04771       <span class="keywordflow">if</span>(conf) mwConference_reject(conf, ERR_SUCCESS, <span class="stringliteral">&quot;Declined&quot;</span>);
<a name="l04772"></a>04772     }
<a name="l04773"></a>04773   }
<a name="l04774"></a>04774 }
<a name="l04775"></a>04775 
<a name="l04776"></a>04776 
<a name="l04777"></a>04777 <span class="keyword">static</span> <span class="keywordtype">char</span> *mw_prpl_get_chat_name(GHashTable *components) {
<a name="l04778"></a>04778   <span class="keywordflow">return</span> g_hash_table_lookup(components, CHAT_KEY_NAME);
<a name="l04779"></a>04779 }
<a name="l04780"></a>04780 
<a name="l04781"></a>04781 
<a name="l04782"></a>04782 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_chat_invite(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04783"></a>04783                                 <span class="keywordtype">int</span> <span class="keywordtype">id</span>,
<a name="l04784"></a>04784                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *invitation,
<a name="l04785"></a>04785                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *who) {
<a name="l04786"></a>04786 
<a name="l04787"></a>04787   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04788"></a>04788   <span class="keyword">struct </span>mwConference *conf;
<a name="l04789"></a>04789   <span class="keyword">struct </span>mwPlace *place;
<a name="l04790"></a>04790   <span class="keyword">struct </span>mwIdBlock idb = { (<span class="keywordtype">char</span> *) who, NULL };
<a name="l04791"></a>04791 
<a name="l04792"></a>04792   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04793"></a>04793   g_return_if_fail(pd != NULL);
<a name="l04794"></a>04794 
<a name="l04795"></a>04795   conf = ID_TO_CONF(pd, <span class="keywordtype">id</span>);
<a name="l04796"></a>04796 
<a name="l04797"></a>04797   <span class="keywordflow">if</span>(conf) {
<a name="l04798"></a>04798     mwConference_invite(conf, &amp;idb, invitation);
<a name="l04799"></a>04799     <span class="keywordflow">return</span>;
<a name="l04800"></a>04800   }
<a name="l04801"></a>04801 
<a name="l04802"></a>04802   place = ID_TO_PLACE(pd, <span class="keywordtype">id</span>);
<a name="l04803"></a>04803   g_return_if_fail(place != NULL);
<a name="l04804"></a>04804 
<a name="l04805"></a>04805   <span class="comment">/* @todo: use the IM service for invitation */</span>
<a name="l04806"></a>04806   mwPlace_legacyInvite(place, &amp;idb, invitation);
<a name="l04807"></a>04807 }
<a name="l04808"></a>04808 
<a name="l04809"></a>04809 
<a name="l04810"></a>04810 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_chat_leave(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04811"></a>04811                                <span class="keywordtype">int</span> <span class="keywordtype">id</span>) {
<a name="l04812"></a>04812 
<a name="l04813"></a>04813   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04814"></a>04814   <span class="keyword">struct </span>mwConference *conf;
<a name="l04815"></a>04815 
<a name="l04816"></a>04816   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04817"></a>04817 
<a name="l04818"></a>04818   g_return_if_fail(pd != NULL);
<a name="l04819"></a>04819   conf = ID_TO_CONF(pd, <span class="keywordtype">id</span>);
<a name="l04820"></a>04820 
<a name="l04821"></a>04821   <span class="keywordflow">if</span>(conf) {
<a name="l04822"></a>04822     mwConference_destroy(conf, ERR_SUCCESS, <span class="stringliteral">&quot;Leaving&quot;</span>);
<a name="l04823"></a>04823 
<a name="l04824"></a>04824   } <span class="keywordflow">else</span> {
<a name="l04825"></a>04825     <span class="keyword">struct </span>mwPlace *place = ID_TO_PLACE(pd, <span class="keywordtype">id</span>);
<a name="l04826"></a>04826     g_return_if_fail(place != NULL);
<a name="l04827"></a>04827 
<a name="l04828"></a>04828     mwPlace_destroy(place, ERR_SUCCESS);
<a name="l04829"></a>04829   }
<a name="l04830"></a>04830 }
<a name="l04831"></a>04831 
<a name="l04832"></a>04832 
<a name="l04833"></a>04833 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_chat_whisper(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04834"></a>04834                                  <span class="keywordtype">int</span> <span class="keywordtype">id</span>,
<a name="l04835"></a>04835                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *who,
<a name="l04836"></a>04836                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *message) {
<a name="l04837"></a>04837 
<a name="l04838"></a>04838   mw_prpl_send_im(gc, who, message, 0);
<a name="l04839"></a>04839 }
<a name="l04840"></a>04840 
<a name="l04841"></a>04841 
<a name="l04842"></a>04842 <span class="keyword">static</span> <span class="keywordtype">int</span> mw_prpl_chat_send(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04843"></a>04843                              <span class="keywordtype">int</span> <span class="keywordtype">id</span>,
<a name="l04844"></a>04844                              <span class="keyword">const</span> <span class="keywordtype">char</span> *message,
<a name="l04845"></a>04845                              <a class="code" href="conversation_8h.html#a66e44dfdc0de2953d73f03fb806bf6f5">PurpleMessageFlags</a> flags) {
<a name="l04846"></a>04846 
<a name="l04847"></a>04847   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04848"></a>04848   <span class="keyword">struct </span>mwConference *conf;
<a name="l04849"></a>04849   <span class="keywordtype">char</span> *msg;
<a name="l04850"></a>04850   <span class="keywordtype">int</span> ret;
<a name="l04851"></a>04851 
<a name="l04852"></a>04852   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04853"></a>04853 
<a name="l04854"></a>04854   g_return_val_if_fail(pd != NULL, 0);
<a name="l04855"></a>04855   conf = ID_TO_CONF(pd, <span class="keywordtype">id</span>);
<a name="l04856"></a>04856 
<a name="l04857"></a>04857   msg = purple_markup_strip_html(message);
<a name="l04858"></a>04858 
<a name="l04859"></a>04859   <span class="keywordflow">if</span>(conf) {
<a name="l04860"></a>04860     ret = ! mwConference_sendText(conf, msg);
<a name="l04861"></a>04861 
<a name="l04862"></a>04862   } <span class="keywordflow">else</span> {
<a name="l04863"></a>04863     <span class="keyword">struct </span>mwPlace *place = ID_TO_PLACE(pd, <span class="keywordtype">id</span>);
<a name="l04864"></a>04864     g_return_val_if_fail(place != NULL, 0);
<a name="l04865"></a>04865 
<a name="l04866"></a>04866     ret = ! mwPlace_sendText(place, msg);
<a name="l04867"></a>04867   }
<a name="l04868"></a>04868 
<a name="l04869"></a>04869   g_free(msg);
<a name="l04870"></a>04870   <span class="keywordflow">return</span> ret;
<a name="l04871"></a>04871 }
<a name="l04872"></a>04872 
<a name="l04873"></a>04873 
<a name="l04874"></a>04874 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_keepalive(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc) {
<a name="l04875"></a>04875   <span class="keyword">struct </span>mwSession *session;
<a name="l04876"></a>04876 
<a name="l04877"></a>04877   g_return_if_fail(gc != NULL);
<a name="l04878"></a>04878 
<a name="l04879"></a>04879   session = gc_to_session(gc);
<a name="l04880"></a>04880   g_return_if_fail(session != NULL);
<a name="l04881"></a>04881 
<a name="l04882"></a>04882   mwSession_sendKeepalive(session);
<a name="l04883"></a>04883 }
<a name="l04884"></a>04884 
<a name="l04885"></a>04885 
<a name="l04886"></a>04886 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_alias_buddy(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04887"></a>04887                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *who,
<a name="l04888"></a>04888                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *alias) {
<a name="l04889"></a>04889 
<a name="l04890"></a>04890   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04891"></a>04891   g_return_if_fail(pd != NULL);
<a name="l04892"></a>04892 
<a name="l04893"></a>04893   <span class="comment">/* it&#39;s a change to the buddy list, so we&#39;ve gotta reflect that in</span>
<a name="l04894"></a>04894 <span class="comment">     the server copy */</span>
<a name="l04895"></a>04895 
<a name="l04896"></a>04896   blist_schedule(pd);
<a name="l04897"></a>04897 }
<a name="l04898"></a>04898 
<a name="l04899"></a>04899 
<a name="l04900"></a>04900 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_group_buddy(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04901"></a>04901                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *who,
<a name="l04902"></a>04902                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *old_group,
<a name="l04903"></a>04903                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *new_group) {
<a name="l04904"></a>04904 
<a name="l04905"></a>04905   <span class="keyword">struct </span>mwAwareIdBlock idb = { mwAware_USER, (<span class="keywordtype">char</span> *) who, NULL };
<a name="l04906"></a>04906   GList *gl = g_list_prepend(NULL, &amp;idb);
<a name="l04907"></a>04907 
<a name="l04908"></a>04908   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04909"></a>04909   <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group;
<a name="l04910"></a>04910   <span class="keyword">struct </span>mwAwareList *list;
<a name="l04911"></a>04911 
<a name="l04912"></a>04912   <span class="comment">/* add who to new_group&#39;s aware list */</span>
<a name="l04913"></a>04913   group = purple_find_group(new_group);
<a name="l04914"></a>04914   list = list_ensure(pd, group);
<a name="l04915"></a>04915   mwAwareList_addAware(list, gl);
<a name="l04916"></a>04916 
<a name="l04917"></a>04917   <span class="comment">/* remove who from old_group&#39;s aware list */</span>
<a name="l04918"></a>04918   group = purple_find_group(old_group);
<a name="l04919"></a>04919   list = list_ensure(pd, group);
<a name="l04920"></a>04920   mwAwareList_removeAware(list, gl);
<a name="l04921"></a>04921 
<a name="l04922"></a>04922   g_list_free(gl);
<a name="l04923"></a>04923 
<a name="l04924"></a>04924   <span class="comment">/* schedule the changes to be saved */</span>
<a name="l04925"></a>04925   blist_schedule(pd);
<a name="l04926"></a>04926 }
<a name="l04927"></a>04927 
<a name="l04928"></a>04928 
<a name="l04929"></a>04929 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_rename_group(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l04930"></a>04930                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *old,
<a name="l04931"></a>04931                                  <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group,
<a name="l04932"></a>04932                                  GList *buddies) {
<a name="l04933"></a>04933 
<a name="l04934"></a>04934   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04935"></a>04935   g_return_if_fail(pd != NULL);
<a name="l04936"></a>04936 
<a name="l04937"></a>04937   <span class="comment">/* it&#39;s a change in the buddy list, so we&#39;ve gotta reflect that in</span>
<a name="l04938"></a>04938 <span class="comment">     the server copy. Also, having this function should prevent all</span>
<a name="l04939"></a>04939 <span class="comment">     those buddies from being removed and re-added. We don&#39;t really</span>
<a name="l04940"></a>04940 <span class="comment">     give a crap what the group is named in Purple other than to record</span>
<a name="l04941"></a>04941 <span class="comment">     that as the group name/alias */</span>
<a name="l04942"></a>04942 
<a name="l04943"></a>04943   blist_schedule(pd);
<a name="l04944"></a>04944 }
<a name="l04945"></a>04945 
<a name="l04946"></a>04946 
<a name="l04947"></a>04947 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_buddy_free(<a class="code" href="struct___purple_buddy.html">PurpleBuddy</a> *buddy) {
<a name="l04948"></a>04948   <span class="comment">/* I don&#39;t think we have any cleanup for buddies yet */</span>
<a name="l04949"></a>04949   ;
<a name="l04950"></a>04950 }
<a name="l04951"></a>04951 
<a name="l04952"></a>04952 
<a name="l04953"></a>04953 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_convo_closed(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">const</span> <span class="keywordtype">char</span> *who) {
<a name="l04954"></a>04954   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04955"></a>04955   <span class="keyword">struct </span>mwServiceIm *srvc;
<a name="l04956"></a>04956   <span class="keyword">struct </span>mwConversation *conv;
<a name="l04957"></a>04957   <span class="keyword">struct </span>mwIdBlock idb = { (<span class="keywordtype">char</span> *) who, NULL };
<a name="l04958"></a>04958 
<a name="l04959"></a>04959   g_return_if_fail(pd != NULL);
<a name="l04960"></a>04960 
<a name="l04961"></a>04961   srvc = pd-&gt;srvc_im;
<a name="l04962"></a>04962   g_return_if_fail(srvc != NULL);
<a name="l04963"></a>04963 
<a name="l04964"></a>04964   conv = mwServiceIm_findConversation(srvc, &amp;idb);
<a name="l04965"></a>04965   <span class="keywordflow">if</span>(! conv) <span class="keywordflow">return</span>;
<a name="l04966"></a>04966 
<a name="l04967"></a>04967   <span class="keywordflow">if</span>(mwConversation_isOpen(conv))
<a name="l04968"></a>04968     mwConversation_free(conv);
<a name="l04969"></a>04969 }
<a name="l04970"></a>04970 
<a name="l04971"></a>04971 
<a name="l04972"></a>04972 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *mw_prpl_normalize(<span class="keyword">const</span> <a class="code" href="struct___purple_account.html">PurpleAccount</a> *account,
<a name="l04973"></a>04973                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>) {
<a name="l04974"></a>04974 
<a name="l04975"></a>04975   <span class="comment">/* code elsewhere assumes that the return value points to different</span>
<a name="l04976"></a>04976 <span class="comment">     memory than the passed value, but it won&#39;t free the normalized</span>
<a name="l04977"></a>04977 <span class="comment">     data. wtf? */</span>
<a name="l04978"></a>04978 
<a name="l04979"></a>04979   <span class="keyword">static</span> <span class="keywordtype">char</span> buf[BUF_LEN];
<a name="l04980"></a>04980   g_strlcpy(buf, <span class="keywordtype">id</span>, <span class="keyword">sizeof</span>(buf));
<a name="l04981"></a>04981   <span class="keywordflow">return</span> buf;
<a name="l04982"></a>04982 }
<a name="l04983"></a>04983 
<a name="l04984"></a>04984 
<a name="l04985"></a>04985 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_remove_group(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group) {
<a name="l04986"></a>04986   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l04987"></a>04987   <span class="keyword">struct </span>mwAwareList *list;
<a name="l04988"></a>04988 
<a name="l04989"></a>04989   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l04990"></a>04990   g_return_if_fail(pd != NULL);
<a name="l04991"></a>04991   g_return_if_fail(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">group_list_map</a> != NULL);
<a name="l04992"></a>04992 
<a name="l04993"></a>04993   list = g_hash_table_lookup(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">group_list_map</a>, group);
<a name="l04994"></a>04994 
<a name="l04995"></a>04995   <span class="keywordflow">if</span>(list) {
<a name="l04996"></a>04996     g_hash_table_remove(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">group_list_map</a>, list);
<a name="l04997"></a>04997     g_hash_table_remove(pd-&gt;<a class="code" href="structmw_purple_plugin_data.html#a6b0e27b92afd08fdda01756417059507">group_list_map</a>, group);
<a name="l04998"></a>04998     mwAwareList_free(list);
<a name="l04999"></a>04999 
<a name="l05000"></a>05000     blist_schedule(pd);
<a name="l05001"></a>05001   }
<a name="l05002"></a>05002 }
<a name="l05003"></a>05003 
<a name="l05004"></a>05004 
<a name="l05005"></a>05005 <span class="keyword">static</span> gboolean mw_prpl_can_receive_file(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l05006"></a>05006                                          <span class="keyword">const</span> <span class="keywordtype">char</span> *who) {
<a name="l05007"></a>05007   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l05008"></a>05008   <span class="keyword">struct </span>mwServiceAware *srvc;
<a name="l05009"></a>05009   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l05010"></a>05010 
<a name="l05011"></a>05011   g_return_val_if_fail(gc != NULL, FALSE);
<a name="l05012"></a>05012 
<a name="l05013"></a>05013   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l05014"></a>05014   g_return_val_if_fail(pd != NULL, FALSE);
<a name="l05015"></a>05015 
<a name="l05016"></a>05016   srvc = pd-&gt;srvc_aware;
<a name="l05017"></a>05017   g_return_val_if_fail(srvc != NULL, FALSE);
<a name="l05018"></a>05018 
<a name="l05019"></a>05019   acct = purple_connection_get_account(gc);
<a name="l05020"></a>05020   g_return_val_if_fail(acct != NULL, FALSE);
<a name="l05021"></a>05021 
<a name="l05022"></a>05022   <span class="keywordflow">return</span> purple_find_buddy(acct, who) &amp;&amp;
<a name="l05023"></a>05023     user_supports(srvc, who, mwAttribute_FILE_TRANSFER);
<a name="l05024"></a>05024 }
<a name="l05025"></a>05025 
<a name="l05026"></a>05026 
<a name="l05027"></a>05027 <span class="keyword">static</span> <span class="keywordtype">void</span> ft_outgoing_init(<a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer) {
<a name="l05028"></a>05028   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l05029"></a>05029   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l05030"></a>05030 
<a name="l05031"></a>05031   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l05032"></a>05032   <span class="keyword">struct </span>mwServiceFileTransfer *srvc;
<a name="l05033"></a>05033   <span class="keyword">struct </span>mwFileTransfer *ft;
<a name="l05034"></a>05034 
<a name="l05035"></a>05035   <span class="keyword">const</span> <span class="keywordtype">char</span> *filename;
<a name="l05036"></a>05036   gsize filesize;
<a name="l05037"></a>05037   FILE *fp;
<a name="l05038"></a>05038 
<a name="l05039"></a>05039   <span class="keyword">struct </span>mwIdBlock idb = { NULL, NULL };
<a name="l05040"></a>05040 
<a name="l05041"></a>05041   DEBUG_INFO(<span class="stringliteral">&quot;ft_outgoing_init\n&quot;</span>);
<a name="l05042"></a>05042 
<a name="l05043"></a>05043   acct = purple_xfer_get_account(xfer);
<a name="l05044"></a>05044   gc = purple_account_get_connection(acct);
<a name="l05045"></a>05045   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l05046"></a>05046   srvc = pd-&gt;srvc_ft;
<a name="l05047"></a>05047 
<a name="l05048"></a>05048   filename = purple_xfer_get_local_filename(xfer);
<a name="l05049"></a>05049   filesize = purple_xfer_get_size(xfer);
<a name="l05050"></a>05050   idb.user = xfer-&gt;<a class="code" href="struct___purple_xfer.html#a7cabb2ac275cd724643036d13ba7d6c0">who</a>;
<a name="l05051"></a>05051 
<a name="l05052"></a>05052   purple_xfer_update_progress(xfer);
<a name="l05053"></a>05053 
<a name="l05054"></a>05054   <span class="comment">/* test that we can actually send the file */</span>
<a name="l05055"></a>05055   fp = g_fopen(filename, <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l05056"></a>05056   <span class="keywordflow">if</span>(! fp) {
<a name="l05057"></a>05057     <span class="keywordtype">char</span> *msg = g_strdup_printf(_(<span class="stringliteral">&quot;Error reading file %s: \n%s\n&quot;</span>),
<a name="l05058"></a>05058                                 filename, g_strerror(errno));
<a name="l05059"></a>05059     purple_xfer_error(purple_xfer_get_type(xfer), acct, xfer-&gt;<a class="code" href="struct___purple_xfer.html#a7cabb2ac275cd724643036d13ba7d6c0">who</a>, msg);
<a name="l05060"></a>05060     g_free(msg);
<a name="l05061"></a>05061     <span class="keywordflow">return</span>;
<a name="l05062"></a>05062   }
<a name="l05063"></a>05063   fclose(fp);
<a name="l05064"></a>05064 
<a name="l05065"></a>05065   {
<a name="l05066"></a>05066     <span class="keywordtype">char</span> *tmp = strrchr(filename, G_DIR_SEPARATOR);
<a name="l05067"></a>05067     <span class="keywordflow">if</span>(tmp++) filename = tmp;
<a name="l05068"></a>05068   }
<a name="l05069"></a>05069 
<a name="l05070"></a>05070   ft = mwFileTransfer_new(srvc, &amp;idb, NULL, filename, filesize);
<a name="l05071"></a>05071 
<a name="l05072"></a>05072   purple_xfer_ref(xfer);
<a name="l05073"></a>05073   mwFileTransfer_setClientData(ft, xfer, (GDestroyNotify) purple_xfer_unref);
<a name="l05074"></a>05074   xfer-&gt;<a class="code" href="struct___purple_xfer.html#a4ce7ab5aaa647508c1eb9ba1593afeda">data</a> = ft;
<a name="l05075"></a>05075 
<a name="l05076"></a>05076   mwFileTransfer_offer(ft);
<a name="l05077"></a>05077 }
<a name="l05078"></a>05078 
<a name="l05079"></a>05079 
<a name="l05080"></a>05080 <span class="keyword">static</span> <span class="keywordtype">void</span> ft_outgoing_cancel(<a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer) {
<a name="l05081"></a>05081   <span class="keyword">struct </span>mwFileTransfer *ft = xfer-&gt;<a class="code" href="struct___purple_xfer.html#a4ce7ab5aaa647508c1eb9ba1593afeda">data</a>;
<a name="l05082"></a>05082 
<a name="l05083"></a>05083   DEBUG_INFO(<span class="stringliteral">&quot;ft_outgoing_cancel called\n&quot;</span>);
<a name="l05084"></a>05084 
<a name="l05085"></a>05085   <span class="keywordflow">if</span>(ft) mwFileTransfer_cancel(ft);
<a name="l05086"></a>05086 }
<a name="l05087"></a>05087 
<a name="l05088"></a>05088 
<a name="l05089"></a>05089 <span class="keyword">static</span> <a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *mw_prpl_new_xfer(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">const</span> <span class="keywordtype">char</span> *who) {
<a name="l05090"></a>05090   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l05091"></a>05091   <a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer;
<a name="l05092"></a>05092 
<a name="l05093"></a>05093   acct = purple_connection_get_account(gc);
<a name="l05094"></a>05094 
<a name="l05095"></a>05095   xfer = purple_xfer_new(acct, <a class="code" href="ft_8h.html#a78fc08b8e8082913b7d7c92bacc12356ac52c4c9694591c04ad151e913a716f9a">PURPLE_XFER_SEND</a>, who);
<a name="l05096"></a>05096   <span class="keywordflow">if</span> (xfer)
<a name="l05097"></a>05097   {
<a name="l05098"></a>05098     purple_xfer_set_init_fnc(xfer, ft_outgoing_init);
<a name="l05099"></a>05099     purple_xfer_set_cancel_send_fnc(xfer, ft_outgoing_cancel);
<a name="l05100"></a>05100   }
<a name="l05101"></a>05101 
<a name="l05102"></a>05102   <span class="keywordflow">return</span> xfer;
<a name="l05103"></a>05103 }
<a name="l05104"></a>05104 
<a name="l05105"></a>05105 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_prpl_send_file(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc,
<a name="l05106"></a>05106                               <span class="keyword">const</span> <span class="keywordtype">char</span> *who, <span class="keyword">const</span> <span class="keywordtype">char</span> *file) {
<a name="l05107"></a>05107 
<a name="l05108"></a>05108   <a class="code" href="struct___purple_xfer.html">PurpleXfer</a> *xfer = mw_prpl_new_xfer(gc, who);
<a name="l05109"></a>05109 
<a name="l05110"></a>05110   <span class="keywordflow">if</span>(file) {
<a name="l05111"></a>05111     DEBUG_INFO(<span class="stringliteral">&quot;file != NULL\n&quot;</span>);
<a name="l05112"></a>05112     purple_xfer_request_accepted(xfer, file);
<a name="l05113"></a>05113 
<a name="l05114"></a>05114   } <span class="keywordflow">else</span> {
<a name="l05115"></a>05115     DEBUG_INFO(<span class="stringliteral">&quot;file == NULL\n&quot;</span>);
<a name="l05116"></a>05116     purple_xfer_request(xfer);
<a name="l05117"></a>05117   }
<a name="l05118"></a>05118 }
<a name="l05119"></a>05119 
<a name="l05120"></a>05120 
<a name="l05121"></a>05121 <span class="keyword">static</span> <a class="code" href="struct___purple_plugin_protocol_info.html">PurplePluginProtocolInfo</a> mw_prpl_info = {
<a name="l05122"></a>05122   <a class="code" href="prpl_8h.html#a766e7a0dcfe8c92068ecca710456fd02ac794e518230f003dd7cea6e38e2e6608">OPT_PROTO_IM_IMAGE</a>,
<a name="l05123"></a>05123   NULL, <span class="comment">/*&lt; set in mw_plugin_init */</span>
<a name="l05124"></a>05124   NULL, <span class="comment">/*&lt; set in mw_plugin_init */</span>
<a name="l05125"></a>05125   <a class="code" href="prpl_8h.html#a64f315135de197dc4e6757ffe5bf1c8d">NO_BUDDY_ICONS</a>,
<a name="l05126"></a>05126   mw_prpl_list_icon,
<a name="l05127"></a>05127   mw_prpl_list_emblem,
<a name="l05128"></a>05128   mw_prpl_status_text,
<a name="l05129"></a>05129   mw_prpl_tooltip_text,
<a name="l05130"></a>05130   mw_prpl_status_types,
<a name="l05131"></a>05131   mw_prpl_blist_node_menu,
<a name="l05132"></a>05132   mw_prpl_chat_info,
<a name="l05133"></a>05133   mw_prpl_chat_info_defaults,
<a name="l05134"></a>05134   mw_prpl_login,
<a name="l05135"></a>05135   mw_prpl_close,
<a name="l05136"></a>05136   mw_prpl_send_im,
<a name="l05137"></a>05137   NULL,
<a name="l05138"></a>05138   mw_prpl_send_typing,
<a name="l05139"></a>05139   mw_prpl_get_info,
<a name="l05140"></a>05140   mw_prpl_set_status,
<a name="l05141"></a>05141   mw_prpl_set_idle,
<a name="l05142"></a>05142   NULL,
<a name="l05143"></a>05143   mw_prpl_add_buddy,
<a name="l05144"></a>05144   mw_prpl_add_buddies,
<a name="l05145"></a>05145   mw_prpl_remove_buddy,
<a name="l05146"></a>05146   NULL,
<a name="l05147"></a>05147   mw_prpl_add_permit,
<a name="l05148"></a>05148   mw_prpl_add_deny,
<a name="l05149"></a>05149   mw_prpl_rem_permit,
<a name="l05150"></a>05150   mw_prpl_rem_deny,
<a name="l05151"></a>05151   mw_prpl_set_permit_deny,
<a name="l05152"></a>05152   mw_prpl_join_chat,
<a name="l05153"></a>05153   mw_prpl_reject_chat,
<a name="l05154"></a>05154   mw_prpl_get_chat_name,
<a name="l05155"></a>05155   mw_prpl_chat_invite,
<a name="l05156"></a>05156   mw_prpl_chat_leave,
<a name="l05157"></a>05157   mw_prpl_chat_whisper,
<a name="l05158"></a>05158   mw_prpl_chat_send,
<a name="l05159"></a>05159   mw_prpl_keepalive,
<a name="l05160"></a>05160   NULL,
<a name="l05161"></a>05161   NULL,
<a name="l05162"></a>05162   NULL,
<a name="l05163"></a>05163   mw_prpl_alias_buddy,
<a name="l05164"></a>05164   mw_prpl_group_buddy,
<a name="l05165"></a>05165   mw_prpl_rename_group,
<a name="l05166"></a>05166   mw_prpl_buddy_free,
<a name="l05167"></a>05167   mw_prpl_convo_closed,
<a name="l05168"></a>05168   mw_prpl_normalize,
<a name="l05169"></a>05169   NULL,
<a name="l05170"></a>05170   mw_prpl_remove_group,
<a name="l05171"></a>05171   NULL,
<a name="l05172"></a>05172   NULL,
<a name="l05173"></a>05173   NULL,
<a name="l05174"></a>05174   NULL,
<a name="l05175"></a>05175   NULL,
<a name="l05176"></a>05176   NULL,
<a name="l05177"></a>05177   mw_prpl_can_receive_file,
<a name="l05178"></a>05178   mw_prpl_send_file,
<a name="l05179"></a>05179   mw_prpl_new_xfer,
<a name="l05180"></a>05180   NULL,
<a name="l05181"></a>05181   NULL,
<a name="l05182"></a>05182   NULL,
<a name="l05183"></a>05183   NULL,
<a name="l05184"></a>05184   NULL,
<a name="l05185"></a>05185   NULL,
<a name="l05186"></a>05186   NULL,
<a name="l05187"></a>05187   <span class="keyword">sizeof</span>(<a class="code" href="struct___purple_plugin_protocol_info.html">PurplePluginProtocolInfo</a>),
<a name="l05188"></a>05188   NULL,
<a name="l05189"></a>05189   NULL,
<a name="l05190"></a>05190   NULL,
<a name="l05191"></a>05191   NULL,
<a name="l05192"></a>05192   NULL,
<a name="l05193"></a>05193   NULL,
<a name="l05194"></a>05194   NULL,
<a name="l05195"></a>05195   NULL
<a name="l05196"></a>05196 };
<a name="l05197"></a>05197 
<a name="l05198"></a>05198 
<a name="l05199"></a>05199 <span class="keyword">static</span> <a class="code" href="struct___purple_plugin_pref_frame.html">PurplePluginPrefFrame</a> *
<a name="l05200"></a>05200 mw_plugin_get_plugin_pref_frame(<a class="code" href="struct___purple_plugin.html">PurplePlugin</a> *plugin) {
<a name="l05201"></a>05201   <a class="code" href="struct___purple_plugin_pref_frame.html">PurplePluginPrefFrame</a> *frame;
<a name="l05202"></a>05202   <a class="code" href="struct___purple_plugin_pref.html">PurplePluginPref</a> *pref;
<a name="l05203"></a>05203 
<a name="l05204"></a>05204   frame = purple_plugin_pref_frame_new();
<a name="l05205"></a>05205 
<a name="l05206"></a>05206   pref = purple_plugin_pref_new_with_label(_(<span class="stringliteral">&quot;Remotely Stored Buddy List&quot;</span>));
<a name="l05207"></a>05207   purple_plugin_pref_frame_add(frame, pref);
<a name="l05208"></a>05208 
<a name="l05209"></a>05209 
<a name="l05210"></a>05210   pref = purple_plugin_pref_new_with_name(MW_PRPL_OPT_BLIST_ACTION);
<a name="l05211"></a>05211   purple_plugin_pref_set_label(pref, _(<span class="stringliteral">&quot;Buddy List Storage Mode&quot;</span>));
<a name="l05212"></a>05212 
<a name="l05213"></a>05213   purple_plugin_pref_set_type(pref, PURPLE_PLUGIN_PREF_CHOICE);
<a name="l05214"></a>05214   purple_plugin_pref_add_choice(pref, _(<span class="stringliteral">&quot;Local Buddy List Only&quot;</span>),
<a name="l05215"></a>05215                               GINT_TO_POINTER(blist_choice_LOCAL));
<a name="l05216"></a>05216   purple_plugin_pref_add_choice(pref, _(<span class="stringliteral">&quot;Merge List from Server&quot;</span>),
<a name="l05217"></a>05217                               GINT_TO_POINTER(blist_choice_MERGE));
<a name="l05218"></a>05218   purple_plugin_pref_add_choice(pref, _(<span class="stringliteral">&quot;Merge and Save List to Server&quot;</span>),
<a name="l05219"></a>05219                               GINT_TO_POINTER(blist_choice_STORE));
<a name="l05220"></a>05220   purple_plugin_pref_add_choice(pref, _(<span class="stringliteral">&quot;Synchronize List with Server&quot;</span>),
<a name="l05221"></a>05221                               GINT_TO_POINTER(blist_choice_SYNCH));
<a name="l05222"></a>05222 
<a name="l05223"></a>05223   purple_plugin_pref_frame_add(frame, pref);
<a name="l05224"></a>05224 
<a name="l05225"></a>05225   <span class="keywordflow">return</span> frame;
<a name="l05226"></a>05226 }
<a name="l05227"></a>05227 
<a name="l05228"></a>05228 
<a name="l05229"></a>05229 <span class="keyword">static</span> <a class="code" href="struct___purple_plugin_ui_info.html">PurplePluginUiInfo</a> mw_plugin_ui_info = {
<a name="l05230"></a>05230   mw_plugin_get_plugin_pref_frame,
<a name="l05231"></a>05231   0,    <span class="comment">/* page_num */</span>
<a name="l05232"></a>05232   NULL, <span class="comment">/* frame */</span>
<a name="l05233"></a>05233   NULL,
<a name="l05234"></a>05234   NULL,
<a name="l05235"></a>05235   NULL,
<a name="l05236"></a>05236   NULL
<a name="l05237"></a>05237 };
<a name="l05238"></a>05238 
<a name="l05239"></a>05239 
<a name="l05240"></a>05240 <span class="keyword">static</span> <span class="keywordtype">void</span> st_import_action_cb(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keywordtype">char</span> *filename) {
<a name="l05241"></a>05241   <span class="keyword">struct </span>mwSametimeList *l;
<a name="l05242"></a>05242 
<a name="l05243"></a>05243   FILE *file;
<a name="l05244"></a>05244   <span class="keywordtype">char</span> buf[BUF_LEN];
<a name="l05245"></a>05245   <span class="keywordtype">size_t</span> len;
<a name="l05246"></a>05246 
<a name="l05247"></a>05247   GString *str;
<a name="l05248"></a>05248 
<a name="l05249"></a>05249   file = g_fopen(filename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l05250"></a>05250   g_return_if_fail(file != NULL);
<a name="l05251"></a>05251 
<a name="l05252"></a>05252   str = g_string_new(NULL);
<a name="l05253"></a>05253   <span class="keywordflow">while</span>( (len = fread(buf, 1, BUF_LEN, file)) ) {
<a name="l05254"></a>05254     g_string_append_len(str, buf, len);
<a name="l05255"></a>05255   }
<a name="l05256"></a>05256 
<a name="l05257"></a>05257   fclose(file);
<a name="l05258"></a>05258 
<a name="l05259"></a>05259   l = mwSametimeList_load(str-&gt;str);
<a name="l05260"></a>05260   g_string_free(str, TRUE);
<a name="l05261"></a>05261 
<a name="l05262"></a>05262   blist_merge(gc, l);
<a name="l05263"></a>05263   mwSametimeList_free(l);
<a name="l05264"></a>05264 }
<a name="l05265"></a>05265 
<a name="l05266"></a>05266 
<a name="l05268"></a>05268 <span class="keyword">static</span> <span class="keywordtype">void</span> st_import_action(<a class="code" href="struct___purple_plugin_action.html">PurplePluginAction</a> *act) {
<a name="l05269"></a>05269   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l05270"></a>05270   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *account;
<a name="l05271"></a>05271   <span class="keywordtype">char</span> *title;
<a name="l05272"></a>05272 
<a name="l05273"></a>05273   gc = act-&gt;<a class="code" href="struct___purple_plugin_action.html#afec75fcacd4a3a141ff767c166072d0f">context</a>;
<a name="l05274"></a>05274   account = purple_connection_get_account(gc);
<a name="l05275"></a>05275   title = g_strdup_printf(_(<span class="stringliteral">&quot;Import Sametime List for Account %s&quot;</span>),
<a name="l05276"></a>05276                           purple_account_get_username(account));
<a name="l05277"></a>05277 
<a name="l05278"></a>05278   purple_request_file(gc, title, NULL, FALSE,
<a name="l05279"></a>05279                     G_CALLBACK(st_import_action_cb), NULL,
<a name="l05280"></a>05280                     account, NULL, NULL,
<a name="l05281"></a>05281                     gc);
<a name="l05282"></a>05282 
<a name="l05283"></a>05283   g_free(title);
<a name="l05284"></a>05284 }
<a name="l05285"></a>05285 
<a name="l05286"></a>05286 
<a name="l05287"></a>05287 <span class="keyword">static</span> <span class="keywordtype">void</span> st_export_action_cb(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keywordtype">char</span> *filename) {
<a name="l05288"></a>05288   <span class="keyword">struct </span>mwSametimeList *l;
<a name="l05289"></a>05289   <span class="keywordtype">char</span> *str;
<a name="l05290"></a>05290   FILE *file;
<a name="l05291"></a>05291 
<a name="l05292"></a>05292   file = g_fopen(filename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l05293"></a>05293   g_return_if_fail(file != NULL);
<a name="l05294"></a>05294 
<a name="l05295"></a>05295   l = mwSametimeList_new();
<a name="l05296"></a>05296   blist_export(gc, l);
<a name="l05297"></a>05297   str = mwSametimeList_store(l);
<a name="l05298"></a>05298   mwSametimeList_free(l);
<a name="l05299"></a>05299 
<a name="l05300"></a>05300   fprintf(file, <span class="stringliteral">&quot;%s&quot;</span>, str);
<a name="l05301"></a>05301   fclose(file);
<a name="l05302"></a>05302 
<a name="l05303"></a>05303   g_free(str);
<a name="l05304"></a>05304 }
<a name="l05305"></a>05305 
<a name="l05306"></a>05306 
<a name="l05308"></a>05308 <span class="keyword">static</span> <span class="keywordtype">void</span> st_export_action(<a class="code" href="struct___purple_plugin_action.html">PurplePluginAction</a> *act) {
<a name="l05309"></a>05309   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l05310"></a>05310   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *account;
<a name="l05311"></a>05311   <span class="keywordtype">char</span> *title;
<a name="l05312"></a>05312 
<a name="l05313"></a>05313   gc = act-&gt;<a class="code" href="struct___purple_plugin_action.html#afec75fcacd4a3a141ff767c166072d0f">context</a>;
<a name="l05314"></a>05314   account = purple_connection_get_account(gc);
<a name="l05315"></a>05315   title = g_strdup_printf(_(<span class="stringliteral">&quot;Export Sametime List for Account %s&quot;</span>),
<a name="l05316"></a>05316                           purple_account_get_username(account));
<a name="l05317"></a>05317 
<a name="l05318"></a>05318   purple_request_file(gc, title, NULL, TRUE,
<a name="l05319"></a>05319                     G_CALLBACK(st_export_action_cb), NULL,
<a name="l05320"></a>05320                         account, NULL, NULL,
<a name="l05321"></a>05321                     gc);
<a name="l05322"></a>05322 
<a name="l05323"></a>05323   g_free(title);
<a name="l05324"></a>05324 }
<a name="l05325"></a>05325 
<a name="l05326"></a>05326 
<a name="l05327"></a>05327 <span class="keyword">static</span> <span class="keywordtype">void</span> remote_group_multi_cleanup(gpointer ignore,
<a name="l05328"></a>05328                                        <a class="code" href="struct_purple_request_fields.html">PurpleRequestFields</a> *fields) {
<a name="l05329"></a>05329 
<a name="l05330"></a>05330   <a class="code" href="struct___purple_request_field.html">PurpleRequestField</a> *f;
<a name="l05331"></a>05331   GList *l;
<a name="l05332"></a>05332 
<a name="l05333"></a>05333   f = purple_request_fields_get_field(fields, <span class="stringliteral">&quot;group&quot;</span>);
<a name="l05334"></a>05334   l = purple_request_field_list_get_items(f);
<a name="l05335"></a>05335 
<a name="l05336"></a>05336   <span class="keywordflow">for</span>(; l; l = l-&gt;next) {
<a name="l05337"></a>05337     <span class="keyword">const</span> <span class="keywordtype">char</span> *i = l-&gt;data;
<a name="l05338"></a>05338     <span class="keyword">struct </span><a class="code" href="structnamed__id.html">named_id</a> *res;
<a name="l05339"></a>05339 
<a name="l05340"></a>05340     res = purple_request_field_list_get_data(f, i);
<a name="l05341"></a>05341 
<a name="l05342"></a>05342     g_free(res-&gt;id);
<a name="l05343"></a>05343     g_free(res-&gt;name);
<a name="l05344"></a>05344     g_free(res);
<a name="l05345"></a>05345   }
<a name="l05346"></a>05346 }
<a name="l05347"></a>05347 
<a name="l05348"></a>05348 
<a name="l05349"></a>05349 <span class="keyword">static</span> <span class="keywordtype">void</span> remote_group_done(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd,
<a name="l05350"></a>05350                               <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l05351"></a>05351   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l05352"></a>05352   <a class="code" href="struct___purple_account.html">PurpleAccount</a> *acct;
<a name="l05353"></a>05353   <a class="code" href="struct___purple_group.html">PurpleGroup</a> *group;
<a name="l05354"></a>05354   <a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *gn;
<a name="l05355"></a>05355   <span class="keyword">const</span> <span class="keywordtype">char</span> *owner;
<a name="l05356"></a>05356 
<a name="l05357"></a>05357   g_return_if_fail(pd != NULL);
<a name="l05358"></a>05358 
<a name="l05359"></a>05359   gc = pd-&gt;gc;
<a name="l05360"></a>05360   acct = purple_connection_get_account(gc);
<a name="l05361"></a>05361 
<a name="l05362"></a>05362   <span class="comment">/* collision checking */</span>
<a name="l05363"></a>05363   group = purple_find_group(name);
<a name="l05364"></a>05364   <span class="keywordflow">if</span>(group) {
<a name="l05365"></a>05365     <span class="keyword">const</span> <span class="keywordtype">char</span> *msgA;
<a name="l05366"></a>05366     <span class="keyword">const</span> <span class="keywordtype">char</span> *msgB;
<a name="l05367"></a>05367     <span class="keywordtype">char</span> *msg;
<a name="l05368"></a>05368 
<a name="l05369"></a>05369     msgA = _(<span class="stringliteral">&quot;Unable to add group: group exists&quot;</span>);
<a name="l05370"></a>05370     msgB = _(<span class="stringliteral">&quot;A group named &#39;%s&#39; already exists in your buddy list.&quot;</span>);
<a name="l05371"></a>05371     msg = g_strdup_printf(msgB, name);
<a name="l05372"></a>05372 
<a name="l05373"></a>05373     <a class="code" href="notify_8h.html#ad54861c382f50702e2c6c2317aff878d">purple_notify_error</a>(gc, _(<span class="stringliteral">&quot;Unable to add group&quot;</span>), msgA, msg);
<a name="l05374"></a>05374 
<a name="l05375"></a>05375     g_free(msg);
<a name="l05376"></a>05376     <span class="keywordflow">return</span>;
<a name="l05377"></a>05377   }
<a name="l05378"></a>05378 
<a name="l05379"></a>05379   group = purple_group_new(name);
<a name="l05380"></a>05380   gn = (<a class="code" href="struct___purple_blist_node.html">PurpleBlistNode</a> *) group;
<a name="l05381"></a>05381 
<a name="l05382"></a>05382   owner = purple_account_get_username(acct);
<a name="l05383"></a>05383 
<a name="l05384"></a>05384   purple_blist_node_set_string(gn, GROUP_KEY_NAME, <span class="keywordtype">id</span>);
<a name="l05385"></a>05385   purple_blist_node_set_int(gn, GROUP_KEY_TYPE, mwSametimeGroup_DYNAMIC);
<a name="l05386"></a>05386   purple_blist_node_set_string(gn, GROUP_KEY_OWNER, owner);
<a name="l05387"></a>05387   purple_blist_add_group(group, NULL);
<a name="l05388"></a>05388 
<a name="l05389"></a>05389   group_add(pd, group);
<a name="l05390"></a>05390   blist_schedule(pd);
<a name="l05391"></a>05391 }
<a name="l05392"></a>05392 
<a name="l05393"></a>05393 
<a name="l05394"></a>05394 <span class="keyword">static</span> <span class="keywordtype">void</span> remote_group_multi_cb(<span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd,
<a name="l05395"></a>05395                                   <a class="code" href="struct_purple_request_fields.html">PurpleRequestFields</a> *fields) {
<a name="l05396"></a>05396   <a class="code" href="struct___purple_request_field.html">PurpleRequestField</a> *f;
<a name="l05397"></a>05397   GList *l;
<a name="l05398"></a>05398 
<a name="l05399"></a>05399   f = purple_request_fields_get_field(fields, <span class="stringliteral">&quot;group&quot;</span>);
<a name="l05400"></a>05400   l = purple_request_field_list_get_selected(f);
<a name="l05401"></a>05401 
<a name="l05402"></a>05402   <span class="keywordflow">if</span>(l) {
<a name="l05403"></a>05403     <span class="keyword">const</span> <span class="keywordtype">char</span> *i = l-&gt;data;
<a name="l05404"></a>05404     <span class="keyword">struct </span><a class="code" href="structnamed__id.html">named_id</a> *res;
<a name="l05405"></a>05405 
<a name="l05406"></a>05406     res = purple_request_field_list_get_data(f, i);
<a name="l05407"></a>05407     remote_group_done(pd, res-&gt;id, res-&gt;name);
<a name="l05408"></a>05408   }
<a name="l05409"></a>05409 
<a name="l05410"></a>05410   remote_group_multi_cleanup(NULL, fields);
<a name="l05411"></a>05411 }
<a name="l05412"></a>05412 
<a name="l05413"></a>05413 
<a name="l05414"></a>05414 <span class="keyword">static</span> <span class="keywordtype">void</span> remote_group_multi(<span class="keyword">struct</span> mwResolveResult *result,
<a name="l05415"></a>05415                                <span class="keyword">struct</span> <a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd) {
<a name="l05416"></a>05416 
<a name="l05417"></a>05417   <a class="code" href="struct_purple_request_fields.html">PurpleRequestFields</a> *fields;
<a name="l05418"></a>05418   <a class="code" href="struct_purple_request_field_group.html">PurpleRequestFieldGroup</a> *g;
<a name="l05419"></a>05419   <a class="code" href="struct___purple_request_field.html">PurpleRequestField</a> *f;
<a name="l05420"></a>05420   GList *l;
<a name="l05421"></a>05421   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgA;
<a name="l05422"></a>05422   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgB;
<a name="l05423"></a>05423   <span class="keywordtype">char</span> *msg;
<a name="l05424"></a>05424 
<a name="l05425"></a>05425   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc = pd-&gt;gc;
<a name="l05426"></a>05426 
<a name="l05427"></a>05427   fields = purple_request_fields_new();
<a name="l05428"></a>05428 
<a name="l05429"></a>05429   g = purple_request_field_group_new(NULL);
<a name="l05430"></a>05430   purple_request_fields_add_group(fields, g);
<a name="l05431"></a>05431 
<a name="l05432"></a>05432   f = purple_request_field_list_new(<span class="stringliteral">&quot;group&quot;</span>, _(<span class="stringliteral">&quot;Possible Matches&quot;</span>));
<a name="l05433"></a>05433   purple_request_field_list_set_multi_select(f, FALSE);
<a name="l05434"></a>05434   purple_request_field_set_required(f, TRUE);
<a name="l05435"></a>05435 
<a name="l05436"></a>05436   <span class="keywordflow">for</span>(l = result-&gt;matches; l; l = l-&gt;next) {
<a name="l05437"></a>05437     <span class="keyword">struct </span>mwResolveMatch *match = l-&gt;data;
<a name="l05438"></a>05438     <span class="keyword">struct </span><a class="code" href="structnamed__id.html">named_id</a> *res = g_new0(<span class="keyword">struct</span> <a class="code" href="structnamed__id.html">named_id</a>, 1);
<a name="l05439"></a>05439 
<a name="l05440"></a>05440     res-&gt;id = g_strdup(match-&gt;id);
<a name="l05441"></a>05441     res-&gt;name = g_strdup(match-&gt;name);
<a name="l05442"></a>05442 
<a name="l05443"></a>05443     purple_request_field_list_add_icon(f, res-&gt;name, NULL, res);
<a name="l05444"></a>05444   }
<a name="l05445"></a>05445 
<a name="l05446"></a>05446   purple_request_field_group_add_field(g, f);
<a name="l05447"></a>05447 
<a name="l05448"></a>05448   msgA = _(<span class="stringliteral">&quot;Notes Address Book group results&quot;</span>);
<a name="l05449"></a>05449   msgB = _(<span class="stringliteral">&quot;The identifier &#39;%s&#39; may possibly refer to any of the following&quot;</span>
<a name="l05450"></a>05450           <span class="stringliteral">&quot; Notes Address Book groups. Please select the correct group from&quot;</span>
<a name="l05451"></a>05451           <span class="stringliteral">&quot; the list below to add it to your buddy list.&quot;</span>);
<a name="l05452"></a>05452   msg = g_strdup_printf(msgB, result-&gt;name);
<a name="l05453"></a>05453 
<a name="l05454"></a>05454   purple_request_fields(gc, _(<span class="stringliteral">&quot;Select Notes Address Book&quot;</span>),
<a name="l05455"></a>05455                       msgA, msg, fields,
<a name="l05456"></a>05456                       _(<span class="stringliteral">&quot;Add Group&quot;</span>), G_CALLBACK(remote_group_multi_cb),
<a name="l05457"></a>05457                       _(<span class="stringliteral">&quot;Cancel&quot;</span>), G_CALLBACK(remote_group_multi_cleanup),
<a name="l05458"></a>05458                           purple_connection_get_account(gc), result-&gt;name, NULL,
<a name="l05459"></a>05459                       pd);
<a name="l05460"></a>05460 
<a name="l05461"></a>05461   g_free(msg);
<a name="l05462"></a>05462 }
<a name="l05463"></a>05463 
<a name="l05464"></a>05464 
<a name="l05465"></a>05465 <span class="keyword">static</span> <span class="keywordtype">void</span> remote_group_resolved(<span class="keyword">struct</span> mwServiceResolve *srvc,
<a name="l05466"></a>05466                                   guint32 <span class="keywordtype">id</span>, guint32 code, GList *results,
<a name="l05467"></a>05467                                   gpointer b) {
<a name="l05468"></a>05468 
<a name="l05469"></a>05469   <span class="keyword">struct </span>mwResolveResult *res = NULL;
<a name="l05470"></a>05470   <span class="keyword">struct </span>mwSession *session;
<a name="l05471"></a>05471   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l05472"></a>05472   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l05473"></a>05473 
<a name="l05474"></a>05474   session = mwService_getSession(MW_SERVICE(srvc));
<a name="l05475"></a>05475   g_return_if_fail(session != NULL);
<a name="l05476"></a>05476 
<a name="l05477"></a>05477   pd = mwSession_getClientData(session);
<a name="l05478"></a>05478   g_return_if_fail(pd != NULL);
<a name="l05479"></a>05479 
<a name="l05480"></a>05480   gc = pd-&gt;gc;
<a name="l05481"></a>05481   g_return_if_fail(gc != NULL);
<a name="l05482"></a>05482 
<a name="l05483"></a>05483   <span class="keywordflow">if</span>(!code &amp;&amp; results) {
<a name="l05484"></a>05484     res = results-&gt;data;
<a name="l05485"></a>05485 
<a name="l05486"></a>05486     <span class="keywordflow">if</span>(res-&gt;matches) {
<a name="l05487"></a>05487       remote_group_multi(res, pd);
<a name="l05488"></a>05488       <span class="keywordflow">return</span>;
<a name="l05489"></a>05489     }
<a name="l05490"></a>05490   }
<a name="l05491"></a>05491 
<a name="l05492"></a>05492   <span class="keywordflow">if</span>(res &amp;&amp; res-&gt;name) {
<a name="l05493"></a>05493     <span class="keyword">const</span> <span class="keywordtype">char</span> *msgA;
<a name="l05494"></a>05494     <span class="keyword">const</span> <span class="keywordtype">char</span> *msgB;
<a name="l05495"></a>05495     <span class="keywordtype">char</span> *msg;
<a name="l05496"></a>05496 
<a name="l05497"></a>05497     msgA = _(<span class="stringliteral">&quot;Unable to add group: group not found&quot;</span>);
<a name="l05498"></a>05498 
<a name="l05499"></a>05499     msgB = _(<span class="stringliteral">&quot;The identifier &#39;%s&#39; did not match any Notes Address Book&quot;</span>
<a name="l05500"></a>05500             <span class="stringliteral">&quot; groups in your Sametime community.&quot;</span>);
<a name="l05501"></a>05501     msg = g_strdup_printf(msgB, res-&gt;name);
<a name="l05502"></a>05502 
<a name="l05503"></a>05503     <a class="code" href="notify_8h.html#ad54861c382f50702e2c6c2317aff878d">purple_notify_error</a>(gc, _(<span class="stringliteral">&quot;Unable to add group&quot;</span>), msgA, msg);
<a name="l05504"></a>05504 
<a name="l05505"></a>05505     g_free(msg);
<a name="l05506"></a>05506   }
<a name="l05507"></a>05507 }
<a name="l05508"></a>05508 
<a name="l05509"></a>05509 
<a name="l05510"></a>05510 <span class="keyword">static</span> <span class="keywordtype">void</span> remote_group_action_cb(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l05511"></a>05511   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l05512"></a>05512   <span class="keyword">struct </span>mwServiceResolve *srvc;
<a name="l05513"></a>05513   GList *query;
<a name="l05514"></a>05514   <span class="keyword">enum</span> mwResolveFlag flags;
<a name="l05515"></a>05515   guint32 req;
<a name="l05516"></a>05516 
<a name="l05517"></a>05517   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l05518"></a>05518   srvc = pd-&gt;srvc_resolve;
<a name="l05519"></a>05519 
<a name="l05520"></a>05520   query = g_list_prepend(NULL, (<span class="keywordtype">char</span> *) name);
<a name="l05521"></a>05521   flags = mwResolveFlag_FIRST | mwResolveFlag_GROUPS;
<a name="l05522"></a>05522 
<a name="l05523"></a>05523   req = mwServiceResolve_resolve(srvc, query, flags, remote_group_resolved,
<a name="l05524"></a>05524                                  NULL, NULL);
<a name="l05525"></a>05525   g_list_free(query);
<a name="l05526"></a>05526 
<a name="l05527"></a>05527   <span class="keywordflow">if</span>(req == SEARCH_ERROR) {
<a name="l05529"></a>05529   }
<a name="l05530"></a>05530 }
<a name="l05531"></a>05531 
<a name="l05532"></a>05532 
<a name="l05533"></a>05533 <span class="keyword">static</span> <span class="keywordtype">void</span> remote_group_action(<a class="code" href="struct___purple_plugin_action.html">PurplePluginAction</a> *act) {
<a name="l05534"></a>05534   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l05535"></a>05535   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgA;
<a name="l05536"></a>05536   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgB;
<a name="l05537"></a>05537 
<a name="l05538"></a>05538   gc = act-&gt;<a class="code" href="struct___purple_plugin_action.html#afec75fcacd4a3a141ff767c166072d0f">context</a>;
<a name="l05539"></a>05539 
<a name="l05540"></a>05540   msgA = _(<span class="stringliteral">&quot;Notes Address Book Group&quot;</span>);
<a name="l05541"></a>05541   msgB = _(<span class="stringliteral">&quot;Enter the name of a Notes Address Book group in the field below&quot;</span>
<a name="l05542"></a>05542           <span class="stringliteral">&quot; to add the group and its members to your buddy list.&quot;</span>);
<a name="l05543"></a>05543 
<a name="l05544"></a>05544   purple_request_input(gc, _(<span class="stringliteral">&quot;Add Group&quot;</span>), msgA, msgB, NULL,
<a name="l05545"></a>05545                      FALSE, FALSE, NULL,
<a name="l05546"></a>05546                      _(<span class="stringliteral">&quot;Add&quot;</span>), G_CALLBACK(remote_group_action_cb),
<a name="l05547"></a>05547                      _(<span class="stringliteral">&quot;Cancel&quot;</span>), NULL,
<a name="l05548"></a>05548                          purple_connection_get_account(gc), NULL, NULL,
<a name="l05549"></a>05549                      gc);
<a name="l05550"></a>05550 }
<a name="l05551"></a>05551 
<a name="l05552"></a>05552 
<a name="l05553"></a>05553 <span class="keyword">static</span> <span class="keywordtype">void</span> search_notify(<span class="keyword">struct</span> mwResolveResult *result,
<a name="l05554"></a>05554                           <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc) {
<a name="l05555"></a>05555   GList *l;
<a name="l05556"></a>05556   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgA;
<a name="l05557"></a>05557   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgB;
<a name="l05558"></a>05558   <span class="keywordtype">char</span> *msg1;
<a name="l05559"></a>05559   <span class="keywordtype">char</span> *msg2;
<a name="l05560"></a>05560 
<a name="l05561"></a>05561   <a class="code" href="struct_purple_notify_search_results.html">PurpleNotifySearchResults</a> *sres;
<a name="l05562"></a>05562   <a class="code" href="struct_purple_notify_search_column.html">PurpleNotifySearchColumn</a> *scol;
<a name="l05563"></a>05563 
<a name="l05564"></a>05564   sres = purple_notify_searchresults_new();
<a name="l05565"></a>05565 
<a name="l05566"></a>05566   scol = purple_notify_searchresults_column_new(_(<span class="stringliteral">&quot;User Name&quot;</span>));
<a name="l05567"></a>05567   purple_notify_searchresults_column_add(sres, scol);
<a name="l05568"></a>05568 
<a name="l05569"></a>05569   scol = purple_notify_searchresults_column_new(_(<span class="stringliteral">&quot;Sametime ID&quot;</span>));
<a name="l05570"></a>05570   purple_notify_searchresults_column_add(sres, scol);
<a name="l05571"></a>05571 
<a name="l05572"></a>05572   purple_notify_searchresults_button_add(sres, PURPLE_NOTIFY_BUTTON_IM,
<a name="l05573"></a>05573                                        notify_im);
<a name="l05574"></a>05574 
<a name="l05575"></a>05575   purple_notify_searchresults_button_add(sres, PURPLE_NOTIFY_BUTTON_ADD,
<a name="l05576"></a>05576                                        notify_add);
<a name="l05577"></a>05577 
<a name="l05578"></a>05578   <span class="keywordflow">for</span>(l = result-&gt;matches; l; l = l-&gt;next) {
<a name="l05579"></a>05579     <span class="keyword">struct </span>mwResolveMatch *match = l-&gt;data;
<a name="l05580"></a>05580     GList *row = NULL;
<a name="l05581"></a>05581 
<a name="l05582"></a>05582     <span class="keywordflow">if</span>(!match-&gt;id || !match-&gt;name)
<a name="l05583"></a>05583       <span class="keywordflow">continue</span>;
<a name="l05584"></a>05584 
<a name="l05585"></a>05585     row = g_list_append(row, g_strdup(match-&gt;name));
<a name="l05586"></a>05586     row = g_list_append(row, g_strdup(match-&gt;id));
<a name="l05587"></a>05587     purple_notify_searchresults_row_add(sres, row);
<a name="l05588"></a>05588   }
<a name="l05589"></a>05589 
<a name="l05590"></a>05590   msgA = _(<span class="stringliteral">&quot;Search results for &#39;%s&#39;&quot;</span>);
<a name="l05591"></a>05591   msgB = _(<span class="stringliteral">&quot;The identifier &#39;%s&#39; may possibly refer to any of the following&quot;</span>
<a name="l05592"></a>05592            <span class="stringliteral">&quot; users. You may add these users to your buddy list or send them&quot;</span>
<a name="l05593"></a>05593            <span class="stringliteral">&quot; messages with the action buttons below.&quot;</span>);
<a name="l05594"></a>05594 
<a name="l05595"></a>05595   msg1 = g_strdup_printf(msgA, result-&gt;name);
<a name="l05596"></a>05596   msg2 = g_strdup_printf(msgB, result-&gt;name);
<a name="l05597"></a>05597 
<a name="l05598"></a>05598   purple_notify_searchresults(gc, _(<span class="stringliteral">&quot;Search Results&quot;</span>),
<a name="l05599"></a>05599                             msg1, msg2, sres, notify_close, NULL);
<a name="l05600"></a>05600 
<a name="l05601"></a>05601   g_free(msg1);
<a name="l05602"></a>05602   g_free(msg2);
<a name="l05603"></a>05603 }
<a name="l05604"></a>05604 
<a name="l05605"></a>05605 
<a name="l05606"></a>05606 <span class="keyword">static</span> <span class="keywordtype">void</span> search_resolved(<span class="keyword">struct</span> mwServiceResolve *srvc,
<a name="l05607"></a>05607                             guint32 <span class="keywordtype">id</span>, guint32 code, GList *results,
<a name="l05608"></a>05608                             gpointer b) {
<a name="l05609"></a>05609 
<a name="l05610"></a>05610   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc = b;
<a name="l05611"></a>05611   <span class="keyword">struct </span>mwResolveResult *res = NULL;
<a name="l05612"></a>05612 
<a name="l05613"></a>05613   <span class="keywordflow">if</span>(results) res = results-&gt;data;
<a name="l05614"></a>05614 
<a name="l05615"></a>05615   <span class="keywordflow">if</span>(!code &amp;&amp; res &amp;&amp; res-&gt;matches) {
<a name="l05616"></a>05616     search_notify(res, gc);
<a name="l05617"></a>05617 
<a name="l05618"></a>05618   } <span class="keywordflow">else</span> {
<a name="l05619"></a>05619     <span class="keyword">const</span> <span class="keywordtype">char</span> *msgA;
<a name="l05620"></a>05620     <span class="keyword">const</span> <span class="keywordtype">char</span> *msgB;
<a name="l05621"></a>05621     <span class="keywordtype">char</span> *msg;
<a name="l05622"></a>05622 
<a name="l05623"></a>05623     msgA = _(<span class="stringliteral">&quot;No matches&quot;</span>);
<a name="l05624"></a>05624     msgB = _(<span class="stringliteral">&quot;The identifier &#39;%s&#39; did not match any users in your&quot;</span>
<a name="l05625"></a>05625              <span class="stringliteral">&quot; Sametime community.&quot;</span>);
<a name="l05626"></a>05626     msg = g_strdup_printf(msgB, (res &amp;&amp; res-&gt;name) ? NSTR(res-&gt;name) : <span class="stringliteral">&quot;&quot;</span>);
<a name="l05627"></a>05627 
<a name="l05628"></a>05628     <a class="code" href="notify_8h.html#ad54861c382f50702e2c6c2317aff878d">purple_notify_error</a>(gc, _(<span class="stringliteral">&quot;No Matches&quot;</span>), msgA, msg);
<a name="l05629"></a>05629 
<a name="l05630"></a>05630     g_free(msg);
<a name="l05631"></a>05631   }
<a name="l05632"></a>05632 }
<a name="l05633"></a>05633 
<a name="l05634"></a>05634 
<a name="l05635"></a>05635 <span class="keyword">static</span> <span class="keywordtype">void</span> search_action_cb(<a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l05636"></a>05636   <span class="keyword">struct </span><a class="code" href="structmw_purple_plugin_data.html">mwPurplePluginData</a> *pd;
<a name="l05637"></a>05637   <span class="keyword">struct </span>mwServiceResolve *srvc;
<a name="l05638"></a>05638   GList *query;
<a name="l05639"></a>05639   <span class="keyword">enum</span> mwResolveFlag flags;
<a name="l05640"></a>05640   guint32 req;
<a name="l05641"></a>05641 
<a name="l05642"></a>05642   pd = gc-&gt;<a class="code" href="struct___purple_connection.html#a65c34f25cec84b2f513f7fdbd27d62bd">proto_data</a>;
<a name="l05643"></a>05643   srvc = pd-&gt;srvc_resolve;
<a name="l05644"></a>05644 
<a name="l05645"></a>05645   query = g_list_prepend(NULL, (<span class="keywordtype">char</span> *) name);
<a name="l05646"></a>05646   flags = mwResolveFlag_FIRST | mwResolveFlag_USERS;
<a name="l05647"></a>05647 
<a name="l05648"></a>05648   req = mwServiceResolve_resolve(srvc, query, flags, search_resolved,
<a name="l05649"></a>05649                                  gc, NULL);
<a name="l05650"></a>05650   g_list_free(query);
<a name="l05651"></a>05651 
<a name="l05652"></a>05652   <span class="keywordflow">if</span>(req == SEARCH_ERROR) {
<a name="l05654"></a>05654   }
<a name="l05655"></a>05655 }
<a name="l05656"></a>05656 
<a name="l05657"></a>05657 
<a name="l05658"></a>05658 <span class="keyword">static</span> <span class="keywordtype">void</span> search_action(<a class="code" href="struct___purple_plugin_action.html">PurplePluginAction</a> *act) {
<a name="l05659"></a>05659   <a class="code" href="struct___purple_connection.html">PurpleConnection</a> *gc;
<a name="l05660"></a>05660   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgA;
<a name="l05661"></a>05661   <span class="keyword">const</span> <span class="keywordtype">char</span> *msgB;
<a name="l05662"></a>05662 
<a name="l05663"></a>05663   gc = act-&gt;<a class="code" href="struct___purple_plugin_action.html#afec75fcacd4a3a141ff767c166072d0f">context</a>;
<a name="l05664"></a>05664 
<a name="l05665"></a>05665   msgA = _(<span class="stringliteral">&quot;Search for a user&quot;</span>);
<a name="l05666"></a>05666   msgB = _(<span class="stringliteral">&quot;Enter a name or partial ID in the field below to search&quot;</span>
<a name="l05667"></a>05667            <span class="stringliteral">&quot; for matching users in your Sametime community.&quot;</span>);
<a name="l05668"></a>05668 
<a name="l05669"></a>05669   purple_request_input(gc, _(<span class="stringliteral">&quot;User Search&quot;</span>), msgA, msgB, NULL,
<a name="l05670"></a>05670                      FALSE, FALSE, NULL,
<a name="l05671"></a>05671                      _(<span class="stringliteral">&quot;Search&quot;</span>), G_CALLBACK(search_action_cb),
<a name="l05672"></a>05672                      _(<span class="stringliteral">&quot;Cancel&quot;</span>), NULL,
<a name="l05673"></a>05673                          purple_connection_get_account(gc), NULL, NULL,
<a name="l05674"></a>05674                          gc);
<a name="l05675"></a>05675 }
<a name="l05676"></a>05676 
<a name="l05677"></a>05677 
<a name="l05678"></a>05678 <span class="keyword">static</span> GList *mw_plugin_actions(<a class="code" href="struct___purple_plugin.html">PurplePlugin</a> *plugin, gpointer context) {
<a name="l05679"></a>05679   <a class="code" href="struct___purple_plugin_action.html">PurplePluginAction</a> *act;
<a name="l05680"></a>05680   GList *l = NULL;
<a name="l05681"></a>05681 
<a name="l05682"></a>05682   act = purple_plugin_action_new(_(<span class="stringliteral">&quot;Import Sametime List...&quot;</span>),
<a name="l05683"></a>05683                                st_import_action);
<a name="l05684"></a>05684   l = g_list_append(l, act);
<a name="l05685"></a>05685 
<a name="l05686"></a>05686   act = purple_plugin_action_new(_(<span class="stringliteral">&quot;Export Sametime List...&quot;</span>),
<a name="l05687"></a>05687                                st_export_action);
<a name="l05688"></a>05688   l = g_list_append(l, act);
<a name="l05689"></a>05689 
<a name="l05690"></a>05690   act = purple_plugin_action_new(_(<span class="stringliteral">&quot;Add Notes Address Book Group...&quot;</span>),
<a name="l05691"></a>05691                                remote_group_action);
<a name="l05692"></a>05692   l = g_list_append(l, act);
<a name="l05693"></a>05693 
<a name="l05694"></a>05694   act = purple_plugin_action_new(_(<span class="stringliteral">&quot;User Search...&quot;</span>),
<a name="l05695"></a>05695                                search_action);
<a name="l05696"></a>05696   l = g_list_append(l, act);
<a name="l05697"></a>05697 
<a name="l05698"></a>05698   <span class="keywordflow">return</span> l;
<a name="l05699"></a>05699 }
<a name="l05700"></a>05700 
<a name="l05701"></a>05701 
<a name="l05702"></a>05702 <span class="keyword">static</span> gboolean mw_plugin_load(<a class="code" href="struct___purple_plugin.html">PurplePlugin</a> *plugin) {
<a name="l05703"></a>05703   <span class="keywordflow">return</span> TRUE;
<a name="l05704"></a>05704 }
<a name="l05705"></a>05705 
<a name="l05706"></a>05706 
<a name="l05707"></a>05707 <span class="keyword">static</span> gboolean mw_plugin_unload(<a class="code" href="struct___purple_plugin.html">PurplePlugin</a> *plugin) {
<a name="l05708"></a>05708   <span class="keywordflow">return</span> TRUE;
<a name="l05709"></a>05709 }
<a name="l05710"></a>05710 
<a name="l05711"></a>05711 
<a name="l05712"></a>05712 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_plugin_destroy(<a class="code" href="struct___purple_plugin.html">PurplePlugin</a> *plugin) {
<a name="l05713"></a>05713   g_log_remove_handler(G_LOG_DOMAIN, log_handler[0]);
<a name="l05714"></a>05714   g_log_remove_handler(<span class="stringliteral">&quot;meanwhile&quot;</span>, log_handler[1]);
<a name="l05715"></a>05715 }
<a name="l05716"></a>05716 
<a name="l05717"></a>05717 <span class="keyword">static</span> <a class="code" href="struct___purple_plugin_info.html">PurplePluginInfo</a> mw_plugin_info =
<a name="l05718"></a>05718 {
<a name="l05719"></a>05719         PURPLE_PLUGIN_MAGIC,
<a name="l05720"></a>05720         <a class="code" href="version_8h.html#a046c2ee58f2b6ed94f29c524c2241f4d">PURPLE_MAJOR_VERSION</a>,
<a name="l05721"></a>05721         <a class="code" href="version_8h.html#aa67c27a6835b76d1b01df29cb3dc9f07">PURPLE_MINOR_VERSION</a>,
<a name="l05722"></a>05722         <a class="code" href="plugin_8h.html#a0e1cfd7954f1157f5ed3ccb42e6f6d58a90cb9161ce675db7fdc7151ec09520cf">PURPLE_PLUGIN_PROTOCOL</a>,                           
<a name="l05723"></a>05723         NULL,                                             
<a name="l05724"></a>05724         0,                                                
<a name="l05725"></a>05725         NULL,                                             
<a name="l05726"></a>05726         PURPLE_PRIORITY_DEFAULT,                          
<a name="l05728"></a>05728         PLUGIN_ID,                                        
<a name="l05729"></a>05729         PLUGIN_NAME,                                      
<a name="l05730"></a>05730         DISPLAY_VERSION,                                  
<a name="l05731"></a>05731         PLUGIN_SUMMARY,                                   
<a name="l05732"></a>05732         PLUGIN_DESC,                                      
<a name="l05733"></a>05733         PLUGIN_AUTHOR,                                    
<a name="l05734"></a>05734         PLUGIN_HOMEPAGE,                                  
<a name="l05736"></a>05736         mw_plugin_load,                                   
<a name="l05737"></a>05737         mw_plugin_unload,                                 
<a name="l05738"></a>05738         mw_plugin_destroy,                                
<a name="l05740"></a>05740         NULL,                                             
<a name="l05741"></a>05741         &amp;mw_prpl_info,                                    
<a name="l05742"></a>05742         &amp;mw_plugin_ui_info,                               
<a name="l05743"></a>05743         mw_plugin_actions,
<a name="l05744"></a>05744 
<a name="l05745"></a>05745         <span class="comment">/* padding */</span>
<a name="l05746"></a>05746         NULL,
<a name="l05747"></a>05747         NULL,
<a name="l05748"></a>05748         NULL,
<a name="l05749"></a>05749         NULL
<a name="l05750"></a>05750 };
<a name="l05751"></a>05751 
<a name="l05752"></a>05752 
<a name="l05753"></a>05753 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_log_handler(<span class="keyword">const</span> gchar *domain, GLogLevelFlags flags,
<a name="l05754"></a>05754                            <span class="keyword">const</span> gchar *msg, gpointer data) {
<a name="l05755"></a>05755 
<a name="l05756"></a>05756   <span class="keywordflow">if</span>(! (msg &amp;&amp; *msg)) <span class="keywordflow">return</span>;
<a name="l05757"></a>05757 
<a name="l05758"></a>05758   <span class="comment">/* handle g_log requests via purple&#39;s built-in debug logging */</span>
<a name="l05759"></a>05759   <span class="keywordflow">if</span>(flags &amp; G_LOG_LEVEL_ERROR) {
<a name="l05760"></a>05760     <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(domain, <span class="stringliteral">&quot;%s\n&quot;</span>, msg);
<a name="l05761"></a>05761 
<a name="l05762"></a>05762   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flags &amp; G_LOG_LEVEL_WARNING) {
<a name="l05763"></a>05763     <a class="code" href="debug_8h.html#a73ce6863806209621433421e69487799">purple_debug_warning</a>(domain, <span class="stringliteral">&quot;%s\n&quot;</span>, msg);
<a name="l05764"></a>05764 
<a name="l05765"></a>05765   } <span class="keywordflow">else</span> {
<a name="l05766"></a>05766     <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(domain, <span class="stringliteral">&quot;%s\n&quot;</span>, msg);
<a name="l05767"></a>05767   }
<a name="l05768"></a>05768 }
<a name="l05769"></a>05769 
<a name="l05770"></a>05770 
<a name="l05771"></a>05771 <span class="keyword">static</span> <span class="keywordtype">void</span> mw_plugin_init(<a class="code" href="struct___purple_plugin.html">PurplePlugin</a> *plugin) {
<a name="l05772"></a>05772   <a class="code" href="struct_purple_account_user_split.html">PurpleAccountUserSplit</a> *split;
<a name="l05773"></a>05773   <a class="code" href="struct_purple_account_option.html">PurpleAccountOption</a> *opt;
<a name="l05774"></a>05774   GList *l = NULL;
<a name="l05775"></a>05775 
<a name="l05776"></a>05776   GLogLevelFlags logflags =
<a name="l05777"></a>05777     G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION;
<a name="l05778"></a>05778 
<a name="l05779"></a>05779   <span class="comment">/* set up the preferences */</span>
<a name="l05780"></a>05780   purple_prefs_add_none(MW_PRPL_OPT_BASE);
<a name="l05781"></a>05781   purple_prefs_add_int(MW_PRPL_OPT_BLIST_ACTION, BLIST_CHOICE_DEFAULT);
<a name="l05782"></a>05782 
<a name="l05783"></a>05783   <span class="comment">/* set up account ID as user:server */</span>
<a name="l05784"></a>05784   split = <a class="code" href="accountopt_8c.html#afed066e46252b20286dc386951bc0697">purple_account_user_split_new</a>(_(<span class="stringliteral">&quot;Server&quot;</span>),
<a name="l05785"></a>05785                                         MW_PLUGIN_DEFAULT_HOST, <span class="charliteral">&#39;:&#39;</span>);
<a name="l05786"></a>05786   mw_prpl_info.<a class="code" href="struct___purple_plugin_protocol_info.html#a391aa567d5f8ddbce0a819ac4f0d6690">user_splits</a> = g_list_append(mw_prpl_info.<a class="code" href="struct___purple_plugin_protocol_info.html#a391aa567d5f8ddbce0a819ac4f0d6690">user_splits</a>, split);
<a name="l05787"></a>05787 
<a name="l05788"></a>05788   <span class="comment">/* remove dead preferences */</span>
<a name="l05789"></a>05789   purple_prefs_remove(MW_PRPL_OPT_PSYCHIC);
<a name="l05790"></a>05790   purple_prefs_remove(MW_PRPL_OPT_SAVE_DYNAMIC);
<a name="l05791"></a>05791 
<a name="l05792"></a>05792   <span class="comment">/* port to connect to */</span>
<a name="l05793"></a>05793   opt = <a class="code" href="accountopt_8c.html#ad94515631fe798e67b9764c8265d9a81">purple_account_option_int_new</a>(_(<span class="stringliteral">&quot;Port&quot;</span>), MW_KEY_PORT,
<a name="l05794"></a>05794                                     MW_PLUGIN_DEFAULT_PORT);
<a name="l05795"></a>05795   l = g_list_append(l, opt);
<a name="l05796"></a>05796 
<a name="l05797"></a>05797   { <span class="comment">/* copy the old force login setting from prefs if it&#39;s</span>
<a name="l05798"></a>05798 <span class="comment">       there. Don&#39;t delete the preference, since there may be more</span>
<a name="l05799"></a>05799 <span class="comment">       than one account that wants to check for it. */</span>
<a name="l05800"></a>05800     gboolean b = FALSE;
<a name="l05801"></a>05801     <span class="keyword">const</span> <span class="keywordtype">char</span> *label = _(<span class="stringliteral">&quot;Force login (ignore server redirects)&quot;</span>);
<a name="l05802"></a>05802 
<a name="l05803"></a>05803     <span class="keywordflow">if</span>(purple_prefs_exists(MW_PRPL_OPT_FORCE_LOGIN))
<a name="l05804"></a>05804       b = purple_prefs_get_bool(MW_PRPL_OPT_FORCE_LOGIN);
<a name="l05805"></a>05805 
<a name="l05806"></a>05806     opt = <a class="code" href="accountopt_8c.html#a662eb355a6b261e78a55cf3df3d1667f">purple_account_option_bool_new</a>(label, MW_KEY_FORCE, b);
<a name="l05807"></a>05807     l = g_list_append(l, opt);
<a name="l05808"></a>05808   }
<a name="l05809"></a>05809 
<a name="l05810"></a>05810   <span class="comment">/* pretend to be Sametime Connect */</span>
<a name="l05811"></a>05811   opt = <a class="code" href="accountopt_8c.html#a662eb355a6b261e78a55cf3df3d1667f">purple_account_option_bool_new</a>(_(<span class="stringliteral">&quot;Hide client identity&quot;</span>),
<a name="l05812"></a>05812                                      MW_KEY_FAKE_IT, FALSE);
<a name="l05813"></a>05813   l = g_list_append(l, opt);
<a name="l05814"></a>05814 
<a name="l05815"></a>05815   mw_prpl_info.<a class="code" href="struct___purple_plugin_protocol_info.html#a7374e9c68494a9831f1d544e22471ad2">protocol_options</a> = l;
<a name="l05816"></a>05816   l = NULL;
<a name="l05817"></a>05817 
<a name="l05818"></a>05818   <span class="comment">/* forward all our g_log messages to purple. Generally all the logging</span>
<a name="l05819"></a>05819 <span class="comment">     calls are using purple_log directly, but the g_return macros will</span>
<a name="l05820"></a>05820 <span class="comment">     get caught here */</span>
<a name="l05821"></a>05821   log_handler[0] = g_log_set_handler(G_LOG_DOMAIN, logflags,
<a name="l05822"></a>05822                                      mw_log_handler, NULL);
<a name="l05823"></a>05823 
<a name="l05824"></a>05824   <span class="comment">/* redirect meanwhile&#39;s logging to purple&#39;s */</span>
<a name="l05825"></a>05825   log_handler[1] = g_log_set_handler(<span class="stringliteral">&quot;meanwhile&quot;</span>, logflags,
<a name="l05826"></a>05826                                      mw_log_handler, NULL);
<a name="l05827"></a>05827 }
<a name="l05828"></a>05828 
<a name="l05829"></a>05829 
<a name="l05830"></a>05830 PURPLE_INIT_PLUGIN(sametime, mw_plugin_init, mw_plugin_info);
<a name="l05831"></a>05831 <span class="comment">/* The End. */</span>
<a name="l05832"></a>05832 
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>sametime.c</b>      </li>
      <li class="footer">Generated on Sun Mar 24 2013 16:05:15 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
