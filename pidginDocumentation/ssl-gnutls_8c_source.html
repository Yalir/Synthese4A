<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plugins/ssl/ssl-gnutls.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('ssl-gnutls_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">plugins/ssl/ssl-gnutls.c</div>  </div>
</div>
<div class="contents">
<a href="ssl-gnutls_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;internal.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="debug_8h.html">debug.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="certificate_8h.html">certificate.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="plugin_8h.html">plugin.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="sslconn_8h.html">sslconn.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="version_8h.html">version.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="util_8h.html">util.h</a>&quot;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#define SSL_GNUTLS_PLUGIN_ID &quot;ssl-gnutls&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;gnutls/gnutls.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;gnutls/x509.h&gt;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a><a class="code" href="struct_purple_ssl_gnutls_data.html">00035</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00036"></a>00036 {
<a name="l00037"></a>00037         gnutls_session session;
<a name="l00038"></a>00038         guint handshake_handler;
<a name="l00039"></a>00039         guint handshake_timer;
<a name="l00040"></a>00040 } <a class="code" href="struct_purple_ssl_gnutls_data.html">PurpleSslGnutlsData</a>;
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#define PURPLE_SSL_GNUTLS_DATA(gsc) ((PurpleSslGnutlsData *)gsc-&gt;private_data)</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="keyword">static</span> gnutls_certificate_client_credentials xcred = NULL;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="preprocessor">#ifdef HAVE_GNUTLS_PRIORITY_FUNCS</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="comment">/* Priority strings.  The default one is, well, the default (and is always</span>
<a name="l00048"></a>00048 <span class="comment"> * set).  The hash table is of the form hostname =&gt; priority (both</span>
<a name="l00049"></a>00049 <span class="comment"> * char *).</span>
<a name="l00050"></a>00050 <span class="comment"> *</span>
<a name="l00051"></a>00051 <span class="comment"> * We only use a gnutls_priority_t for the default on the assumption that</span>
<a name="l00052"></a>00052 <span class="comment"> * that&#39;s the more common case.  Improvement patches (like matching on</span>
<a name="l00053"></a>00053 <span class="comment"> * subdomains) welcome.</span>
<a name="l00054"></a>00054 <span class="comment"> */</span>
<a name="l00055"></a>00055 <span class="keyword">static</span> gnutls_priority_t default_priority = NULL;
<a name="l00056"></a>00056 <span class="keyword">static</span> GHashTable *host_priorities = NULL;
<a name="l00057"></a>00057 <span class="preprocessor">#endif</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>
<a name="l00059"></a>00059 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00060"></a>00060 ssl_gnutls_log(<span class="keywordtype">int</span> level, <span class="keyword">const</span> <span class="keywordtype">char</span> *str)
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062         <span class="comment">/* GnuTLS log messages include the &#39;\n&#39; */</span>
<a name="l00063"></a>00063         <a class="code" href="debug_8h.html#a89b6474a316d3e177cc91b35897ae20a">purple_debug_misc</a>(<span class="stringliteral">&quot;gnutls&quot;</span>, <span class="stringliteral">&quot;lvl %d: %s&quot;</span>, level, str);
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00067"></a>00067 ssl_gnutls_init_gnutls(<span class="keywordtype">void</span>)
<a name="l00068"></a>00068 {
<a name="l00069"></a>00069         <span class="keyword">const</span> <span class="keywordtype">char</span> *debug_level;
<a name="l00070"></a>00070         <span class="keyword">const</span> <span class="keywordtype">char</span> *host_priorities_str;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072         <span class="comment">/* Configure GnuTLS to use glib memory management */</span>
<a name="l00073"></a>00073         <span class="comment">/* I expect that this isn&#39;t really necessary, but it may prevent</span>
<a name="l00074"></a>00074 <span class="comment">           some bugs */</span>
<a name="l00075"></a>00075         <span class="comment">/* TODO: It may be necessary to wrap this allocators for GnuTLS.</span>
<a name="l00076"></a>00076 <span class="comment">           If there are strange bugs, perhaps look here (yes, I am a</span>
<a name="l00077"></a>00077 <span class="comment">           hypocrite) */</span>
<a name="l00078"></a>00078         gnutls_global_set_mem_functions(
<a name="l00079"></a>00079                 (gnutls_alloc_function)   g_malloc, <span class="comment">/* malloc */</span>
<a name="l00080"></a>00080                 (gnutls_alloc_function)   g_malloc, <span class="comment">/* secure malloc */</span>
<a name="l00081"></a>00081                 NULL,      <span class="comment">/* mem_is_secure */</span>
<a name="l00082"></a>00082                 (gnutls_realloc_function) g_realloc, <span class="comment">/* realloc */</span>
<a name="l00083"></a>00083                 (gnutls_free_function)    g_free     <span class="comment">/* free */</span>
<a name="l00084"></a>00084                 );
<a name="l00085"></a>00085 
<a name="l00086"></a>00086         debug_level = g_getenv(<span class="stringliteral">&quot;PURPLE_GNUTLS_DEBUG&quot;</span>);
<a name="l00087"></a>00087         <span class="keywordflow">if</span> (debug_level) {
<a name="l00088"></a>00088                 <span class="keywordtype">int</span> level = atoi(debug_level);
<a name="l00089"></a>00089                 <span class="keywordflow">if</span> (level &lt; 0) {
<a name="l00090"></a>00090                         <a class="code" href="debug_8h.html#a73ce6863806209621433421e69487799">purple_debug_warning</a>(<span class="stringliteral">&quot;gnutls&quot;</span>, <span class="stringliteral">&quot;Assuming log level 0 instead of %d\n&quot;</span>,
<a name="l00091"></a>00091                                              level);
<a name="l00092"></a>00092                         level = 0;
<a name="l00093"></a>00093                 }
<a name="l00094"></a>00094 
<a name="l00095"></a>00095                 <span class="comment">/* &quot;The level is an integer between 0 and 9. Higher values mean more verbosity.&quot; */</span>
<a name="l00096"></a>00096                 gnutls_global_set_log_level(level);
<a name="l00097"></a>00097                 gnutls_global_set_log_function(ssl_gnutls_log);
<a name="l00098"></a>00098         }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100         <span class="comment">/* Expected format: host=priority;host2=priority;*=priority</span>
<a name="l00101"></a>00101 <span class="comment">         * where &quot;*&quot; is used to override the default priority string for</span>
<a name="l00102"></a>00102 <span class="comment">         * libpurple.</span>
<a name="l00103"></a>00103 <span class="comment">         */</span>
<a name="l00104"></a>00104         host_priorities_str = g_getenv(<span class="stringliteral">&quot;PURPLE_GNUTLS_PRIORITIES&quot;</span>);
<a name="l00105"></a>00105         <span class="keywordflow">if</span> (host_priorities_str) {
<a name="l00106"></a>00106 <span class="preprocessor">#ifndef HAVE_GNUTLS_PRIORITY_FUNCS</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span>                <a class="code" href="debug_8h.html#a73ce6863806209621433421e69487799">purple_debug_warning</a>(<span class="stringliteral">&quot;gnutls&quot;</span>, <span class="stringliteral">&quot;Warning, PURPLE_GNUTLS_PRIORITIES &quot;</span>
<a name="l00108"></a>00108                                      <span class="stringliteral">&quot;environment variable set, but we were built &quot;</span>
<a name="l00109"></a>00109                                      <span class="stringliteral">&quot;against an older GnuTLS that doesn&#39;t support &quot;</span>
<a name="l00110"></a>00110                                      <span class="stringliteral">&quot;this. :-(&quot;</span>);
<a name="l00111"></a>00111 <span class="preprocessor">#else </span><span class="comment">/* HAVE_GNUTLS_PRIORITY_FUNCS */</span>
<a name="l00112"></a>00112                 <span class="keywordtype">char</span> **entries = g_strsplit(host_priorities_str, <span class="stringliteral">&quot;;&quot;</span>, -1);
<a name="l00113"></a>00113                 <span class="keywordtype">char</span> *default_priority_str = NULL;
<a name="l00114"></a>00114                 guint i;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116                 host_priorities = g_hash_table_new_full(g_str_hash, g_str_equal,
<a name="l00117"></a>00117                                                         g_free, g_free);
<a name="l00118"></a>00118 
<a name="l00119"></a>00119                 <span class="keywordflow">for</span> (i = 0; entries[i]; ++i) {
<a name="l00120"></a>00120                         <span class="keywordtype">char</span> *host = entries[i];
<a name="l00121"></a>00121                         <span class="keywordtype">char</span> *equals = strchr(host, <span class="charliteral">&#39;=&#39;</span>);
<a name="l00122"></a>00122                         <span class="keywordtype">char</span> *prio_str;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124                         <span class="keywordflow">if</span> (equals) {
<a name="l00125"></a>00125                                 *equals = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00126"></a>00126                                 prio_str = equals + 1;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128                                 <span class="comment">/* Empty? */</span>
<a name="l00129"></a>00129                                 <span class="keywordflow">if</span> (*prio_str == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00130"></a>00130                                         <a class="code" href="debug_8h.html#a73ce6863806209621433421e69487799">purple_debug_warning</a>(<span class="stringliteral">&quot;gnutls&quot;</span>, <span class="stringliteral">&quot;Ignoring empty priority &quot;</span>
<a name="l00131"></a>00131                                                                        <span class="stringliteral">&quot;string for %s\n&quot;</span>, host);
<a name="l00132"></a>00132                                 } <span class="keywordflow">else</span> {
<a name="l00133"></a>00133                                         <span class="comment">/* TODO: Validate each of these and complain */</span>
<a name="l00134"></a>00134                                         <span class="keywordflow">if</span> (g_str_equal(host, <span class="stringliteral">&quot;*&quot;</span>)) {
<a name="l00135"></a>00135                                                 <span class="comment">/* Override the default priority */</span>
<a name="l00136"></a>00136                                                 g_free(default_priority_str);
<a name="l00137"></a>00137                                                 default_priority_str = g_strdup(prio_str);
<a name="l00138"></a>00138                                         } <span class="keywordflow">else</span>
<a name="l00139"></a>00139                                                 g_hash_table_insert(host_priorities, g_strdup(host),
<a name="l00140"></a>00140                                                                     g_strdup(prio_str));
<a name="l00141"></a>00141                                 }
<a name="l00142"></a>00142                         }
<a name="l00143"></a>00143                 }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145                 <span class="keywordflow">if</span> (default_priority_str) {
<a name="l00146"></a>00146                         <span class="keywordflow">if</span> (gnutls_priority_init(&amp;default_priority, default_priority_str, NULL)) {
<a name="l00147"></a>00147                                 <a class="code" href="debug_8h.html#a73ce6863806209621433421e69487799">purple_debug_warning</a>(<span class="stringliteral">&quot;gnutls&quot;</span>, <span class="stringliteral">&quot;Unable to set default priority to %s\n&quot;</span>,
<a name="l00148"></a>00148                                                      default_priority_str);
<a name="l00149"></a>00149                                 <span class="comment">/* Versions of GnuTLS as of 2.8.6 (2010-03-31) don&#39;t free/NULL</span>
<a name="l00150"></a>00150 <span class="comment">                                 * this on error.</span>
<a name="l00151"></a>00151 <span class="comment">                                 */</span>
<a name="l00152"></a>00152                                 gnutls_free(default_priority);
<a name="l00153"></a>00153                                 default_priority = NULL;
<a name="l00154"></a>00154                         }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156                         g_free(default_priority_str);
<a name="l00157"></a>00157                 }
<a name="l00158"></a>00158 
<a name="l00159"></a>00159                 g_strfreev(entries);
<a name="l00160"></a>00160 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_GNUTLS_PRIORITY_FUNCS */</span>
<a name="l00161"></a>00161         }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="preprocessor">#ifdef HAVE_GNUTLS_PRIORITY_FUNCS</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span>        <span class="comment">/* Make sure we set have a default priority! */</span>
<a name="l00165"></a>00165         <span class="keywordflow">if</span> (!default_priority) {
<a name="l00166"></a>00166                 <span class="keywordflow">if</span> (gnutls_priority_init(&amp;default_priority, <span class="stringliteral">&quot;NORMAL:%SSL3_RECORD_VERSION&quot;</span>, NULL)) {
<a name="l00167"></a>00167                         <span class="comment">/* See comment above about memory leak */</span>
<a name="l00168"></a>00168                         gnutls_free(default_priority);
<a name="l00169"></a>00169                         gnutls_priority_init(&amp;default_priority, <span class="stringliteral">&quot;NORMAL&quot;</span>, NULL);
<a name="l00170"></a>00170                 }
<a name="l00171"></a>00171         }
<a name="l00172"></a>00172 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_GNUTLS_PRIORITY_FUNCS */</span>
<a name="l00173"></a>00173 
<a name="l00174"></a>00174         gnutls_global_init();
<a name="l00175"></a>00175 
<a name="l00176"></a>00176         gnutls_certificate_allocate_credentials(&amp;xcred);
<a name="l00177"></a>00177 
<a name="l00178"></a>00178         <span class="comment">/* TODO: I can likely remove this */</span>
<a name="l00179"></a>00179         gnutls_certificate_set_x509_trust_file(xcred, <span class="stringliteral">&quot;ca.pem&quot;</span>,
<a name="l00180"></a>00180                 GNUTLS_X509_FMT_PEM);
<a name="l00181"></a>00181 }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="keyword">static</span> gboolean
<a name="l00184"></a>00184 ssl_gnutls_init(<span class="keywordtype">void</span>)
<a name="l00185"></a>00185 {
<a name="l00186"></a>00186         <span class="keywordflow">return</span> TRUE;
<a name="l00187"></a>00187 }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00190"></a>00190 ssl_gnutls_uninit(<span class="keywordtype">void</span>)
<a name="l00191"></a>00191 {
<a name="l00192"></a>00192         gnutls_global_deinit();
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         gnutls_certificate_free_credentials(xcred);
<a name="l00195"></a>00195         xcred = NULL;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="preprocessor">#ifdef HAVE_GNUTLS_PRIORITY_FUNCS</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (host_priorities) {
<a name="l00199"></a>00199                 g_hash_table_destroy(host_priorities);
<a name="l00200"></a>00200                 host_priorities = NULL;
<a name="l00201"></a>00201         }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         gnutls_priority_deinit(default_priority);
<a name="l00204"></a>00204         default_priority = NULL;
<a name="l00205"></a>00205 <span class="preprocessor">#endif</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span>}
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00209"></a>00209 ssl_gnutls_verified_cb(PurpleCertificateVerificationStatus st,
<a name="l00210"></a>00210                        gpointer userdata)
<a name="l00211"></a>00211 {
<a name="l00212"></a>00212         <a class="code" href="struct___purple_ssl_connection.html">PurpleSslConnection</a> *gsc = (<a class="code" href="struct___purple_ssl_connection.html">PurpleSslConnection</a> *) userdata;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (st == PURPLE_CERTIFICATE_VALID) {
<a name="l00215"></a>00215                 <span class="comment">/* Certificate valid? Good! Do the connection! */</span>
<a name="l00216"></a>00216                 gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a439700f2b4e3568fec14a787176de873">connect_cb</a>(gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a4d6e5627e1a64b9e17edb6270d4460c9">connect_cb_data</a>, gsc, <a class="code" href="eventloop_8h.html#ae16a4b18f1da57dff1eb139e934fffb3a04a9339a9f5df8019b8afc3af679ec9e">PURPLE_INPUT_READ</a>);
<a name="l00217"></a>00217         } <span class="keywordflow">else</span> {
<a name="l00218"></a>00218                 <span class="comment">/* Otherwise, signal an error */</span>
<a name="l00219"></a>00219                 <span class="keywordflow">if</span>(gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a1d0230e7919e2cd8c4f0c21d1191a0b5">error_cb</a> != NULL)
<a name="l00220"></a>00220                         gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a1d0230e7919e2cd8c4f0c21d1191a0b5">error_cb</a>(gsc, PURPLE_SSL_CERTIFICATE_INVALID,
<a name="l00221"></a>00221                                       gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a4d6e5627e1a64b9e17edb6270d4460c9">connect_cb_data</a>);
<a name="l00222"></a>00222                 purple_ssl_close(gsc);
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224 }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="keyword">static</span> <span class="keywordtype">void</span> ssl_gnutls_handshake_cb(gpointer data, gint source,
<a name="l00229"></a>00229                 <a class="code" href="eventloop_8h.html#ae16a4b18f1da57dff1eb139e934fffb3">PurpleInputCondition</a> cond)
<a name="l00230"></a>00230 {
<a name="l00231"></a>00231         <a class="code" href="struct___purple_ssl_connection.html">PurpleSslConnection</a> *gsc = data;
<a name="l00232"></a>00232         <a class="code" href="struct_purple_ssl_gnutls_data.html">PurpleSslGnutlsData</a> *gnutls_data = PURPLE_SSL_GNUTLS_DATA(gsc);
<a name="l00233"></a>00233         ssize_t ret;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235         <span class="comment">/*purple_debug_info(&quot;gnutls&quot;, &quot;Handshaking with %s\n&quot;, gsc-&gt;host);*/</span>
<a name="l00236"></a>00236         ret = gnutls_handshake(gnutls_data-&gt;session);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         <span class="keywordflow">if</span>(ret == GNUTLS_E_AGAIN || ret == GNUTLS_E_INTERRUPTED)
<a name="l00239"></a>00239                 <span class="keywordflow">return</span>;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241         <a class="code" href="eventloop_8c.html#ae309cb053b0e7984f10d9886367ed84e">purple_input_remove</a>(gnutls_data-&gt;handshake_handler);
<a name="l00242"></a>00242         gnutls_data-&gt;handshake_handler = 0;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244         <span class="keywordflow">if</span>(ret != 0) {
<a name="l00245"></a>00245                 <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls&quot;</span>, <span class="stringliteral">&quot;Handshake failed. Error %s\n&quot;</span>,
<a name="l00246"></a>00246                         gnutls_strerror(ret));
<a name="l00247"></a>00247 
<a name="l00248"></a>00248                 <span class="keywordflow">if</span>(gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a1d0230e7919e2cd8c4f0c21d1191a0b5">error_cb</a> != NULL)
<a name="l00249"></a>00249                         gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a1d0230e7919e2cd8c4f0c21d1191a0b5">error_cb</a>(gsc, PURPLE_SSL_HANDSHAKE_FAILED,
<a name="l00250"></a>00250                                 gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a4d6e5627e1a64b9e17edb6270d4460c9">connect_cb_data</a>);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252                 purple_ssl_close(gsc);
<a name="l00253"></a>00253         } <span class="keywordflow">else</span> {
<a name="l00254"></a>00254                 <span class="comment">/* Now we are cooking with gas! */</span>
<a name="l00255"></a>00255                 <a class="code" href="struct_purple_ssl_ops.html">PurpleSslOps</a> *ops = purple_ssl_get_ops();
<a name="l00256"></a>00256                 GList * peers = ops-&gt;<a class="code" href="struct_purple_ssl_ops.html#a8b1d17d54225006f010c64b9afbafac9">get_peer_certificates</a>(gsc);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258                 <a class="code" href="struct___purple_certificate_scheme.html">PurpleCertificateScheme</a> *x509 =
<a name="l00259"></a>00259                         purple_certificate_find_scheme(<span class="stringliteral">&quot;x509&quot;</span>);
<a name="l00260"></a>00260 
<a name="l00261"></a>00261                 GList * l;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263                 <span class="comment">/* TODO: Remove all this debugging babble */</span>
<a name="l00264"></a>00264                 <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(<span class="stringliteral">&quot;gnutls&quot;</span>, <span class="stringliteral">&quot;Handshake complete\n&quot;</span>);
<a name="l00265"></a>00265 
<a name="l00266"></a>00266                 <span class="keywordflow">for</span> (l=peers; l; l = l-&gt;next) {
<a name="l00267"></a>00267                         <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *crt = l-&gt;<a class="code" href="struct___purple_certificate.html#ac2d150b349f3d00b3c333b5e16c30449">data</a>;
<a name="l00268"></a>00268                         GByteArray *z =
<a name="l00269"></a>00269                                 x509-&gt;<a class="code" href="struct___purple_certificate_scheme.html#a1e47b38750186ba7314c6a383c7d70e1">get_fingerprint_sha1</a>(crt);
<a name="l00270"></a>00270                         gchar * fpr =
<a name="l00271"></a>00271                                 purple_base16_encode_chunked(z-&gt;data,
<a name="l00272"></a>00272                                                              z-&gt;len);
<a name="l00273"></a>00273 
<a name="l00274"></a>00274                         <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(<span class="stringliteral">&quot;gnutls/x509&quot;</span>,
<a name="l00275"></a>00275                                           <span class="stringliteral">&quot;Key print: %s\n&quot;</span>,
<a name="l00276"></a>00276                                           fpr);
<a name="l00277"></a>00277 
<a name="l00278"></a>00278                         <span class="comment">/* Kill the cert! */</span>
<a name="l00279"></a>00279                         x509-&gt;<a class="code" href="struct___purple_certificate_scheme.html#aa5a279ad03536b0e476a524ae6996b07">destroy_certificate</a>(crt);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281                         g_free(fpr);
<a name="l00282"></a>00282                         g_byte_array_free(z, TRUE);
<a name="l00283"></a>00283                 }
<a name="l00284"></a>00284                 g_list_free(peers);
<a name="l00285"></a>00285 
<a name="l00286"></a>00286                 {
<a name="l00287"></a>00287                         <span class="keyword">const</span> gnutls_datum *cert_list;
<a name="l00288"></a>00288                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cert_list_size = 0;
<a name="l00289"></a>00289                         gnutls_session session=gnutls_data-&gt;session;
<a name="l00290"></a>00290                         <span class="keywordtype">int</span> i;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292                         cert_list =
<a name="l00293"></a>00293                                 gnutls_certificate_get_peers(session, &amp;cert_list_size);
<a name="l00294"></a>00294 
<a name="l00295"></a>00295                         <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(<span class="stringliteral">&quot;gnutls&quot;</span>,
<a name="l00296"></a>00296                                             <span class="stringliteral">&quot;Peer provided %d certs\n&quot;</span>,
<a name="l00297"></a>00297                                             cert_list_size);
<a name="l00298"></a>00298                         <span class="keywordflow">for</span> (i=0; i&lt;cert_list_size; i++)
<a name="l00299"></a>00299                         {
<a name="l00300"></a>00300                                 gchar fpr_bin[256];
<a name="l00301"></a>00301                                 gsize fpr_bin_sz = <span class="keyword">sizeof</span>(fpr_bin);
<a name="l00302"></a>00302                                 gchar * fpr_asc = NULL;
<a name="l00303"></a>00303                                 gchar tbuf[256];
<a name="l00304"></a>00304                                 gsize tsz=<span class="keyword">sizeof</span>(tbuf);
<a name="l00305"></a>00305                                 gchar * tasc = NULL;
<a name="l00306"></a>00306                                 gnutls_x509_crt cert;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308                                 gnutls_x509_crt_init(&amp;cert);
<a name="l00309"></a>00309                                 gnutls_x509_crt_import (cert, &amp;cert_list[i],
<a name="l00310"></a>00310                                                 GNUTLS_X509_FMT_DER);
<a name="l00311"></a>00311 
<a name="l00312"></a>00312                                 gnutls_x509_crt_get_fingerprint(cert, GNUTLS_MAC_SHA,
<a name="l00313"></a>00313                                                 fpr_bin, &amp;fpr_bin_sz);
<a name="l00314"></a>00314 
<a name="l00315"></a>00315                                 fpr_asc =
<a name="l00316"></a>00316                                                 purple_base16_encode_chunked((<span class="keyword">const</span> guchar *)fpr_bin, fpr_bin_sz);
<a name="l00317"></a>00317 
<a name="l00318"></a>00318                                 <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(<span class="stringliteral">&quot;gnutls&quot;</span>,
<a name="l00319"></a>00319                                                 <span class="stringliteral">&quot;Lvl %d SHA1 fingerprint: %s\n&quot;</span>,
<a name="l00320"></a>00320                                                 i, fpr_asc);
<a name="l00321"></a>00321 
<a name="l00322"></a>00322                                 tsz=<span class="keyword">sizeof</span>(tbuf);
<a name="l00323"></a>00323                                 gnutls_x509_crt_get_serial(cert,tbuf,&amp;tsz);
<a name="l00324"></a>00324                                 tasc=purple_base16_encode_chunked((<span class="keyword">const</span> guchar *)tbuf, tsz);
<a name="l00325"></a>00325                                 <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(<span class="stringliteral">&quot;gnutls&quot;</span>,
<a name="l00326"></a>00326                                                 <span class="stringliteral">&quot;Serial: %s\n&quot;</span>,
<a name="l00327"></a>00327                                                 tasc);
<a name="l00328"></a>00328                                 g_free(tasc);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330                                 tsz=<span class="keyword">sizeof</span>(tbuf);
<a name="l00331"></a>00331                                 gnutls_x509_crt_get_dn (cert, tbuf, &amp;tsz);
<a name="l00332"></a>00332                                 <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(<span class="stringliteral">&quot;gnutls&quot;</span>,
<a name="l00333"></a>00333                                                 <span class="stringliteral">&quot;Cert DN: %s\n&quot;</span>,
<a name="l00334"></a>00334                                                 tbuf);
<a name="l00335"></a>00335                                 tsz=<span class="keyword">sizeof</span>(tbuf);
<a name="l00336"></a>00336                                 gnutls_x509_crt_get_issuer_dn (cert, tbuf, &amp;tsz);
<a name="l00337"></a>00337                                 <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(<span class="stringliteral">&quot;gnutls&quot;</span>,
<a name="l00338"></a>00338                                                 <span class="stringliteral">&quot;Cert Issuer DN: %s\n&quot;</span>,
<a name="l00339"></a>00339                                                 tbuf);
<a name="l00340"></a>00340 
<a name="l00341"></a>00341                                 g_free(fpr_asc);
<a name="l00342"></a>00342                                 fpr_asc = NULL;
<a name="l00343"></a>00343                                 gnutls_x509_crt_deinit(cert);
<a name="l00344"></a>00344                         }
<a name="l00345"></a>00345                 }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347                 <span class="comment">/* TODO: The following logic should really be in libpurple */</span>
<a name="l00348"></a>00348                 <span class="comment">/* If a Verifier was given, hand control over to it */</span>
<a name="l00349"></a>00349                 <span class="keywordflow">if</span> (gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#acaa17acd2bdd2bdccf6b4cffd2481c90">verifier</a>) {
<a name="l00350"></a>00350                         GList *peers;
<a name="l00351"></a>00351                         <span class="comment">/* First, get the peer cert chain */</span>
<a name="l00352"></a>00352                         peers = purple_ssl_get_peer_certificates(gsc);
<a name="l00353"></a>00353 
<a name="l00354"></a>00354                         <span class="comment">/* Now kick off the verification process */</span>
<a name="l00355"></a>00355                         purple_certificate_verify(gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#acaa17acd2bdd2bdccf6b4cffd2481c90">verifier</a>,
<a name="l00356"></a>00356                                                   gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a30b603b1954be6113242ec013680f3a4">host</a>,
<a name="l00357"></a>00357                                                   peers,
<a name="l00358"></a>00358                                                   ssl_gnutls_verified_cb,
<a name="l00359"></a>00359                                                   gsc);
<a name="l00360"></a>00360 
<a name="l00361"></a>00361                         purple_certificate_destroy_list(peers);
<a name="l00362"></a>00362                 } <span class="keywordflow">else</span> {
<a name="l00363"></a>00363                         <span class="comment">/* Otherwise, just call the &quot;connection complete&quot;</span>
<a name="l00364"></a>00364 <span class="comment">                           callback */</span>
<a name="l00365"></a>00365                         gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a439700f2b4e3568fec14a787176de873">connect_cb</a>(gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a4d6e5627e1a64b9e17edb6270d4460c9">connect_cb_data</a>, gsc, cond);
<a name="l00366"></a>00366                 }
<a name="l00367"></a>00367         }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 }
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 <span class="keyword">static</span> gboolean
<a name="l00372"></a>00372 start_handshake_cb(gpointer data)
<a name="l00373"></a>00373 {
<a name="l00374"></a>00374         <a class="code" href="struct___purple_ssl_connection.html">PurpleSslConnection</a> *gsc = data;
<a name="l00375"></a>00375         <a class="code" href="struct_purple_ssl_gnutls_data.html">PurpleSslGnutlsData</a> *gnutls_data = PURPLE_SSL_GNUTLS_DATA(gsc);
<a name="l00376"></a>00376 
<a name="l00377"></a>00377         <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(<span class="stringliteral">&quot;gnutls&quot;</span>, <span class="stringliteral">&quot;Starting handshake with %s\n&quot;</span>, gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a30b603b1954be6113242ec013680f3a4">host</a>);
<a name="l00378"></a>00378 
<a name="l00379"></a>00379         gnutls_data-&gt;handshake_timer = 0;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381         ssl_gnutls_handshake_cb(gsc, gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a96fc1a70065540dbf86d704d46382100">fd</a>, <a class="code" href="eventloop_8h.html#ae16a4b18f1da57dff1eb139e934fffb3a04a9339a9f5df8019b8afc3af679ec9e">PURPLE_INPUT_READ</a>);
<a name="l00382"></a>00382         <span class="keywordflow">return</span> FALSE;
<a name="l00383"></a>00383 }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00386"></a>00386 ssl_gnutls_connect(<a class="code" href="struct___purple_ssl_connection.html">PurpleSslConnection</a> *gsc)
<a name="l00387"></a>00387 {
<a name="l00388"></a>00388         <a class="code" href="struct_purple_ssl_gnutls_data.html">PurpleSslGnutlsData</a> *gnutls_data;
<a name="l00389"></a>00389         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> cert_type_priority[2] = { GNUTLS_CRT_X509, 0 };
<a name="l00390"></a>00390 
<a name="l00391"></a>00391         gnutls_data = g_new0(<a class="code" href="struct_purple_ssl_gnutls_data.html">PurpleSslGnutlsData</a>, 1);
<a name="l00392"></a>00392         gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a93a75a9c2aab285e1997e775b9be60a6">private_data</a> = gnutls_data;
<a name="l00393"></a>00393 
<a name="l00394"></a>00394         gnutls_init(&amp;gnutls_data-&gt;session, GNUTLS_CLIENT);
<a name="l00395"></a>00395 <span class="preprocessor">#ifdef HAVE_GNUTLS_PRIORITY_FUNCS</span>
<a name="l00396"></a>00396 <span class="preprocessor"></span>        {
<a name="l00397"></a>00397                 <span class="keyword">const</span> <span class="keywordtype">char</span> *prio_str = NULL;
<a name="l00398"></a>00398                 gboolean <span class="keyword">set</span> = FALSE;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400                 <span class="comment">/* Let&#39;s see if someone has specified a specific priority */</span>
<a name="l00401"></a>00401                 <span class="keywordflow">if</span> (gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a30b603b1954be6113242ec013680f3a4">host</a> &amp;&amp; host_priorities)
<a name="l00402"></a>00402                         prio_str = g_hash_table_lookup(host_priorities, gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a30b603b1954be6113242ec013680f3a4">host</a>);
<a name="l00403"></a>00403 
<a name="l00404"></a>00404                 <span class="keywordflow">if</span> (prio_str)
<a name="l00405"></a>00405                         <span class="keyword">set</span> = (GNUTLS_E_SUCCESS ==
<a name="l00406"></a>00406                                         gnutls_priority_set_direct(gnutls_data-&gt;session, prio_str,
<a name="l00407"></a>00407                                                                NULL));
<a name="l00408"></a>00408 
<a name="l00409"></a>00409                 <span class="keywordflow">if</span> (!<span class="keyword">set</span>)
<a name="l00410"></a>00410                         gnutls_priority_set(gnutls_data-&gt;session, default_priority);
<a name="l00411"></a>00411         }
<a name="l00412"></a>00412 <span class="preprocessor">#else</span>
<a name="l00413"></a>00413 <span class="preprocessor"></span>        gnutls_set_default_priority(gnutls_data-&gt;session);
<a name="l00414"></a>00414 <span class="preprocessor">#endif</span>
<a name="l00415"></a>00415 <span class="preprocessor"></span>
<a name="l00416"></a>00416         gnutls_certificate_type_set_priority(gnutls_data-&gt;session,
<a name="l00417"></a>00417                 cert_type_priority);
<a name="l00418"></a>00418 
<a name="l00419"></a>00419         gnutls_credentials_set(gnutls_data-&gt;session, GNUTLS_CRD_CERTIFICATE,
<a name="l00420"></a>00420                 xcred);
<a name="l00421"></a>00421 
<a name="l00422"></a>00422         gnutls_transport_set_ptr(gnutls_data-&gt;session, GINT_TO_POINTER(gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a96fc1a70065540dbf86d704d46382100">fd</a>));
<a name="l00423"></a>00423 
<a name="l00424"></a>00424         gnutls_data-&gt;handshake_handler = <a class="code" href="eventloop_8c.html#ad4f7f5fdc0ee617d0e3fe358f04f838b">purple_input_add</a>(gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a96fc1a70065540dbf86d704d46382100">fd</a>,
<a name="l00425"></a>00425                 <a class="code" href="eventloop_8h.html#ae16a4b18f1da57dff1eb139e934fffb3a04a9339a9f5df8019b8afc3af679ec9e">PURPLE_INPUT_READ</a>, ssl_gnutls_handshake_cb, gsc);
<a name="l00426"></a>00426 
<a name="l00427"></a>00427         <span class="comment">/* Orborde asks: Why are we configuring a callback, then</span>
<a name="l00428"></a>00428 <span class="comment">           (almost) immediately calling it?</span>
<a name="l00429"></a>00429 <span class="comment"></span>
<a name="l00430"></a>00430 <span class="comment">           Answer: gnutls_handshake (up in handshake_cb) needs to be called</span>
<a name="l00431"></a>00431 <span class="comment">           once in order to get the ball rolling on the SSL connection.</span>
<a name="l00432"></a>00432 <span class="comment">           Once it has done so, only then will the server reply, triggering</span>
<a name="l00433"></a>00433 <span class="comment">           the callback.</span>
<a name="l00434"></a>00434 <span class="comment"></span>
<a name="l00435"></a>00435 <span class="comment">           Since the logic driving gnutls_handshake is the same with the first</span>
<a name="l00436"></a>00436 <span class="comment">           and subsequent calls, we&#39;ll just fire the callback immediately to</span>
<a name="l00437"></a>00437 <span class="comment">           accomplish this.</span>
<a name="l00438"></a>00438 <span class="comment">        */</span>
<a name="l00439"></a>00439         gnutls_data-&gt;handshake_timer = <a class="code" href="eventloop_8c.html#aadefb8b6d8b677ba989e47cbf8a05806">purple_timeout_add</a>(0, start_handshake_cb,
<a name="l00440"></a>00440                                                           gsc);
<a name="l00441"></a>00441 }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00444"></a>00444 ssl_gnutls_close(<a class="code" href="struct___purple_ssl_connection.html">PurpleSslConnection</a> *gsc)
<a name="l00445"></a>00445 {
<a name="l00446"></a>00446         <a class="code" href="struct_purple_ssl_gnutls_data.html">PurpleSslGnutlsData</a> *gnutls_data = PURPLE_SSL_GNUTLS_DATA(gsc);
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         <span class="keywordflow">if</span>(!gnutls_data)
<a name="l00449"></a>00449                 <span class="keywordflow">return</span>;
<a name="l00450"></a>00450 
<a name="l00451"></a>00451         <span class="keywordflow">if</span>(gnutls_data-&gt;handshake_handler)
<a name="l00452"></a>00452                 <a class="code" href="eventloop_8c.html#ae309cb053b0e7984f10d9886367ed84e">purple_input_remove</a>(gnutls_data-&gt;handshake_handler);
<a name="l00453"></a>00453         <span class="keywordflow">if</span> (gnutls_data-&gt;handshake_timer)
<a name="l00454"></a>00454                 <a class="code" href="eventloop_8c.html#aa63215615dfb1d5e8e61612520e5ec27">purple_timeout_remove</a>(gnutls_data-&gt;handshake_timer);
<a name="l00455"></a>00455 
<a name="l00456"></a>00456         gnutls_bye(gnutls_data-&gt;session, GNUTLS_SHUT_RDWR);
<a name="l00457"></a>00457 
<a name="l00458"></a>00458         gnutls_deinit(gnutls_data-&gt;session);
<a name="l00459"></a>00459 
<a name="l00460"></a>00460         g_free(gnutls_data);
<a name="l00461"></a>00461         gsc-&gt;<a class="code" href="struct___purple_ssl_connection.html#a93a75a9c2aab285e1997e775b9be60a6">private_data</a> = NULL;
<a name="l00462"></a>00462 }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="keyword">static</span> <span class="keywordtype">size_t</span>
<a name="l00465"></a>00465 ssl_gnutls_read(<a class="code" href="struct___purple_ssl_connection.html">PurpleSslConnection</a> *gsc, <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> len)
<a name="l00466"></a>00466 {
<a name="l00467"></a>00467         <a class="code" href="struct_purple_ssl_gnutls_data.html">PurpleSslGnutlsData</a> *gnutls_data = PURPLE_SSL_GNUTLS_DATA(gsc);
<a name="l00468"></a>00468         ssize_t s;
<a name="l00469"></a>00469 
<a name="l00470"></a>00470         s = gnutls_record_recv(gnutls_data-&gt;session, data, len);
<a name="l00471"></a>00471 
<a name="l00472"></a>00472         <span class="keywordflow">if</span>(s == GNUTLS_E_AGAIN || s == GNUTLS_E_INTERRUPTED) {
<a name="l00473"></a>00473                 s = -1;
<a name="l00474"></a>00474                 errno = EAGAIN;
<a name="l00475"></a>00475         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(s &lt; 0) {
<a name="l00476"></a>00476                 <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls&quot;</span>, <span class="stringliteral">&quot;receive failed: %s\n&quot;</span>,
<a name="l00477"></a>00477                                 gnutls_strerror(s));
<a name="l00478"></a>00478                 s = -1;
<a name="l00479"></a>00479                 <span class="comment">/*</span>
<a name="l00480"></a>00480 <span class="comment">                 * TODO: Set errno to something more appropriate.  Or even</span>
<a name="l00481"></a>00481 <span class="comment">                 *       better: allow ssl plugins to keep track of their</span>
<a name="l00482"></a>00482 <span class="comment">                 *       own error message, then add a new ssl_ops function</span>
<a name="l00483"></a>00483 <span class="comment">                 *       that returns the error message.</span>
<a name="l00484"></a>00484 <span class="comment">                 */</span>
<a name="l00485"></a>00485                 errno = EIO;
<a name="l00486"></a>00486         }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         <span class="keywordflow">return</span> s;
<a name="l00489"></a>00489 }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="keyword">static</span> <span class="keywordtype">size_t</span>
<a name="l00492"></a>00492 ssl_gnutls_write(<a class="code" href="struct___purple_ssl_connection.html">PurpleSslConnection</a> *gsc, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> len)
<a name="l00493"></a>00493 {
<a name="l00494"></a>00494         <a class="code" href="struct_purple_ssl_gnutls_data.html">PurpleSslGnutlsData</a> *gnutls_data = PURPLE_SSL_GNUTLS_DATA(gsc);
<a name="l00495"></a>00495         ssize_t s = 0;
<a name="l00496"></a>00496 
<a name="l00497"></a>00497         <span class="comment">/* XXX: when will gnutls_data be NULL? */</span>
<a name="l00498"></a>00498         <span class="keywordflow">if</span>(gnutls_data)
<a name="l00499"></a>00499                 s = gnutls_record_send(gnutls_data-&gt;session, data, len);
<a name="l00500"></a>00500 
<a name="l00501"></a>00501         <span class="keywordflow">if</span>(s == GNUTLS_E_AGAIN || s == GNUTLS_E_INTERRUPTED) {
<a name="l00502"></a>00502                 s = -1;
<a name="l00503"></a>00503                 errno = EAGAIN;
<a name="l00504"></a>00504         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(s &lt; 0) {
<a name="l00505"></a>00505                 <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls&quot;</span>, <span class="stringliteral">&quot;send failed: %s\n&quot;</span>,
<a name="l00506"></a>00506                                 gnutls_strerror(s));
<a name="l00507"></a>00507                 s = -1;
<a name="l00508"></a>00508                 <span class="comment">/*</span>
<a name="l00509"></a>00509 <span class="comment">                 * TODO: Set errno to something more appropriate.  Or even</span>
<a name="l00510"></a>00510 <span class="comment">                 *       better: allow ssl plugins to keep track of their</span>
<a name="l00511"></a>00511 <span class="comment">                 *       own error message, then add a new ssl_ops function</span>
<a name="l00512"></a>00512 <span class="comment">                 *       that returns the error message.</span>
<a name="l00513"></a>00513 <span class="comment">                 */</span>
<a name="l00514"></a>00514                 errno = EIO;
<a name="l00515"></a>00515         }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517         <span class="keywordflow">return</span> s;
<a name="l00518"></a>00518 }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 <span class="comment">/* Forward declarations are fun! */</span>
<a name="l00521"></a>00521 <span class="keyword">static</span> <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *
<a name="l00522"></a>00522 x509_import_from_datum(<span class="keyword">const</span> gnutls_datum dt, gnutls_x509_crt_fmt mode);
<a name="l00523"></a>00523 <span class="comment">/* indeed! */</span>
<a name="l00524"></a>00524 <span class="keyword">static</span> gboolean
<a name="l00525"></a>00525 x509_certificate_signed_by(<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> * crt,
<a name="l00526"></a>00526                            <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> * issuer);
<a name="l00527"></a>00527 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00528"></a>00528 x509_destroy_certificate(<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> * crt);
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="keyword">static</span> GList *
<a name="l00531"></a>00531 ssl_gnutls_get_peer_certificates(<a class="code" href="struct___purple_ssl_connection.html">PurpleSslConnection</a> * gsc)
<a name="l00532"></a>00532 {
<a name="l00533"></a>00533         <a class="code" href="struct_purple_ssl_gnutls_data.html">PurpleSslGnutlsData</a> *gnutls_data = PURPLE_SSL_GNUTLS_DATA(gsc);
<a name="l00534"></a>00534         <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *prvcrt = NULL;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         <span class="comment">/* List of Certificate instances to return */</span>
<a name="l00537"></a>00537         GList * peer_certs = NULL;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         <span class="comment">/* List of raw certificates as given by GnuTLS */</span>
<a name="l00540"></a>00540         <span class="keyword">const</span> gnutls_datum *cert_list;
<a name="l00541"></a>00541         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cert_list_size = 0;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00544"></a>00544 
<a name="l00545"></a>00545         <span class="comment">/* This should never, ever happen. */</span>
<a name="l00546"></a>00546         g_return_val_if_fail( gnutls_certificate_type_get (gnutls_data-&gt;session) == GNUTLS_CRT_X509, NULL);
<a name="l00547"></a>00547 
<a name="l00548"></a>00548         <span class="comment">/* Get the certificate list from GnuTLS */</span>
<a name="l00549"></a>00549         <span class="comment">/* TODO: I am _pretty sure_ this doesn&#39;t block or do other exciting things */</span>
<a name="l00550"></a>00550         cert_list = gnutls_certificate_get_peers(gnutls_data-&gt;session,
<a name="l00551"></a>00551                                                  &amp;cert_list_size);
<a name="l00552"></a>00552 
<a name="l00553"></a>00553         <span class="comment">/* Convert each certificate to a Certificate and append it to the list */</span>
<a name="l00554"></a>00554         <span class="keywordflow">for</span> (i = 0; i &lt; cert_list_size; i++) {
<a name="l00555"></a>00555                 <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> * newcrt = x509_import_from_datum(cert_list[i],
<a name="l00556"></a>00556                                                               GNUTLS_X509_FMT_DER);
<a name="l00557"></a>00557                 <span class="comment">/* Append is somewhat inefficient on linked lists, but is easy</span>
<a name="l00558"></a>00558 <span class="comment">                   to read. If someone complains, I&#39;ll change it.</span>
<a name="l00559"></a>00559 <span class="comment">                   TODO: Is anyone complaining? (Maybe elb?) */</span>
<a name="l00560"></a>00560                 <span class="comment">/* only append if previous cert was actually signed by this one.</span>
<a name="l00561"></a>00561 <span class="comment">                 * Thanks Microsoft. */</span>
<a name="l00562"></a>00562                 <span class="keywordflow">if</span> ((prvcrt == NULL) || x509_certificate_signed_by(prvcrt, newcrt)) {
<a name="l00563"></a>00563                         peer_certs = g_list_append(peer_certs, newcrt);
<a name="l00564"></a>00564                         prvcrt = newcrt;
<a name="l00565"></a>00565                 } <span class="keywordflow">else</span> {
<a name="l00566"></a>00566                         x509_destroy_certificate(newcrt);
<a name="l00567"></a>00567                         <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls&quot;</span>, <span class="stringliteral">&quot;Dropping further peer certificates &quot;</span>
<a name="l00568"></a>00568                                                      <span class="stringliteral">&quot;because the chain is broken!\n&quot;</span>);
<a name="l00569"></a>00569                         <span class="keywordflow">break</span>;
<a name="l00570"></a>00570                 }
<a name="l00571"></a>00571         }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573         <span class="comment">/* cert_list doesn&#39;t need free()-ing */</span>
<a name="l00574"></a>00574 
<a name="l00575"></a>00575         <span class="keywordflow">return</span> peer_certs;
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 <span class="comment">/************************************************************************/</span>
<a name="l00579"></a>00579 <span class="comment">/* X.509 functionality                                                  */</span>
<a name="l00580"></a>00580 <span class="comment">/************************************************************************/</span>
<a name="l00581"></a>00581 <span class="keyword">const</span> gchar * SCHEME_NAME = <span class="stringliteral">&quot;x509&quot;</span>;
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 <span class="keyword">static</span> <a class="code" href="struct___purple_certificate_scheme.html">PurpleCertificateScheme</a> x509_gnutls;
<a name="l00584"></a>00584 
<a name="l00586"></a><a class="code" href="structx509__crtdata__t.html">00586</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00587"></a>00587         gint refcount;
<a name="l00588"></a>00588         gnutls_x509_crt crt;
<a name="l00589"></a>00589 } <a class="code" href="structx509__crtdata__t.html">x509_crtdata_t</a>;
<a name="l00590"></a>00590 
<a name="l00592"></a>00592 <span class="keyword">static</span> <a class="code" href="structx509__crtdata__t.html">x509_crtdata_t</a> *
<a name="l00593"></a>00593 x509_crtdata_addref(<a class="code" href="structx509__crtdata__t.html">x509_crtdata_t</a> *cd)
<a name="l00594"></a>00594 {
<a name="l00595"></a>00595         (cd-&gt;refcount)++;
<a name="l00596"></a>00596         <span class="keywordflow">return</span> cd;
<a name="l00597"></a>00597 }
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00600"></a>00600 x509_crtdata_delref(<a class="code" href="structx509__crtdata__t.html">x509_crtdata_t</a> *cd)
<a name="l00601"></a>00601 {
<a name="l00602"></a>00602         (cd-&gt;refcount)--;
<a name="l00603"></a>00603 
<a name="l00604"></a>00604         <span class="keywordflow">if</span> (cd-&gt;refcount &lt; 0)
<a name="l00605"></a>00605                 g_critical(<span class="stringliteral">&quot;Refcount of x509_crtdata_t is %d, which is less &quot;</span>
<a name="l00606"></a>00606                                 <span class="stringliteral">&quot;than zero!\n&quot;</span>, cd-&gt;refcount);
<a name="l00607"></a>00607 
<a name="l00608"></a>00608         <span class="comment">/* If the refcount reaches zero, kill the structure */</span>
<a name="l00609"></a>00609         <span class="keywordflow">if</span> (cd-&gt;refcount &lt;= 0) {
<a name="l00610"></a>00610                 <span class="comment">/* Kill the internal data */</span>
<a name="l00611"></a>00611                 gnutls_x509_crt_deinit( cd-&gt;crt );
<a name="l00612"></a>00612                 <span class="comment">/* And kill the struct */</span>
<a name="l00613"></a>00613                 g_free( cd );
<a name="l00614"></a>00614         }
<a name="l00615"></a>00615 }
<a name="l00616"></a>00616 
<a name="l00618"></a><a class="code" href="ssl-gnutls_8c.html#a6fa3a1267496da8148a77f8f0b4f3a6b">00618</a> <span class="preprocessor">#define X509_GET_GNUTLS_DATA(pcrt) ( ((x509_crtdata_t *) (pcrt-&gt;data))-&gt;crt)</span>
<a name="l00619"></a>00619 <span class="preprocessor"></span>
<a name="l00629"></a>00629 <span class="keyword">static</span> <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *
<a name="l00630"></a>00630 x509_import_from_datum(<span class="keyword">const</span> gnutls_datum dt, gnutls_x509_crt_fmt mode)
<a name="l00631"></a>00631 {
<a name="l00632"></a>00632         <span class="comment">/* Internal certificate data structure */</span>
<a name="l00633"></a>00633         <a class="code" href="structx509__crtdata__t.html">x509_crtdata_t</a> *certdat;
<a name="l00634"></a>00634         <span class="comment">/* New certificate to return */</span>
<a name="l00635"></a>00635         <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> * crt;
<a name="l00636"></a>00636 
<a name="l00637"></a>00637         <span class="comment">/* Allocate and prepare the internal certificate data */</span>
<a name="l00638"></a>00638         certdat = g_new0(<a class="code" href="structx509__crtdata__t.html">x509_crtdata_t</a>, 1);
<a name="l00639"></a>00639         gnutls_x509_crt_init(&amp;(certdat-&gt;crt));
<a name="l00640"></a>00640         certdat-&gt;refcount = 0;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642         <span class="comment">/* Perform the actual certificate parse */</span>
<a name="l00643"></a>00643         <span class="comment">/* Yes, certdat-&gt;crt should be passed as-is */</span>
<a name="l00644"></a>00644         gnutls_x509_crt_import(certdat-&gt;crt, &amp;dt, mode);
<a name="l00645"></a>00645 
<a name="l00646"></a>00646         <span class="comment">/* Allocate the certificate and load it with data */</span>
<a name="l00647"></a>00647         crt = g_new0(<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a>, 1);
<a name="l00648"></a>00648         crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> = &amp;x509_gnutls;
<a name="l00649"></a>00649         crt-&gt;<a class="code" href="struct___purple_certificate.html#ac2d150b349f3d00b3c333b5e16c30449">data</a> = x509_crtdata_addref(certdat);
<a name="l00650"></a>00650 
<a name="l00651"></a>00651         <span class="keywordflow">return</span> crt;
<a name="l00652"></a>00652 }
<a name="l00653"></a>00653 
<a name="l00659"></a>00659 <span class="keyword">static</span> <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *
<a name="l00660"></a>00660 x509_import_from_file(<span class="keyword">const</span> gchar * filename)
<a name="l00661"></a>00661 {
<a name="l00662"></a>00662         <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *crt;  <span class="comment">/* Certificate being constructed */</span>
<a name="l00663"></a>00663         gchar *buf;        <span class="comment">/* Used to load the raw file data */</span>
<a name="l00664"></a>00664         gsize buf_sz;      <span class="comment">/* Size of the above */</span>
<a name="l00665"></a>00665         gnutls_datum dt; <span class="comment">/* Struct to pass down to GnuTLS */</span>
<a name="l00666"></a>00666 
<a name="l00667"></a>00667         <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(<span class="stringliteral">&quot;gnutls&quot;</span>,
<a name="l00668"></a>00668                           <span class="stringliteral">&quot;Attempting to load X.509 certificate from %s\n&quot;</span>,
<a name="l00669"></a>00669                           filename);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671         <span class="comment">/* Next, we&#39;ll simply yank the entire contents of the file</span>
<a name="l00672"></a>00672 <span class="comment">           into memory */</span>
<a name="l00673"></a>00673         <span class="comment">/* TODO: Should I worry about very large files here? */</span>
<a name="l00674"></a>00674         g_return_val_if_fail(
<a name="l00675"></a>00675                 g_file_get_contents(filename,
<a name="l00676"></a>00676                             &amp;buf,
<a name="l00677"></a>00677                             &amp;buf_sz,
<a name="l00678"></a>00678                             NULL      <span class="comment">/* No error checking for now */</span>
<a name="l00679"></a>00679                 ),
<a name="l00680"></a>00680                 NULL);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682         <span class="comment">/* Load the datum struct */</span>
<a name="l00683"></a>00683         dt.data = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) buf;
<a name="l00684"></a>00684         dt.size = buf_sz;
<a name="l00685"></a>00685 
<a name="l00686"></a>00686         <span class="comment">/* Perform the conversion; files should be in PEM format */</span>
<a name="l00687"></a>00687         crt = x509_import_from_datum(dt, GNUTLS_X509_FMT_PEM);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689         <span class="comment">/* Cleanup */</span>
<a name="l00690"></a>00690         g_free(buf);
<a name="l00691"></a>00691 
<a name="l00692"></a>00692         <span class="keywordflow">return</span> crt;
<a name="l00693"></a>00693 }
<a name="l00694"></a>00694 
<a name="l00700"></a>00700 <span class="keyword">static</span> GSList *
<a name="l00701"></a>00701 x509_importcerts_from_file(<span class="keyword">const</span> gchar * filename)
<a name="l00702"></a>00702 {
<a name="l00703"></a>00703         <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *crt;  <span class="comment">/* Certificate being constructed */</span>
<a name="l00704"></a>00704         gchar *buf;        <span class="comment">/* Used to load the raw file data */</span>
<a name="l00705"></a>00705         gchar *begin, *end;
<a name="l00706"></a>00706         GSList *crts = NULL;
<a name="l00707"></a>00707         gsize buf_sz;      <span class="comment">/* Size of the above */</span>
<a name="l00708"></a>00708         gnutls_datum dt; <span class="comment">/* Struct to pass down to GnuTLS */</span>
<a name="l00709"></a>00709 
<a name="l00710"></a>00710         <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(<span class="stringliteral">&quot;gnutls&quot;</span>,
<a name="l00711"></a>00711                           <span class="stringliteral">&quot;Attempting to load X.509 certificates from %s\n&quot;</span>,
<a name="l00712"></a>00712                           filename);
<a name="l00713"></a>00713 
<a name="l00714"></a>00714         <span class="comment">/* Next, we&#39;ll simply yank the entire contents of the file</span>
<a name="l00715"></a>00715 <span class="comment">           into memory */</span>
<a name="l00716"></a>00716         <span class="comment">/* TODO: Should I worry about very large files here? */</span>
<a name="l00717"></a>00717         g_return_val_if_fail(
<a name="l00718"></a>00718                 g_file_get_contents(filename,
<a name="l00719"></a>00719                             &amp;buf,
<a name="l00720"></a>00720                             &amp;buf_sz,
<a name="l00721"></a>00721                             NULL      <span class="comment">/* No error checking for now */</span>
<a name="l00722"></a>00722                 ),
<a name="l00723"></a>00723                 NULL);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725         begin = buf;
<a name="l00726"></a>00726         <span class="keywordflow">while</span>((end = strstr(begin, <span class="stringliteral">&quot;-----END CERTIFICATE-----&quot;</span>)) != NULL) {
<a name="l00727"></a>00727                 end += <span class="keyword">sizeof</span>(<span class="stringliteral">&quot;-----END CERTIFICATE-----&quot;</span>)-1;
<a name="l00728"></a>00728                 <span class="comment">/* Load the datum struct */</span>
<a name="l00729"></a>00729                 dt.data = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) begin;
<a name="l00730"></a>00730                 dt.size = (end-begin);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732                 <span class="comment">/* Perform the conversion; files should be in PEM format */</span>
<a name="l00733"></a>00733                 crt = x509_import_from_datum(dt, GNUTLS_X509_FMT_PEM);
<a name="l00734"></a>00734                 crts = g_slist_prepend(crts, crt);
<a name="l00735"></a>00735                 begin = end;
<a name="l00736"></a>00736         }
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         <span class="comment">/* Cleanup */</span>
<a name="l00739"></a>00739         g_free(buf);
<a name="l00740"></a>00740 
<a name="l00741"></a>00741         <span class="keywordflow">return</span> crts;
<a name="l00742"></a>00742 }
<a name="l00743"></a>00743 
<a name="l00751"></a>00751 <span class="keyword">static</span> gboolean
<a name="l00752"></a>00752 x509_export_certificate(<span class="keyword">const</span> gchar *filename, <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *crt)
<a name="l00753"></a>00753 {
<a name="l00754"></a>00754         gnutls_x509_crt crt_dat; <span class="comment">/* GnuTLS cert struct */</span>
<a name="l00755"></a>00755         <span class="keywordtype">int</span> ret;
<a name="l00756"></a>00756         gchar * out_buf; <span class="comment">/* Data to output */</span>
<a name="l00757"></a>00757         <span class="keywordtype">size_t</span> out_size; <span class="comment">/* Output size */</span>
<a name="l00758"></a>00758         gboolean success = FALSE;
<a name="l00759"></a>00759 
<a name="l00760"></a>00760         <span class="comment">/* Paranoia paranoia paranoia! */</span>
<a name="l00761"></a>00761         g_return_val_if_fail(filename, FALSE);
<a name="l00762"></a>00762         g_return_val_if_fail(crt, FALSE);
<a name="l00763"></a>00763         g_return_val_if_fail(crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> == &amp;x509_gnutls, FALSE);
<a name="l00764"></a>00764         g_return_val_if_fail(crt-&gt;<a class="code" href="struct___purple_certificate.html#ac2d150b349f3d00b3c333b5e16c30449">data</a>, FALSE);
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         crt_dat = <a class="code" href="ssl-gnutls_8c.html#a6fa3a1267496da8148a77f8f0b4f3a6b">X509_GET_GNUTLS_DATA</a>(crt);
<a name="l00767"></a>00767 
<a name="l00768"></a>00768         <span class="comment">/* Obtain the output size required */</span>
<a name="l00769"></a>00769         out_size = 0;
<a name="l00770"></a>00770         ret = gnutls_x509_crt_export(crt_dat, GNUTLS_X509_FMT_PEM,
<a name="l00771"></a>00771                                      NULL, <span class="comment">/* Provide no buffer yet */</span>
<a name="l00772"></a>00772                                      &amp;out_size <span class="comment">/* Put size here */</span>
<a name="l00773"></a>00773                 );
<a name="l00774"></a>00774         g_return_val_if_fail(ret == GNUTLS_E_SHORT_MEMORY_BUFFER, FALSE);
<a name="l00775"></a>00775 
<a name="l00776"></a>00776         <span class="comment">/* Now allocate a buffer and *really* export it */</span>
<a name="l00777"></a>00777         out_buf = g_new0(gchar, out_size);
<a name="l00778"></a>00778         ret = gnutls_x509_crt_export(crt_dat, GNUTLS_X509_FMT_PEM,
<a name="l00779"></a>00779                                      out_buf, <span class="comment">/* Export to our new buffer */</span>
<a name="l00780"></a>00780                                      &amp;out_size <span class="comment">/* Put size here */</span>
<a name="l00781"></a>00781                 );
<a name="l00782"></a>00782         <span class="keywordflow">if</span> (ret != 0) {
<a name="l00783"></a>00783                 <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls/x509&quot;</span>,
<a name="l00784"></a>00784                                    <span class="stringliteral">&quot;Failed to export cert to buffer with code %d\n&quot;</span>,
<a name="l00785"></a>00785                                    ret);
<a name="l00786"></a>00786                 g_free(out_buf);
<a name="l00787"></a>00787                 <span class="keywordflow">return</span> FALSE;
<a name="l00788"></a>00788         }
<a name="l00789"></a>00789 
<a name="l00790"></a>00790         <span class="comment">/* Write it out to an actual file */</span>
<a name="l00791"></a>00791         success = purple_util_write_data_to_file_absolute(filename,
<a name="l00792"></a>00792                                                           out_buf, out_size);
<a name="l00793"></a>00793 
<a name="l00794"></a>00794         g_free(out_buf);
<a name="l00795"></a>00795         <span class="keywordflow">return</span> success;
<a name="l00796"></a>00796 }
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 <span class="keyword">static</span> <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *
<a name="l00799"></a>00799 x509_copy_certificate(<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *crt)
<a name="l00800"></a>00800 {
<a name="l00801"></a>00801         <a class="code" href="structx509__crtdata__t.html">x509_crtdata_t</a> *crtdat;
<a name="l00802"></a>00802         <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *newcrt;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804         g_return_val_if_fail(crt, NULL);
<a name="l00805"></a>00805         g_return_val_if_fail(crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> == &amp;x509_gnutls, NULL);
<a name="l00806"></a>00806 
<a name="l00807"></a>00807         crtdat = (<a class="code" href="structx509__crtdata__t.html">x509_crtdata_t</a> *) crt-&gt;<a class="code" href="struct___purple_certificate.html#ac2d150b349f3d00b3c333b5e16c30449">data</a>;
<a name="l00808"></a>00808 
<a name="l00809"></a>00809         newcrt = g_new0(<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a>, 1);
<a name="l00810"></a>00810         newcrt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> = &amp;x509_gnutls;
<a name="l00811"></a>00811         newcrt-&gt;<a class="code" href="struct___purple_certificate.html#ac2d150b349f3d00b3c333b5e16c30449">data</a> = x509_crtdata_addref(crtdat);
<a name="l00812"></a>00812 
<a name="l00813"></a>00813         <span class="keywordflow">return</span> newcrt;
<a name="l00814"></a>00814 }
<a name="l00823"></a>00823 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00824"></a>00824 x509_destroy_certificate(<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> * crt)
<a name="l00825"></a>00825 {
<a name="l00826"></a>00826         <span class="keywordflow">if</span> (NULL == crt) <span class="keywordflow">return</span>;
<a name="l00827"></a>00827 
<a name="l00828"></a>00828         <span class="comment">/* Check that the scheme is x509_gnutls */</span>
<a name="l00829"></a>00829         <span class="keywordflow">if</span> ( crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> != &amp;x509_gnutls ) {
<a name="l00830"></a>00830                 <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls&quot;</span>,
<a name="l00831"></a>00831                                    <span class="stringliteral">&quot;destroy_certificate attempted on certificate of wrong scheme (scheme was %s, expected %s)\n&quot;</span>,
<a name="l00832"></a>00832                                    crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a>-&gt;<a class="code" href="struct___purple_certificate_scheme.html#acff04b6134fbb2be54d1272bccd61b0c">name</a>,
<a name="l00833"></a>00833                                    SCHEME_NAME);
<a name="l00834"></a>00834                 <span class="keywordflow">return</span>;
<a name="l00835"></a>00835         }
<a name="l00836"></a>00836 
<a name="l00837"></a>00837         g_return_if_fail(crt-&gt;<a class="code" href="struct___purple_certificate.html#ac2d150b349f3d00b3c333b5e16c30449">data</a> != NULL);
<a name="l00838"></a>00838         g_return_if_fail(crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> != NULL);
<a name="l00839"></a>00839 
<a name="l00840"></a>00840         <span class="comment">/* Use the reference counting system to free (or not) the</span>
<a name="l00841"></a>00841 <span class="comment">           underlying data */</span>
<a name="l00842"></a>00842         x509_crtdata_delref((<a class="code" href="structx509__crtdata__t.html">x509_crtdata_t</a> *)crt-&gt;<a class="code" href="struct___purple_certificate.html#ac2d150b349f3d00b3c333b5e16c30449">data</a>);
<a name="l00843"></a>00843 
<a name="l00844"></a>00844         <span class="comment">/* Kill the structure itself */</span>
<a name="l00845"></a>00845         g_free(crt);
<a name="l00846"></a>00846 }
<a name="l00847"></a>00847 
<a name="l00856"></a>00856 <span class="keyword">static</span> gboolean
<a name="l00857"></a>00857 x509_certificate_signed_by(<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> * crt,
<a name="l00858"></a>00858                            <a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> * issuer)
<a name="l00859"></a>00859 {
<a name="l00860"></a>00860         gnutls_x509_crt crt_dat;
<a name="l00861"></a>00861         gnutls_x509_crt issuer_dat;
<a name="l00862"></a>00862         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> verify; <span class="comment">/* used to store result from GnuTLS verifier */</span>
<a name="l00863"></a>00863         <span class="keywordtype">int</span> ret;
<a name="l00864"></a>00864         gchar *crt_id = NULL;
<a name="l00865"></a>00865         gchar *issuer_id = NULL;
<a name="l00866"></a>00866 
<a name="l00867"></a>00867         g_return_val_if_fail(crt, FALSE);
<a name="l00868"></a>00868         g_return_val_if_fail(issuer, FALSE);
<a name="l00869"></a>00869 
<a name="l00870"></a>00870         <span class="comment">/* Verify that both certs are the correct scheme */</span>
<a name="l00871"></a>00871         g_return_val_if_fail(crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> == &amp;x509_gnutls, FALSE);
<a name="l00872"></a>00872         g_return_val_if_fail(issuer-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> == &amp;x509_gnutls, FALSE);
<a name="l00873"></a>00873 
<a name="l00874"></a>00874         <span class="comment">/* TODO: check for more nullness? */</span>
<a name="l00875"></a>00875 
<a name="l00876"></a>00876         crt_dat = <a class="code" href="ssl-gnutls_8c.html#a6fa3a1267496da8148a77f8f0b4f3a6b">X509_GET_GNUTLS_DATA</a>(crt);
<a name="l00877"></a>00877         issuer_dat = <a class="code" href="ssl-gnutls_8c.html#a6fa3a1267496da8148a77f8f0b4f3a6b">X509_GET_GNUTLS_DATA</a>(issuer);
<a name="l00878"></a>00878 
<a name="l00879"></a>00879         <span class="comment">/* First, let&#39;s check that crt.issuer is actually issuer */</span>
<a name="l00880"></a>00880         ret = gnutls_x509_crt_check_issuer(crt_dat, issuer_dat);
<a name="l00881"></a>00881         <span class="keywordflow">if</span> (ret &lt;= 0) {
<a name="l00882"></a>00882 
<a name="l00883"></a>00883                 <span class="keywordflow">if</span> (ret &lt; 0) {
<a name="l00884"></a>00884                         <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls/x509&quot;</span>,
<a name="l00885"></a>00885                                            <span class="stringliteral">&quot;GnuTLS error %d while checking certificate issuer match.&quot;</span>,
<a name="l00886"></a>00886                                            ret);
<a name="l00887"></a>00887                 } <span class="keywordflow">else</span> {
<a name="l00888"></a>00888                         gchar *crt_id, *issuer_id, *crt_issuer_id;
<a name="l00889"></a>00889                         crt_id = purple_certificate_get_unique_id(crt);
<a name="l00890"></a>00890                         issuer_id = purple_certificate_get_unique_id(issuer);
<a name="l00891"></a>00891                         crt_issuer_id =
<a name="l00892"></a>00892                                 purple_certificate_get_issuer_unique_id(crt);
<a name="l00893"></a>00893                         <a class="code" href="debug_8h.html#a112ab6ae0c750309516442f315002bee">purple_debug_info</a>(<span class="stringliteral">&quot;gnutls/x509&quot;</span>,
<a name="l00894"></a>00894                                           <span class="stringliteral">&quot;Certificate %s is issued by &quot;</span>
<a name="l00895"></a>00895                                           <span class="stringliteral">&quot;%s, which does not match %s.\n&quot;</span>,
<a name="l00896"></a>00896                                           crt_id ? crt_id : <span class="stringliteral">&quot;(null)&quot;</span>,
<a name="l00897"></a>00897                                           crt_issuer_id ? crt_issuer_id : <span class="stringliteral">&quot;(null)&quot;</span>,
<a name="l00898"></a>00898                                           issuer_id ? issuer_id : <span class="stringliteral">&quot;(null)&quot;</span>);
<a name="l00899"></a>00899                         g_free(crt_id);
<a name="l00900"></a>00900                         g_free(issuer_id);
<a name="l00901"></a>00901                         g_free(crt_issuer_id);
<a name="l00902"></a>00902                 }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904                 <span class="comment">/* The issuer is not correct, or there were errors */</span>
<a name="l00905"></a>00905                 <span class="keywordflow">return</span> FALSE;
<a name="l00906"></a>00906         }
<a name="l00907"></a>00907 
<a name="l00908"></a>00908         <span class="comment">/* Now, check the signature */</span>
<a name="l00909"></a>00909         <span class="comment">/* The second argument is a ptr to an array of &quot;trusted&quot; issuer certs,</span>
<a name="l00910"></a>00910 <span class="comment">           but we&#39;re only using one trusted one */</span>
<a name="l00911"></a>00911         ret = gnutls_x509_crt_verify(crt_dat, &amp;issuer_dat, 1,
<a name="l00912"></a>00912                                      <span class="comment">/* Permit signings by X.509v1 certs</span>
<a name="l00913"></a>00913 <span class="comment">                                        (Verisign and possibly others have</span>
<a name="l00914"></a>00914 <span class="comment">                                        root certificates that predate the</span>
<a name="l00915"></a>00915 <span class="comment">                                        current standard) */</span>
<a name="l00916"></a>00916                                      GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,
<a name="l00917"></a>00917                                      &amp;verify);
<a name="l00918"></a>00918 
<a name="l00919"></a>00919         <span class="keywordflow">if</span> (ret != 0) {
<a name="l00920"></a>00920                 <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls/x509&quot;</span>,
<a name="l00921"></a>00921                                    <span class="stringliteral">&quot;Attempted certificate verification caused a GnuTLS error code %d. I will just say the signature is bad, but you should look into this.\n&quot;</span>, ret);
<a name="l00922"></a>00922                 <span class="keywordflow">return</span> FALSE;
<a name="l00923"></a>00923         }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925 <span class="preprocessor">#ifdef HAVE_GNUTLS_CERT_INSECURE_ALGORITHM</span>
<a name="l00926"></a>00926 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (verify &amp; GNUTLS_CERT_INSECURE_ALGORITHM) {
<a name="l00927"></a>00927                 <span class="comment">/*</span>
<a name="l00928"></a>00928 <span class="comment">                 * A certificate in the chain is signed with an insecure</span>
<a name="l00929"></a>00929 <span class="comment">                 * algorithm. Put a warning into the log to make this error</span>
<a name="l00930"></a>00930 <span class="comment">                 * perfectly clear as soon as someone looks at the debug log is</span>
<a name="l00931"></a>00931 <span class="comment">                 * generated.</span>
<a name="l00932"></a>00932 <span class="comment">                 */</span>
<a name="l00933"></a>00933                 crt_id = purple_certificate_get_unique_id(crt);
<a name="l00934"></a>00934                 issuer_id = purple_certificate_get_issuer_unique_id(crt);
<a name="l00935"></a>00935                 <a class="code" href="debug_8h.html#a73ce6863806209621433421e69487799">purple_debug_warning</a>(<span class="stringliteral">&quot;gnutls/x509&quot;</span>,
<a name="l00936"></a>00936                                 <span class="stringliteral">&quot;Insecure hash algorithm used by %s to sign %s\n&quot;</span>,
<a name="l00937"></a>00937                                 issuer_id, crt_id);
<a name="l00938"></a>00938         }
<a name="l00939"></a>00939 <span class="preprocessor">#endif</span>
<a name="l00940"></a>00940 <span class="preprocessor"></span>
<a name="l00941"></a>00941         <span class="keywordflow">if</span> (verify &amp; GNUTLS_CERT_INVALID) {
<a name="l00942"></a>00942                 <span class="comment">/* Signature didn&#39;t check out, but at least</span>
<a name="l00943"></a>00943 <span class="comment">                   there were no errors*/</span>
<a name="l00944"></a>00944                 <span class="keywordflow">if</span> (!crt_id)
<a name="l00945"></a>00945                         crt_id = purple_certificate_get_unique_id(crt);
<a name="l00946"></a>00946                 <span class="keywordflow">if</span> (!issuer_id)
<a name="l00947"></a>00947                         issuer_id = purple_certificate_get_issuer_unique_id(crt);
<a name="l00948"></a>00948                 <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls/x509&quot;</span>,
<a name="l00949"></a>00949                                   <span class="stringliteral">&quot;Bad signature from %s on %s\n&quot;</span>,
<a name="l00950"></a>00950                                   issuer_id, crt_id);
<a name="l00951"></a>00951                 g_free(crt_id);
<a name="l00952"></a>00952                 g_free(issuer_id);
<a name="l00953"></a>00953 
<a name="l00954"></a>00954                 <span class="keywordflow">return</span> FALSE;
<a name="l00955"></a>00955         } <span class="comment">/* if (ret, etc.) */</span>
<a name="l00956"></a>00956 
<a name="l00957"></a>00957         <span class="comment">/* If we got here, the signature is good */</span>
<a name="l00958"></a>00958         <span class="keywordflow">return</span> TRUE;
<a name="l00959"></a>00959 }
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 <span class="keyword">static</span> GByteArray *
<a name="l00962"></a>00962 x509_sha1sum(<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *crt)
<a name="l00963"></a>00963 {
<a name="l00964"></a>00964         <span class="keywordtype">size_t</span> hashlen = 20; <span class="comment">/* SHA1 hashes are 20 bytes */</span>
<a name="l00965"></a>00965         <span class="keywordtype">size_t</span> tmpsz = hashlen; <span class="comment">/* Throw-away variable for GnuTLS to stomp on*/</span>
<a name="l00966"></a>00966         gnutls_x509_crt crt_dat;
<a name="l00967"></a>00967         GByteArray *hash; 
<a name="l00968"></a>00968         guchar hashbuf[hashlen]; 
<a name="l00970"></a>00970         g_return_val_if_fail(crt, NULL);
<a name="l00971"></a>00971 
<a name="l00972"></a>00972         crt_dat = <a class="code" href="ssl-gnutls_8c.html#a6fa3a1267496da8148a77f8f0b4f3a6b">X509_GET_GNUTLS_DATA</a>(crt);
<a name="l00973"></a>00973 
<a name="l00974"></a>00974         <span class="comment">/* Extract the fingerprint */</span>
<a name="l00975"></a>00975         g_return_val_if_fail(
<a name="l00976"></a>00976                 0 == gnutls_x509_crt_get_fingerprint(crt_dat, GNUTLS_MAC_SHA,
<a name="l00977"></a>00977                                                      hashbuf, &amp;tmpsz),
<a name="l00978"></a>00978                 NULL);
<a name="l00979"></a>00979 
<a name="l00980"></a>00980         <span class="comment">/* This shouldn&#39;t happen */</span>
<a name="l00981"></a>00981         g_return_val_if_fail(tmpsz == hashlen, NULL);
<a name="l00982"></a>00982 
<a name="l00983"></a>00983         <span class="comment">/* Okay, now create and fill hash array */</span>
<a name="l00984"></a>00984         hash = g_byte_array_new();
<a name="l00985"></a>00985         g_byte_array_append(hash, hashbuf, hashlen);
<a name="l00986"></a>00986 
<a name="l00987"></a>00987         <span class="keywordflow">return</span> hash;
<a name="l00988"></a>00988 }
<a name="l00989"></a>00989 
<a name="l00990"></a>00990 <span class="keyword">static</span> gchar *
<a name="l00991"></a>00991 x509_cert_dn (<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *crt)
<a name="l00992"></a>00992 {
<a name="l00993"></a>00993         gnutls_x509_crt cert_dat;
<a name="l00994"></a>00994         gchar *dn = NULL;
<a name="l00995"></a>00995         <span class="keywordtype">size_t</span> dn_size;
<a name="l00996"></a>00996 
<a name="l00997"></a>00997         g_return_val_if_fail(crt, NULL);
<a name="l00998"></a>00998         g_return_val_if_fail(crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> == &amp;x509_gnutls, NULL);
<a name="l00999"></a>00999 
<a name="l01000"></a>01000         cert_dat = <a class="code" href="ssl-gnutls_8c.html#a6fa3a1267496da8148a77f8f0b4f3a6b">X509_GET_GNUTLS_DATA</a>(crt);
<a name="l01001"></a>01001 
<a name="l01002"></a>01002         <span class="comment">/* Figure out the length of the Distinguished Name */</span>
<a name="l01003"></a>01003         <span class="comment">/* Claim that the buffer is size 0 so GnuTLS just tells us how much</span>
<a name="l01004"></a>01004 <span class="comment">           space it needs */</span>
<a name="l01005"></a>01005         dn_size = 0;
<a name="l01006"></a>01006         gnutls_x509_crt_get_dn(cert_dat, dn, &amp;dn_size);
<a name="l01007"></a>01007 
<a name="l01008"></a>01008         <span class="comment">/* Now allocate and get the Distinguished Name */</span>
<a name="l01009"></a>01009         <span class="comment">/* Old versions of GnuTLS have an off-by-one error in reporting</span>
<a name="l01010"></a>01010 <span class="comment">           the size of the needed buffer in some functions, so allocate</span>
<a name="l01011"></a>01011 <span class="comment">           an extra byte */</span>
<a name="l01012"></a>01012         dn = g_new0(gchar, ++dn_size);
<a name="l01013"></a>01013         <span class="keywordflow">if</span> (0 != gnutls_x509_crt_get_dn(cert_dat, dn, &amp;dn_size)) {
<a name="l01014"></a>01014                 <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls/x509&quot;</span>,
<a name="l01015"></a>01015                                    <span class="stringliteral">&quot;Failed to get Distinguished Name\n&quot;</span>);
<a name="l01016"></a>01016                 g_free(dn);
<a name="l01017"></a>01017                 <span class="keywordflow">return</span> NULL;
<a name="l01018"></a>01018         }
<a name="l01019"></a>01019 
<a name="l01020"></a>01020         <span class="keywordflow">return</span> dn;
<a name="l01021"></a>01021 }
<a name="l01022"></a>01022 
<a name="l01023"></a>01023 <span class="keyword">static</span> gchar *
<a name="l01024"></a>01024 x509_issuer_dn (<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *crt)
<a name="l01025"></a>01025 {
<a name="l01026"></a>01026         gnutls_x509_crt cert_dat;
<a name="l01027"></a>01027         gchar *dn = NULL;
<a name="l01028"></a>01028         <span class="keywordtype">size_t</span> dn_size;
<a name="l01029"></a>01029 
<a name="l01030"></a>01030         g_return_val_if_fail(crt, NULL);
<a name="l01031"></a>01031         g_return_val_if_fail(crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> == &amp;x509_gnutls, NULL);
<a name="l01032"></a>01032 
<a name="l01033"></a>01033         cert_dat = <a class="code" href="ssl-gnutls_8c.html#a6fa3a1267496da8148a77f8f0b4f3a6b">X509_GET_GNUTLS_DATA</a>(crt);
<a name="l01034"></a>01034 
<a name="l01035"></a>01035         <span class="comment">/* Figure out the length of the Distinguished Name */</span>
<a name="l01036"></a>01036         <span class="comment">/* Claim that the buffer is size 0 so GnuTLS just tells us how much</span>
<a name="l01037"></a>01037 <span class="comment">           space it needs */</span>
<a name="l01038"></a>01038         dn_size = 0;
<a name="l01039"></a>01039         gnutls_x509_crt_get_issuer_dn(cert_dat, dn, &amp;dn_size);
<a name="l01040"></a>01040 
<a name="l01041"></a>01041         <span class="comment">/* Now allocate and get the Distinguished Name */</span>
<a name="l01042"></a>01042         <span class="comment">/* Old versions of GnuTLS have an off-by-one error in reporting</span>
<a name="l01043"></a>01043 <span class="comment">           the size of the needed buffer in some functions, so allocate</span>
<a name="l01044"></a>01044 <span class="comment">           an extra byte */</span>
<a name="l01045"></a>01045         dn = g_new0(gchar, ++dn_size);
<a name="l01046"></a>01046         <span class="keywordflow">if</span> (0 != gnutls_x509_crt_get_issuer_dn(cert_dat, dn, &amp;dn_size)) {
<a name="l01047"></a>01047                 <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls/x509&quot;</span>,
<a name="l01048"></a>01048                                    <span class="stringliteral">&quot;Failed to get issuer&#39;s Distinguished &quot;</span>
<a name="l01049"></a>01049                                    <span class="stringliteral">&quot;Name\n&quot;</span>);
<a name="l01050"></a>01050                 g_free(dn);
<a name="l01051"></a>01051                 <span class="keywordflow">return</span> NULL;
<a name="l01052"></a>01052         }
<a name="l01053"></a>01053 
<a name="l01054"></a>01054         <span class="keywordflow">return</span> dn;
<a name="l01055"></a>01055 }
<a name="l01056"></a>01056 
<a name="l01057"></a>01057 <span class="keyword">static</span> gchar *
<a name="l01058"></a>01058 x509_common_name (<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *crt)
<a name="l01059"></a>01059 {
<a name="l01060"></a>01060         gnutls_x509_crt cert_dat;
<a name="l01061"></a>01061         gchar *cn = NULL;
<a name="l01062"></a>01062         <span class="keywordtype">size_t</span> cn_size;
<a name="l01063"></a>01063         <span class="keywordtype">int</span> ret;
<a name="l01064"></a>01064 
<a name="l01065"></a>01065         g_return_val_if_fail(crt, NULL);
<a name="l01066"></a>01066         g_return_val_if_fail(crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> == &amp;x509_gnutls, NULL);
<a name="l01067"></a>01067 
<a name="l01068"></a>01068         cert_dat = <a class="code" href="ssl-gnutls_8c.html#a6fa3a1267496da8148a77f8f0b4f3a6b">X509_GET_GNUTLS_DATA</a>(crt);
<a name="l01069"></a>01069 
<a name="l01070"></a>01070         <span class="comment">/* Figure out the length of the Common Name */</span>
<a name="l01071"></a>01071         <span class="comment">/* Claim that the buffer is size 0 so GnuTLS just tells us how much</span>
<a name="l01072"></a>01072 <span class="comment">           space it needs */</span>
<a name="l01073"></a>01073         cn_size = 0;
<a name="l01074"></a>01074         gnutls_x509_crt_get_dn_by_oid(cert_dat,
<a name="l01075"></a>01075                                       GNUTLS_OID_X520_COMMON_NAME,
<a name="l01076"></a>01076                                       0, <span class="comment">/* First CN found, please */</span>
<a name="l01077"></a>01077                                       0, <span class="comment">/* Not in raw mode */</span>
<a name="l01078"></a>01078                                       cn, &amp;cn_size);
<a name="l01079"></a>01079 
<a name="l01080"></a>01080         <span class="comment">/* Now allocate and get the Common Name */</span>
<a name="l01081"></a>01081         <span class="comment">/* Old versions of GnuTLS have an off-by-one error in reporting</span>
<a name="l01082"></a>01082 <span class="comment">           the size of the needed buffer in some functions, so allocate</span>
<a name="l01083"></a>01083 <span class="comment">           an extra byte */</span>
<a name="l01084"></a>01084         cn = g_new0(gchar, ++cn_size);
<a name="l01085"></a>01085         ret = gnutls_x509_crt_get_dn_by_oid(cert_dat,
<a name="l01086"></a>01086                                             GNUTLS_OID_X520_COMMON_NAME,
<a name="l01087"></a>01087                                             0, <span class="comment">/* First CN found, please */</span>
<a name="l01088"></a>01088                                             0, <span class="comment">/* Not in raw mode */</span>
<a name="l01089"></a>01089                                             cn, &amp;cn_size);
<a name="l01090"></a>01090         <span class="keywordflow">if</span> (ret != 0) {
<a name="l01091"></a>01091                 <a class="code" href="debug_8h.html#a92d772544aec6c280006448aa9a1ef50">purple_debug_error</a>(<span class="stringliteral">&quot;gnutls/x509&quot;</span>,
<a name="l01092"></a>01092                                    <span class="stringliteral">&quot;Failed to get Common Name\n&quot;</span>);
<a name="l01093"></a>01093                 g_free(cn);
<a name="l01094"></a>01094                 <span class="keywordflow">return</span> NULL;
<a name="l01095"></a>01095         }
<a name="l01096"></a>01096 
<a name="l01097"></a>01097         <span class="keywordflow">return</span> cn;
<a name="l01098"></a>01098 }
<a name="l01099"></a>01099 
<a name="l01100"></a>01100 <span class="keyword">static</span> gboolean
<a name="l01101"></a>01101 x509_check_name (<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *crt, <span class="keyword">const</span> gchar *name)
<a name="l01102"></a>01102 {
<a name="l01103"></a>01103         gnutls_x509_crt crt_dat;
<a name="l01104"></a>01104 
<a name="l01105"></a>01105         g_return_val_if_fail(crt, FALSE);
<a name="l01106"></a>01106         g_return_val_if_fail(crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> == &amp;x509_gnutls, FALSE);
<a name="l01107"></a>01107         g_return_val_if_fail(name, FALSE);
<a name="l01108"></a>01108 
<a name="l01109"></a>01109         crt_dat = <a class="code" href="ssl-gnutls_8c.html#a6fa3a1267496da8148a77f8f0b4f3a6b">X509_GET_GNUTLS_DATA</a>(crt);
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         <span class="keywordflow">if</span> (gnutls_x509_crt_check_hostname(crt_dat, name)) {
<a name="l01112"></a>01112                 <span class="keywordflow">return</span> TRUE;
<a name="l01113"></a>01113         } <span class="keywordflow">else</span> {
<a name="l01114"></a>01114                 <span class="keywordflow">return</span> FALSE;
<a name="l01115"></a>01115         }
<a name="l01116"></a>01116 }
<a name="l01117"></a>01117 
<a name="l01118"></a>01118 <span class="keyword">static</span> gboolean
<a name="l01119"></a>01119 x509_times (<a class="code" href="struct___purple_certificate.html">PurpleCertificate</a> *crt, time_t *activation, time_t *expiration)
<a name="l01120"></a>01120 {
<a name="l01121"></a>01121         gnutls_x509_crt crt_dat;
<a name="l01122"></a>01122         <span class="comment">/* GnuTLS time functions return this on error */</span>
<a name="l01123"></a>01123         <span class="keyword">const</span> time_t errval = (time_t) (-1);
<a name="l01124"></a>01124         gboolean success = TRUE;
<a name="l01125"></a>01125 
<a name="l01126"></a>01126         g_return_val_if_fail(crt, FALSE);
<a name="l01127"></a>01127         g_return_val_if_fail(crt-&gt;<a class="code" href="struct___purple_certificate.html#ad40d8dd0a806d5bd9b4b409e13aab333">scheme</a> == &amp;x509_gnutls, FALSE);
<a name="l01128"></a>01128 
<a name="l01129"></a>01129         crt_dat = <a class="code" href="ssl-gnutls_8c.html#a6fa3a1267496da8148a77f8f0b4f3a6b">X509_GET_GNUTLS_DATA</a>(crt);
<a name="l01130"></a>01130 
<a name="l01131"></a>01131         <span class="keywordflow">if</span> (activation) {
<a name="l01132"></a>01132                 *activation = gnutls_x509_crt_get_activation_time(crt_dat);
<a name="l01133"></a>01133                 <span class="keywordflow">if</span> (*activation == errval)
<a name="l01134"></a>01134                         success = FALSE;
<a name="l01135"></a>01135         }
<a name="l01136"></a>01136         <span class="keywordflow">if</span> (expiration) {
<a name="l01137"></a>01137                 *expiration = gnutls_x509_crt_get_expiration_time(crt_dat);
<a name="l01138"></a>01138                 <span class="keywordflow">if</span> (*expiration == errval)
<a name="l01139"></a>01139                         success = FALSE;
<a name="l01140"></a>01140         }
<a name="l01141"></a>01141 
<a name="l01142"></a>01142         <span class="keywordflow">return</span> success;
<a name="l01143"></a>01143 }
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 <span class="comment">/* X.509 certificate operations provided by this plugin */</span>
<a name="l01146"></a>01146 <span class="keyword">static</span> <a class="code" href="struct___purple_certificate_scheme.html">PurpleCertificateScheme</a> x509_gnutls = {
<a name="l01147"></a>01147         <span class="stringliteral">&quot;x509&quot;</span>,                          <span class="comment">/* Scheme name */</span>
<a name="l01148"></a>01148         N_(<span class="stringliteral">&quot;X.509 Certificates&quot;</span>),        <span class="comment">/* User-visible scheme name */</span>
<a name="l01149"></a>01149         x509_import_from_file,           <span class="comment">/* Certificate import function */</span>
<a name="l01150"></a>01150         x509_export_certificate,         <span class="comment">/* Certificate export function */</span>
<a name="l01151"></a>01151         x509_copy_certificate,           <span class="comment">/* Copy */</span>
<a name="l01152"></a>01152         x509_destroy_certificate,        <span class="comment">/* Destroy cert */</span>
<a name="l01153"></a>01153         x509_certificate_signed_by,      <span class="comment">/* Signature checker */</span>
<a name="l01154"></a>01154         x509_sha1sum,                    <span class="comment">/* SHA1 fingerprint */</span>
<a name="l01155"></a>01155         x509_cert_dn,                    <span class="comment">/* Unique ID */</span>
<a name="l01156"></a>01156         x509_issuer_dn,                  <span class="comment">/* Issuer Unique ID */</span>
<a name="l01157"></a>01157         x509_common_name,                <span class="comment">/* Subject name */</span>
<a name="l01158"></a>01158         x509_check_name,                 <span class="comment">/* Check subject name */</span>
<a name="l01159"></a>01159         x509_times,                      <span class="comment">/* Activation/Expiration time */</span>
<a name="l01160"></a>01160         x509_importcerts_from_file,      <span class="comment">/* Multiple certificates import function */</span>
<a name="l01161"></a>01161 
<a name="l01162"></a>01162         NULL,
<a name="l01163"></a>01163         NULL,
<a name="l01164"></a>01164         NULL
<a name="l01165"></a>01165 
<a name="l01166"></a>01166 };
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 <span class="keyword">static</span> <a class="code" href="struct_purple_ssl_ops.html">PurpleSslOps</a> ssl_ops =
<a name="l01169"></a>01169 {
<a name="l01170"></a>01170         ssl_gnutls_init,
<a name="l01171"></a>01171         ssl_gnutls_uninit,
<a name="l01172"></a>01172         ssl_gnutls_connect,
<a name="l01173"></a>01173         ssl_gnutls_close,
<a name="l01174"></a>01174         ssl_gnutls_read,
<a name="l01175"></a>01175         ssl_gnutls_write,
<a name="l01176"></a>01176         ssl_gnutls_get_peer_certificates,
<a name="l01177"></a>01177 
<a name="l01178"></a>01178         <span class="comment">/* padding */</span>
<a name="l01179"></a>01179         NULL,
<a name="l01180"></a>01180         NULL,
<a name="l01181"></a>01181         NULL
<a name="l01182"></a>01182 };
<a name="l01183"></a>01183 
<a name="l01184"></a>01184 <span class="keyword">static</span> gboolean
<a name="l01185"></a>01185 plugin_load(<a class="code" href="struct___purple_plugin.html">PurplePlugin</a> *plugin)
<a name="l01186"></a>01186 {
<a name="l01187"></a>01187         <span class="keywordflow">if</span>(!purple_ssl_get_ops()) {
<a name="l01188"></a>01188                 purple_ssl_set_ops(&amp;ssl_ops);
<a name="l01189"></a>01189         }
<a name="l01190"></a>01190 
<a name="l01191"></a>01191         <span class="comment">/* Init GNUTLS now so others can use it even if sslconn never does */</span>
<a name="l01192"></a>01192         ssl_gnutls_init_gnutls();
<a name="l01193"></a>01193 
<a name="l01194"></a>01194         <span class="comment">/* Register that we&#39;re providing an X.509 CertScheme */</span>
<a name="l01195"></a>01195         purple_certificate_register_scheme( &amp;x509_gnutls );
<a name="l01196"></a>01196 
<a name="l01197"></a>01197         <span class="keywordflow">return</span> TRUE;
<a name="l01198"></a>01198 }
<a name="l01199"></a>01199 
<a name="l01200"></a>01200 <span class="keyword">static</span> gboolean
<a name="l01201"></a>01201 plugin_unload(<a class="code" href="struct___purple_plugin.html">PurplePlugin</a> *plugin)
<a name="l01202"></a>01202 {
<a name="l01203"></a>01203         <span class="keywordflow">if</span>(purple_ssl_get_ops() == &amp;ssl_ops) {
<a name="l01204"></a>01204                 purple_ssl_set_ops(NULL);
<a name="l01205"></a>01205         }
<a name="l01206"></a>01206 
<a name="l01207"></a>01207         purple_certificate_unregister_scheme( &amp;x509_gnutls );
<a name="l01208"></a>01208 
<a name="l01209"></a>01209         <span class="keywordflow">return</span> TRUE;
<a name="l01210"></a>01210 }
<a name="l01211"></a>01211 
<a name="l01212"></a>01212 <span class="keyword">static</span> <a class="code" href="struct___purple_plugin_info.html">PurplePluginInfo</a> info =
<a name="l01213"></a>01213 {
<a name="l01214"></a>01214         PURPLE_PLUGIN_MAGIC,
<a name="l01215"></a>01215         <a class="code" href="version_8h.html#a046c2ee58f2b6ed94f29c524c2241f4d">PURPLE_MAJOR_VERSION</a>,
<a name="l01216"></a>01216         <a class="code" href="version_8h.html#aa67c27a6835b76d1b01df29cb3dc9f07">PURPLE_MINOR_VERSION</a>,
<a name="l01217"></a>01217         <a class="code" href="plugin_8h.html#a0e1cfd7954f1157f5ed3ccb42e6f6d58a204952e5e56c3ae37f432de93ff75e59">PURPLE_PLUGIN_STANDARD</a>,                             
<a name="l01218"></a>01218         NULL,                                             
<a name="l01219"></a>01219         PURPLE_PLUGIN_FLAG_INVISIBLE,                       
<a name="l01220"></a>01220         NULL,                                             
<a name="l01221"></a>01221         PURPLE_PRIORITY_DEFAULT,                            
<a name="l01223"></a>01223         SSL_GNUTLS_PLUGIN_ID,                             
<a name="l01224"></a>01224         N_(<span class="stringliteral">&quot;GNUTLS&quot;</span>),                                     
<a name="l01225"></a>01225         DISPLAY_VERSION,                                  
<a name="l01227"></a>01227         N_(<span class="stringliteral">&quot;Provides SSL support through GNUTLS.&quot;</span>),
<a name="l01229"></a>01229         N_(<span class="stringliteral">&quot;Provides SSL support through GNUTLS.&quot;</span>),
<a name="l01230"></a>01230         <span class="stringliteral">&quot;Christian Hammond &lt;chipx86@gnupdate.org&gt;&quot;</span>,
<a name="l01231"></a>01231         PURPLE_WEBSITE,                                     
<a name="l01233"></a>01233         plugin_load,                                      
<a name="l01234"></a>01234         plugin_unload,                                    
<a name="l01235"></a>01235         NULL,                                             
<a name="l01237"></a>01237         NULL,                                             
<a name="l01238"></a>01238         NULL,                                             
<a name="l01239"></a>01239         NULL,                                             
<a name="l01240"></a>01240         NULL,                                             
<a name="l01242"></a>01242         <span class="comment">/* padding */</span>
<a name="l01243"></a>01243         NULL,
<a name="l01244"></a>01244         NULL,
<a name="l01245"></a>01245         NULL,
<a name="l01246"></a>01246         NULL
<a name="l01247"></a>01247 };
<a name="l01248"></a>01248 
<a name="l01249"></a>01249 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01250"></a>01250 init_plugin(<a class="code" href="struct___purple_plugin.html">PurplePlugin</a> *plugin)
<a name="l01251"></a>01251 {
<a name="l01252"></a>01252 }
<a name="l01253"></a>01253 
<a name="l01254"></a>01254 PURPLE_INIT_PLUGIN(ssl_gnutls, init_plugin, info)
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="ssl-gnutls_8c.html">ssl-gnutls.c</a>      </li>
      <li class="footer">Generated on Sun Mar 24 2013 16:05:10 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
